{"cells":[{"metadata":{"_uuid":"007bf6a70936c7370199013dbc60537cf86b2f0a","_execution_state":"idle","trusted":true},"cell_type":"code","source":"## Importing packages\n\n# This R environment comes with all of CRAN and many other helpful packages preinstalled.\n# You can see which packages are installed by checking out the kaggle/rstats docker image: \n# https://github.com/kaggle/docker-rstats\n\nlibrary(tidyverse) # metapackage with lots of helpful functions\n\ndados = read.csv('../input/train.csv', sep = ',', header = T)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"07c6fb58f7057d2312e71192c4bc7258934bd1ad"},"cell_type":"code","source":"# Árvore\nlibrary(rpart)\nlibrary(rpart.plot)\n\ndados$Survived = as.factor(dados$Survived)\n\n# Treinando a árvore para diferentes subamostras \ndadosBoot = sample_n(dados, size = nrow(dados), replace = T)\nmod1 = rpart(Survived ~ Sex + Age + Pclass + SibSp + Parch + Fare, data = dadosBoot)\nrpart.plot(mod1)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"595b7d661692cae0c5cf00a555e797d64b97c538"},"cell_type":"code","source":"# Eliminando do data set as variáveis que não queremos usar para construir os algoritmos de previsão\ndados = dados %>% select(-c('Name', 'Ticket', 'Cabin', 'Embarked'))\ndados$Survived = factor(dados$Survived)\ncolnames(dados)\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"71451306f7162cea232d80b5fbba98845844fd98"},"cell_type":"code","source":"passageiro_teste = sample_n(dados, 1)\n\ndados_train = dados %>% filter(PassengerId != passageiro_teste$PassengerId)\n\n# Número de bootstraps para estimar a variância da previsão\nnboot = 100\n\n# Número de boostraps para o bagging\nnbag = 30\n\n# Número de variáveis para sortear a cada árvore\nnvar = 3\n\ni = 1\n\nprev_arvore = matrix(nrow = nboot, ncol = 1)\nprev_bag = matrix(nrow = nboot, ncol= 1)\nprev_rf = matrix(nrow = nboot, ncol= 1)\n\ndados_boot = sample_n(dados_train, nrow(dados_train), replace = T)\n# Obtenho a árvore\narvore = rpart(data = dados_boot, Survived ~ Sex + Age + Pclass + SibSp + Parch + Fare)\n# Obtenho a previsão\nprev_arvore[i] = predict(arvore, passageiro_teste)[1]","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"cc2f2474e6588a496738190edc46f0cc410173f1"},"cell_type":"code","source":"# Verificando a variância das previsões\n\n# Vamos fazer o seguinte: vou sortear um passageiro e retirá-lo do banco de dados\n# Em seguida, aplico um bootstrapping nos passageiros restantes.\n# Para cada amostra sorteada no bootstrapping, ajusto um modelo de árvore e calculo a previsão para o passageiro que foi separado.\n# Também faço um bootstrapping em cima dessa nova amostra, e calculo a previsão feita usando o bagging.\n\npassageiro_teste = sample_n(dados, 1)\n\ndados_train = dados %>% filter(PassengerId != passageiro_teste$PassengerId)\n\n# Número de bootstraps para estimar a variância da previsão\nnboot = 100\n\n# Número de boostraps para o bagging\nnbag = 30\n\n# Número de variáveis para sortear a cada árvore\nnvar = 3\n\nprev_arvore = matrix(nrow = nboot, ncol = 1)\nprev_bag = matrix(nrow = nboot, ncol= 1)\nprev_rf = matrix(nrow = nboot, ncol= 1)\nfor(i in 1:nboot) {\n    # Obtenho a amostra\n    dados_boot = sample_n(dados_train, nrow(dados_train), replace = T)\n    # Obtenho a árvore\n    arvore = rpart(data = dados_boot, Survived ~ Sex + Age + Pclass + SibSp + Parch + Fare)\n    # Obtenho a previsão\n    prev_arvore[i] = predict(arvore, passageiro_teste)[1]\n    \n    # Fazendo o bagging\n    pbag = 0\n    prf = 0\n    for(j in 1:nbag) {\n        dados_bag = sample_n(dados_boot, nrow(dados_boot), replace = T)\n        arvore_tmp = rpart(data = dados_bag, Survived ~ Sex + Age + Pclass + SibSp + Parch + Fare)\n        \n        # Atualizando a previsão do bagging\n        pbag = pbag + predict(arvore_tmp, passageiro_teste)[1]  / nbag\n        \n        # Incluindo a seleção aleatória de variáveis\n        dados_rf = cbind(Survived = dados_bag$Survived, dados_bag %>% select(-c(PassengerId, Survived)) %>% sample(nvar))\n        arvore_tmp = rpart(data = dados_rf, eval(paste0(\"Survived~\", colnames(dados_rf %>% select(-Survived)))))    }\n    \n        # Atualizando a previsão do bagging + sav\n        prf = prf + predict(arvore_tmp, passageiro_teste)[1] / nbag\n    \n    # Previsão final do bagging\n    prev_bag[i] = pbag\n    prev_rf[i] = prf\n}","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"ff9492879df29658e005d00aab6f01bf2af24419"},"cell_type":"code","source":"# Calculando o desvio-padrão das previsões em cada caso\nsd(prev_arvore)\nsd(prev_bag)\nsd(prev_rf)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"78680d7a8af9c001ae914442bdab9ff83a5aab7c"},"cell_type":"code","source":"# Histogramas\ndfplot = rbind(data.frame(prev = prev_arvore, Modelo = rep('Árvore', length(prev_arvore))), data.frame(prev = prev_bag, Modelo = rep('Bagging', length(prev_bag))), data.frame(prev = prev_rf, Modelo = rep('RF', length(prev_rf))))\ng = ggplot(data = dfplot %>% subset(Modelo %in% c('Árvore', 'Bagging')), aes(x = prev, fill = Modelo))\ng + geom_histogram(aes(y=..count../sum(..count..)), bins = 10, alpha = 0.3, position = 'identity') +\nxlab(\"Previsão\") + ylab(\"Frequência\") + ggtitle(\"Previsões- árvore x bagging\") +\ntheme(plot.title = element_text(size = 30, face = \"bold\"))\n\ng = ggplot(data = dfplot, aes(x = prev, fill = Modelo))\ng + geom_histogram(aes(y=..count../sum(..count..)), bins = 20, alpha = 0.3, position = 'identity') +\nxlab(\"Previsão\") + ylab(\"Frequência\") + ggtitle(\"Previsões- árvore x bagging x rf\") +\ntheme(plot.title = element_text(size = 25, face = \"bold\"))\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"1e4aa6eb7e62f5683795e8540cda2b05b3ab9c4f"},"cell_type":"code","source":"# Pacote para random forest\nlibrary(randomForest)\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"a5f7e581020bde7864397eebb58b998cf83fba9b"},"cell_type":"code","source":"# Preenchendo missing values de idade com a média. Dá pra melhorar...\ndados[which(is.na(dados$Age)), 'Age'] = mean(dados$Age, na.rm = T)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"abca916a8d63e48ff74e6a1acaef1f4323416e1c"},"cell_type":"code","source":"# Grid para busca\ng_ntree = c(10, 100, 200)\ng_mtry = c(2, 3, 4, 5, 6)\ng_maxnodes = c(3, 5, 10, 20, 40)\n\n# Número de combinações\nn = length(g_ntree) * length(g_mtry) * length(g_maxnodes)\n\n# Parãmetro para cross-validation\nn_fold = 10\n\n# Número de indivíduos em cada fatia\nn_ind = floor(nrow(dados) / n_fold)\n\n# Primeiro vamos calcular quanto tempo demora para fazer o cross-validation com uma combinação\ni_ntree = 2\ni_mtry = 3\ni_maxnodes = 4\n\ninicio = Sys.time()\n\n# Sorteio uma permutação das linhas do dataset\nindices = sample(1:nrow(dados))\n\nntree = g_ntree[i_ntree]\nmtry = g_mtry[i_mtry]\nmaxnodes = g_maxnodes[i_maxnodes]\nacc = 0\n# Para cada fatia\nfor(i in 1:n_fold) {\n    test = dados[(indices[((i-1)*n_ind):(i*n_ind)]),] # Teste na fatia\n    train = dados[-(indices[((i-1)*n_ind):(i*n_ind)]),] # Treino no restante\n    \n    modrf = randomForest(Survived~., data = train, ntree = ntree, mtry = mtry, maxnodes = maxnodes, na.action = na.roughfix)\n    \n    # Calculando as previsões\n    prev = predict(modrf, test %>% select(-Survived))\n    \n    # Atualizando a acurácia média\n    acc = acc + (sum(prev == test$Survived) / length(prev)) / n_fold   \n}\n\nfim = Sys.time()\nt = (fim - inicio)\n\nprint(paste0(\"Tempo estimado para rodar todas as \", n, \" combinações:\"))\nprint(n*t)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"ae0505b48e897350c87a81c12d3442425ba3c799"},"cell_type":"code","source":"# SE o tempo for razoável, vou rodar a busca exaustiva\ninicio = Sys.time()\n\ndfres = data.frame(ntree = integer(), mtry = integer(), maxnodes = integer(), acc = numeric(), stringsAsFactors = F)\n# Sorteio uma permutação das linhas do dataset\nindices = sample(1:nrow(dados))\nfor(i_ntree in 1:length(g_ntree)) {\n    ntree = g_ntree[i_ntree]\n    for(i_mtry in 1:length(g_mtry)){\n         mtry = g_mtry[i_mtry]\n        for(i_maxnodes in 1:length(g_maxnodes)) {\n            maxnodes = g_maxnodes[i_maxnodes]\n            \n            acc = 0\n            # Percorro as fatias do dataset\n            for(i in 1:n_fold) {\n                test = dados[(indices[((i-1)*n_ind):(i*n_ind)]),] # Teste na fatia\n                train = dados[-(indices[((i-1)*n_ind):(i*n_ind)]),] # Treino no restante\n\n                modrf = randomForest(Survived~., data = train, ntree = ntree, mtry = mtry, maxnodes = maxnodes, na.action = na.roughfix)\n\n                # Calculando as previsões\n                prev = predict(modrf, test %>% select(-Survived))\n\n                # Atualizando a acurácia média\n                acc = acc + (sum(prev == test$Survived) / length(prev)) / n_fold   \n            }\n            \n            # Guardando os resultados\n            linha = data.frame(ntree = ntree, mtry = mtry, maxnodes = maxnodes, acc = acc)\n            dfres = rbind(dfres, linha)\n            print(paste0(\"ntree = \", ntree, \", mtry = \", mtry, \", maxnodes = \", maxnodes, \", acc = \", acc))\n        }\n    }\n}\n\nfim = Sys.time()\nt = (fim - inicio)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"70cd48587ebe860b12ccb8560c0bf094a042f111"},"cell_type":"code","source":"# Ordenando da maior acurácia para a menor\ndfres = dfres[order(dfres$acc, decreasing = T), ]\n\n# PEgando os melhores parametros\nntree = dfres[1, 'ntree']\nmtry = dfres[1, 'mtry']\nmaxnodes = dfres[1, 'maxnodes']\n\nprint(paste0(\"Melhores parâmetros: ntree = \", ntree, \", mtry = \", mtry, \", maxnodes = \", maxnodes))\n\n# Treinando o modelo com os melhores parâmetros e todos os dados\nmodrf_final = randomForest(Survived~., data = dados, ntree = ntree, mtry = mtry, maxnodes = maxnodes)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"98133ab081be00cc85a9a2bcba84455d1e601a9d"},"cell_type":"code","source":"# Amostra de teste\ntest = read.csv('../input/test.csv')","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"5fe19b4eb44dbb74d313f9da763d8d65c201df2a"},"cell_type":"code","source":"# Preenchendo missing de Age e Fare\ntest[which(is.na(test$Age)), 'Age'] = mean(test$Age, na.rm = T)\ntest[which(is.na(test$Fare)), 'Fare'] = mean(test$Fare, na.rm = T)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"2356aa867c4ef09ee5e89aef42686c9e62e482c8"},"cell_type":"code","source":"# Calculando previsões para submeter à competição\nres = predict(modrf_final, test)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"13ab0433f603381e0346604231021ff6aabcc21d"},"cell_type":"code","source":"submit = data.frame(PassengerId = test$PassengerId, Survived = res)\nwrite.csv(submit, \"submit_RF.csv\", row.names = F)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"d0f9433610552f62b9e8ba53e4dad409ec342ded"},"cell_type":"code","source":"submit","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"3a3443056680b46c326b365071572227ad329afe"},"cell_type":"code","source":"","execution_count":null,"outputs":[]}],"metadata":{"kernelspec":{"display_name":"R","language":"R","name":"ir"},"language_info":{"mimetype":"text/x-r-source","name":"R","pygments_lexer":"r","version":"3.4.2","file_extension":".r","codemirror_mode":"r"}},"nbformat":4,"nbformat_minor":1}