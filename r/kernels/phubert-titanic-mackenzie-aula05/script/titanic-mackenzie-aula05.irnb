{"cells":[{"metadata":{"_uuid":"007bf6a70936c7370199013dbc60537cf86b2f0a","_execution_state":"idle","trusted":true},"cell_type":"code","source":"## Importing packages\n\n# This R environment comes with all of CRAN and many other helpful packages preinstalled.\n# You can see which packages are installed by checking out the kaggle/rstats docker image: \n# https://github.com/kaggle/docker-rstats\n\nlibrary(tidyverse) # metapackage with lots of helpful functions\n\ndados = read.csv('../input/train.csv', sep = ',', header = T)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"75911500b81fa32a1b3976601a5ee446e1d3684d"},"cell_type":"code","source":"# Survived x Fare\nlibrary(ggplot2)\n\ng = ggplot(data = dados, aes(group = Survived, y = Fare, x = Survived))\ng + geom_boxplot(fill = 'lightblue') + xlab(\"Sobrevivente (1 = sobrevivente)\") + ylab(\"Preço da passagem (limitado a $200)\") + ylim(c(0,200))\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"c452b2ed4e57661d59d9ad5ec4c5b54bff797f8a"},"cell_type":"code","source":"# Média de Fare \ndados %>% group_by(Survived) %>% summarise('media' = mean(Fare))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"a29bc7c00aaf296bbaab77497df969f661a454fd"},"cell_type":"code","source":"# Usando o classificador simples: se Fare > 35, survived = 1\nypred = ifelse(dados$Fare > 35, 1, 0)\n\n# Obtendo a matriz de confusão\nlibrary(caret)\nconfusionMatrix(factor(ypred), factor(dados$Survived), positive = '1')","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"d7c98dade5cf7d13e4250a749e8a8ff337c1f9e4"},"cell_type":"code","source":"# Testando a acurácia de vários pontos de corte\ntmin = min(dados$Fare)\ntmax = max(dados$Fare)\n\n# Número de pontos de corte para testar (entre tmin e tmax)\nnpontos = 1000\npontos = seq(from = tmin, to = tmax, length.out = npontos)\n\nres = as.data.frame(matrix(ncol=4, nrow=0))\nfor(i in 1:npontos) {\n    t = pontos[i]\n    ypred = ifelse(dados$Fare < t, 0, 1)\n    m = confusionMatrix(factor(ypred), factor(dados$Survived))\n    a = m$overall['Accuracy']\n    tb = m$table\n    p = tb[2,2] / sum(tb[,2])\n    r = tb[2, 1] / sum(tb[,1])\n    res[i, 1] = t\n    res[i, 2] = a\n    res[i, 3] = p\n    res[i, 4] = r\n}\ncolnames(res) = c(\"corte\", \"acuracia\", \"tpr\", \"fpr\")\n\nresFare = res\n# Ponto ótimo\ntopt = res[which.max(res$acuracia),1]\nprint(paste0(\"Corte ótimo = \", topt))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"fdb8836ab8207682893475031af09404ca003025"},"cell_type":"code","source":"# ROC curve\ng = ggplot(data = res, aes(y = tpr, x = fpr))\ng + geom_line() + geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), color = \"blue\", linetype = 'dashed') +\nxlab('Taxa de falsos positivos (frequência de alarme falso)') + ylab('Taxa de verdadeiros positivos (recall)') +\nggtitle(\"ROC - Fare\")","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"scrolled":true,"_uuid":"3a6cdeee94a0d04e66a4cbad8cadb01f226c95bb"},"cell_type":"code","source":"# Plotando os resultados\ng = ggplot(data = res, aes(x = corte, y = acuracia))\ng + geom_line() + xlab('Ponto de corte') + ylab('Acurácia')\n\ng = ggplot(data = res[which(res$corte < 100),], aes(x = corte, y = acuracia))\ng + geom_line() + geom_point() + xlab('Ponto de corte') + ylab('Acurácia') +\ngeom_vline(xintercept = topt, colour = 'red', linetype = 'dashed')","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"2e2a28ca94363f36e2c2acd5f3263b4f7e66fe06"},"cell_type":"code","source":"# Repetindo para Parch\ng = ggplot(data = dados, aes(group = Survived, y = Parch, x = Survived))\ng + geom_boxplot(fill = 'lightblue') + xlab(\"Sobrevivente (1 = sobrevivente)\") + ylab(\"Parentes a bordo\") ","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"984b9b50b9a94e30b3d85a7c09596b61284521aa"},"cell_type":"code","source":"# Testando a acurácia de vários pontos de corte\ntmin = min(dados$Parch)\ntmax = max(dados$Parch)\n\n# Número de pontos de corte para testar (entre tmin e tmax)\nnpontos = 1000\npontos = seq(from = tmin, to = tmax, length.out = npontos)\n\nres = as.data.frame(matrix(ncol=2, nrow=0))\nfor(i in 1:npontos) {\n    t = pontos[i]\n    ypred = ifelse(dados$Parch < t, 0, 1)\n    m = confusionMatrix(factor(ypred), factor(dados$Survived))\n    a = m$overall['Accuracy']\n    tb = m$table\n    p = tb[2,2] / sum(tb[,2])\n    r = tb[2, 1] / sum(tb[,1])\n    res[i, 1] = t\n    res[i, 2] = a\n    res[i, 3] = p\n    res[i, 4] = r\n}\ncolnames(res) = c(\"corte\", \"acuracia\", \"tpr\", \"fpr\")\n\nresParch = res\n# Ponto ótimo\ntopt = res[which.max(res$acuracia),1]\nprint(paste0(\"Corte ótimo = \", topt))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"82a3e1d8df5b89a682f8462b061a4f885d94b40f"},"cell_type":"code","source":"# ROC curve\ng = ggplot(data = res, aes(y = tpr, x = fpr))\ng + geom_line() + geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), color = \"blue\", linetype = 'dashed') +\nxlab('Taxa de falsos positivos (frequência de alarme falso)') + ylab('Taxa de verdadeiros positivos (recall)') +\nggtitle(\"ROC - Parch\")","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"100dd7ed392b85ad68a7440a730e4cf887524b30"},"cell_type":"code","source":"# Plotando os resultados\ng = ggplot(data = res, aes(x = corte, y = acuracia))\ng + geom_line() + xlab('Ponto de corte') + ylab('Acurácia') + geom_point()\n\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"1446dc18b36db995bbc3f270b25335d318274564"},"cell_type":"code","source":"# ROC Parch x Fare\ndfRoc = rbind(cbind.data.frame(variavel = rep('Fare', nrow(resFare)), tpr = resFare$tpr, fpr = resFare$fpr), cbind.data.frame(variavel = rep('Parch', nrow(resParch)), tpr = resParch$tpr, fpr = resParch$fpr))\n\ng = ggplot(data = dfRoc, aes(y = tpr, x = fpr, color = variavel))\ng + geom_line() + geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), color = \"blue\", linetype = 'dashed') +\nxlab('Taxa de falsos positivos (frequência de alarme falso)') + ylab('Taxa de verdadeiros positivos (recall)') +\nggtitle(\"ROC\")","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"scrolled":true,"_uuid":"5b7ce8daacbd72e4df55d44d2b15c28df388aa96"},"cell_type":"code","source":"# Gráfico Parch x Fare\ng = ggplot(data =dados, aes(x = Parch, y = Fare, color = factor(Survived)))\ng + geom_point() + guides(color = F)\n\ng = ggplot(data =dados, aes(x = Parch, y = Fare, color = factor(Survived)))\ng + geom_point() + guides(color = F) + geom_hline(yintercept = 50.77, color = 'red', linetype = 'dashed')\n\ng = ggplot(data =dados, aes(x = Parch, y = Fare, color = factor(Survived)))\ng + geom_point() + guides(color = F) + geom_hline(yintercept = 50.77, color = 'red', linetype = 'dashed') +\ngeom_vline(xintercept = 0.5, color = 'blue', linetype = 'dashed' )","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"f49d3daf9996eaaaf4653cb9d4b5e9339df2b1a6"},"cell_type":"code","source":"# Calculando a proporção de sobreviventes em cada região\ndados %>% subset(Fare < 50.77 & Parch == 0) %>% summarise(p = sum(Survived) / n())\ndados %>% subset(Fare < 50.77 & Parch > 0) %>% summarise(p = sum(Survived) / n())\ndados %>% subset(Fare >= 50.77 & Parch == 0) %>% summarise(p = sum(Survived) / n())\ndados %>% subset(Fare >= 50.77 & Parch > 0) %>% summarise(p = sum(Survived) / n())\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"07d229fca158fc6c9d730fc9f194c9dd5955c43d"},"cell_type":"code","source":"# Ponto de corte ótimo para cada região\ntmin = min(dados$Parch)\ntmax = max(dados$Parch)\n\n# Número de pontos de corte para testar (entre tmin e tmax)\nnpontos = 1000\npontos = seq(from = tmin, to = tmax, length.out = npontos)\n\ntmp = dados %>% subset(Fare < 50.77)\nres = as.data.frame(matrix(ncol=2, nrow=0))\nfor(i in 1:npontos) {\n    t = pontos[i]\n    ypred = ifelse(tmp$Parch < t, 0, 1)\n    m = confusionMatrix(factor(ypred), factor(tmp$Survived))\n    a = m$overall['Accuracy']\n    res[i, 1] = t\n    res[i, 2] = a\n}\ncolnames(res) = c(\"corte\", \"acuracia\")\n\n# Ponto ótimo\ntopt1 = res[which.max(res$acuracia),1]\nprint(paste0(\"Corte ótimo = \", topt1))\n\ntmp = dados %>% subset(Fare >= 50.77)\nres = as.data.frame(matrix(ncol=2, nrow=0))\nfor(i in 1:npontos) {\n    t = pontos[i]\n    ypred = ifelse(tmp$Parch < t, 0, 1)\n    m = confusionMatrix(factor(ypred), factor(tmp$Survived))\n    a = m$overall['Accuracy']\n    res[i, 1] = t\n    res[i, 2] = a\n}\ncolnames(res) = c(\"corte\", \"acuracia\")\n\n# Ponto ótimo\ntopt2 = res[which.max(res$acuracia),1]\nprint(paste0(\"Corte ótimo = \", topt2))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"f1506009e5d016d0a251ffb179995b1d6f77e212"},"cell_type":"code","source":"# Gráfico da região de decisão\ng = ggplot(data =dados, aes(x = Parch, y = Fare, color = factor(Survived)))\ng + geom_point() + guides(color = F) + geom_hline(yintercept = 50.77, color = 'red', linetype = 'dashed') +\n geom_segment(aes(x = 5.5, y = -1, xend = 5.5, yend = 50.77), color = \"blue\", linetype = 'dashed') +\ngeom_segment(aes(x = 0.5, y = 50.77, xend = 0.5, yend = 550), color = \"blue\", linetype = 'dashed') +\nscale_y_continuous(expand = c(0, 0))","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"ca657d930baca3df9fa039ae9d2e845a7b9d8d1a"},"cell_type":"code","source":"# Calculando a proporção de sobreviventes em cada região\ndados %>% subset(Fare < 50.77 & Parch <= 5) %>% summarise(p = sum(Survived) / n())\ndados %>% subset(Fare < 50.77 & Parch > 5) %>% summarise(p = sum(Survived) / n())\ndados %>% subset(Fare >= 50.77 & Parch == 0) %>% summarise(p = sum(Survived) / n())\ndados %>% subset(Fare >= 50.77 & Parch > 0) %>% summarise(p = sum(Survived) / n())","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"07c6fb58f7057d2312e71192c4bc7258934bd1ad"},"cell_type":"code","source":"# Árvore\nlibrary(rpart)\nlibrary(rpart.plot)\n\ndados$Survived = as.factor(dados$Survived)\n\n# Treinando uma árvore com apenas três variáveis\nmod1 = rpart(Survived ~ Sex + Age + Pclass, data = dados)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"96a1aff6c6776ed3b36d759f1c869805ac5afd8e"},"cell_type":"code","source":"# Visualizando a árvore resultante\nrpart.plot(mod1)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"628d1c84a1a95156a3e258761471e6a680856f75"},"cell_type":"code","source":"# Resumo do processo de treinamento\nsummary(mod1)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"d1e8df761818be526fd4c59ea3e3db37e32d6da4"},"cell_type":"code","source":"# Vamos avaliar o ganho de previsão a cada novo split da árvore\n# Esse ganho é chamado \"complexity parameter\" (CP)\nprintcp(mod1)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"0d0965b1d82c030c4520c789eb901e6a7a635f92"},"cell_type":"code","source":"# Visualizando a relação entre complexidade do modelo e erro de previsão\n# Eixo horizontal: complexidade\n# Eixo vertical: média e desvio padrão do erro no cross-validation\nplotcp(mod1)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"c2f09630df458e0a6195037619d8b69975e2a583"},"cell_type":"code","source":"# Podando a árvore: escolhemos um valor c de CP, e eliminamos todos os splits que não tenham ganho de qualidade de no mínimo c\n# Um método usual é escolher como corte para o CP o valor que forneceu o mínimo erro de cross-validation (coluna xerror da cptable)\n# Neste caso, o menor erro de cross validation foi no mínimo valor de cp; portanto a poda não terá efeito\npmod = prune(mod1, mod1$cptable[which.min(mod1$cptable[,\"xerror\"]),\"CP\"])\nrpart.plot(pmod)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"aa28171347d9e7afabf21c7d518f694a8eb065bc"},"cell_type":"code","source":"# Para efeito de teste, vamos podar a árvore com um valor maior de complexidade\npmod = prune(mod1, 0.02)\nrpart.plot(pmod)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"b04e3220234e7ae1e8deb31f989d43631faf96d2"},"cell_type":"code","source":"# Vamos observar agora as previsões da árvore\n# O método predict vai fornecer a previsão do modelo\n# No caso da classificação binária, a previsão é uma probabilidade (P(y = 0) ou P(y=1))\nprob = predict(mod1, dados %>% select(c(Age, Sex, Pclass)))\n\n# Modelo com mais variáveis\nmod2 = rpart(Survived ~ Sex + Age + Pclass + SibSp + Parch + Fare, data = dados)\nprob2 = predict(mod2, dados %>% select(c(Age, Sex, Pclass, Parch, SibSp, Fare)))\n\nmod3 = rpart(Survived ~ Sex + Age + Pclass + SibSp + Parch + Fare + Embarked, data = dados)\nprob3 = predict(mod3, dados)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"176c022325877caffb57aa9bd7bf9242e3d1bfad"},"cell_type":"code","source":"# Pergunta: a parrtir de qual valor da probabilidade de y = 1 devemos classificar o indivíduo como sobrevivente?\n# Vamos observar o que acontece na curva ROC\n# Utilizaremos o pacote AUC\nlibrary(AUC)\n\nroc1 = roc(prob[,2], dados$Survived)\nroc2 = roc(prob2[,2], dados$Survived)\nroc3 = roc(prob3[,2], dados$Survived)\nplot(roc1)\nplot(roc2, add = T, col = 'blue')\nplot(roc3, add = T, col = 'red')","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"bb99dfb1384fcd65e1ca193ae67140d6cdd3a15c"},"cell_type":"code","source":"# Calculando a área sob a curva\nauc(roc1)\nauc(roc2)\nauc(roc3)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"b6f1994e860108355efa24214c0ae2c98401764d"},"cell_type":"code","source":"plotcp(mod2)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"9e9df0a4337021caece5dd547c35cbbec05d5a2b"},"cell_type":"code","source":"pmod2 = prune(mod2, 0.027)\nrpart.plot(pmod2)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"98133ab081be00cc85a9a2bcba84455d1e601a9d"},"cell_type":"code","source":"# Amostra de teste\ntest = read.csv('../input/test.csv')","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"2356aa867c4ef09ee5e89aef42686c9e62e482c8"},"cell_type":"code","source":"# Calculando previsões para submeter à competição\nres = predict(mod2, test)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"13ab0433f603381e0346604231021ff6aabcc21d"},"cell_type":"code","source":"submit = data.frame(PassengerId = test$PassengerId, Survived = ifelse(res[,2] > 0.5, 1, 0))\nwrite.csv(submit, \"submit_CART.csv\", row.names = F)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"d0f9433610552f62b9e8ba53e4dad409ec342ded"},"cell_type":"code","source":"","execution_count":null,"outputs":[]}],"metadata":{"kernelspec":{"display_name":"R","language":"R","name":"ir"},"language_info":{"mimetype":"text/x-r-source","name":"R","pygments_lexer":"r","version":"3.4.2","file_extension":".r","codemirror_mode":"r"}},"nbformat":4,"nbformat_minor":1}