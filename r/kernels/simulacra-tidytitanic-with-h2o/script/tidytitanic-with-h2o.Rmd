---
title: "Tidy Titanic with H2o"
author: "Harrison"
date: "January 14, 2018"
output:
  html_document: 
    theme: lumen
    toc: true
  html_notebook: default
  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(comment=NA, message=FALSE, warning=FALSE)
```

```{r message=FALSE}
library(tidyverse)
library(stringr)
library(forcats)
library(magrittr)
library(modelr)
```

```{r message=FALSE}
train <- read_csv("../input/train.csv")
test <- read_csv("../input/test.csv")
```

Combine the data sets. My approach is to add a column that identifies whether the observation is in the train or test set, and to keep the Survived column, filling with NA's for the test set. This way, we can do exploratory analysy, cleaning, and modeling all with one data frame, courtesy of the group_by function.

```{r}
data <- train %>%
  select(-Survived) %>%
  bind_rows(test) %>%
  mutate(is_train = factor(c(rep("train", nrow(train)),
                             rep("test", nrow(test)))),
         Survived = c(train$Survived, rep(NA, nrow(test)))
         )
```


Check that the train and test sets were combined correctly.
```{r}
train %>% nrow() + 
  test %>% nrow() ==
  nrow(data)
```

# Feature Engineering

```{r}
data %>% glimpse
```

```{r}
data %>% summarize_all(n_distinct)
```

```{r}
data <- data %>%
  select(-PassengerId)
```

```{r}
data$Name %>% head(n = 50)
```
## Engineer Titles
```{r}
data %>%
  mutate(title = 
           str_extract(Name, pattern = ",\\s\\w*\\.") %>%
           str_sub(start = 3, end = -2)
           ) -> data

data
```

```{r}
data %>%
  distinct(title)

```

Inspect rare titles.
```{r}
data %>% 
  group_by(title) %>%
  count() %>%
  filter( n < 5) %>%
  walk(glimpse) %>%
  use_series(title) -> rare_title
```

Stored rate titles
```{r}
rare_title
```

```{r}
data %>%
  select(title, Survived) %>%
  filter(title == "Col")
  
```

This just confirms my suspision that rare titles provide little information.

Let's inspect a couple mysterious ones.

```{r}
title_error <- c("Mme", "Mlle", "Jonkheer", NA)
```

```{r}
data %>% 
  select(Name, title) %>%
  filter(title %in% title_error)
  
```

It looks like these weren't errors, but simply titles I didn't recognize. A bit of sleuthing discovers that "Mme." and "Mlle." are French honorifics for "Madame", a title for a woman, and "Madamoiselle", a title for an unmarried women, respectivelely. 

Now to our Dutch nobility. According to wikipedia, 
**Jonkheer or jonkvrouw is literally translated as "young lord" or "young lady". In medieval times such a person was a young and unmarried child of a high-ranking knight or nobleman.**

And the only title able to escape our regular expression was "the Countess". 

```{r}
data %>% 
  replace_na(
    list(title = "Countess")
  ) -> data

rare_title[is.na(rare_title)] <- "Countess"
```



Let's lump these into a "rare title" level.

```{r}
data %>%
  mutate(title = fct_collapse(factor(title),
                              Rare_Title = rare_title)) -> data
```

Here's a function to explore how a given feature correlates with survival.

```{r}
explore_survival <- function(...){
  data %>%
  group_by(...) %>% 
  summarise(avg_survival = mean(Survived, na.rm = TRUE),
            count = n(),
            na_survived = sum(is.na(Survived))) %>%
  arrange(avg_survival %>% desc())
}
```

```{r}
explore_survival(title)
```

The men did NOT fare well. The reverends had it the worst. Married women were most likely to survive. In fact, the survival rate matches up quite nicely with the rules of chivalry at that time. 

## Engineering Ticket Prefix

```{r}
#View(data)
```

```{r}
data %<>%
  mutate(Pclass = factor(Pclass) %>%
           fct_recode(Upper = "1",
                      Middle = "2",
                      Lower = "3")) %>%
  rename(Status = Pclass)
```

```{r}
data %>%
  mutate(Port = str_extract(Ticket, pattern = ".*\\s") %>%
           str_sub(start = 1, end = -2)) -> data
```

```{r}
#View(data)
```


```{r}
data %>%
  group_by(Port) %>%
  summarize(mean_survival = mean(Survived, na.rm = T),
            count = n(),
            na = sum(is.na(Survived))) %>%
  arrange(mean_survival)
  
```

We can see some patterns that will inform how we relabel the factors. We can group them by similar letters & survival rate. If two labels look similar but have different survival rates, grouping them together will lose information.

```{r}

find_label <- function(pat){
  str_subset(data$Port, pattern = pat) %>% unique()
}

A <- find_label("^A")
Paris <- find_label("(PA)|(Pa)")
S <- find_label("^S\\.") %>% setdiff(Paris)
W <- find_label("^W")
CA_died <-  c("C.A./SOTON", "CA", "CA.")
C_survived <- c("C", "C.A.")
P <- find_label("^P")
SOTON <- find_label("SOTON")
STON <- find_label("STON")
F_ <- find_label("^F")

```

Now we recode the Port factor.

```{r}
data %>%
  mutate(Port = factor(Port)) %>%
  mutate(Port = fct_collapse(Port,
    A = A,
    Paris = Paris,
    S = S,
    W = W,
    CA_died = CA_died,
    C_survived = C_survived,
    P = P,
    SOTON = SOTON,
    STON = STON,
    F_ = F_
  )) -> data
```

```{r}
data %>% 
  group_by(Port) %>%
  count() %>%
  arrange(n)
```

```{r}
data %>% 
  mutate(Port = fct_lump(Port, n = 10)) -> data
```

```{r}
data %>% 
  group_by(Port) %>%
  count() %>%
  arrange(n)
```

## Engineering Ticket Number

```{r}
data %>%
  select(Ticket, Port, Survived) %>%
  filter(is.na(Port)) %>%
  arrange(Ticket)
```

It looks like our regular expression didn't leave out any prefixes.

```{r}
data %>% 
  mutate(Ticket_number = str_extract(Ticket, pattern = "(\\s[0-9]*)|(^[0-9]*$)") %>%
           as.integer() %>%
           as.character()) -> data
```

```{r}

find_num <- function(num){
  str_subset(data$Ticket_number, pattern = paste("^", num, sep = "")) %>% unique()
}


data %>%
  mutate(Ticket_group = factor(Ticket_number) %>% 
           fct_collapse(
             `1` = find_num(1),
             `2` = find_num(2),
             `3` = find_num(3),
             `4` = find_num(4),
             `5` = find_num(5),
             `6` = find_num(6),
             `7` = find_num(7),
             `8` = find_num(8),
             `9` = find_num(9),
             other = NA
           )) -> data
```

```{r}
data %>%
  group_by(Ticket_group) %>% 
  summarise(avg_survival = mean(Survived, na.rm = TRUE),
            count = n(),
            na_survived = sum(is.na(Survived))) -> explore_ticket

explore_ticket
  
```

Wow this feature looks *super* informative. Especially considering that I had no hypothesis about how ticket number would affect survival; I just tried to extract a reasonable identifier from the ticket number. 

```{r}
ggplot(data = explore_ticket %>% filter(Ticket_group %in% 1:3)) +
  geom_bar(stat = "identity", aes(x = Ticket_group, y = avg_survival, fill = Ticket_group)) +
  geom_text(mapping = aes(x = Ticket_group, y = .2, label = count))
```

Only about 25% of people in the 3rd ticket group survived compared to about 60% in the 1st group. These statistics are not trivial: there is a relatively large sample size for each, uncluding a large number of test observations.


## Next

```{r}
#data %>% View()
```

```{r}
data %>%
  distinct(Embarked)
```

```{r}
data %>% 
  filter(is.na(Embarked))
```

It's hard to say why this data is missing. We'll clean it in the end. 

## Engineer Cabin

```{r}
data %>%
  mutate(Cabin_Letter = str_extract(Cabin, pattern = "^[A-Z]"),
         Cabin_Number = str_extract(Cabin, pattern = "[0-9]{1,3}"),
         Cabin_Multiple = str_length(Cabin) > 4) -> data
  
```


```{r}
explore_survival(Cabin_Letter) 
```

```{r}
explore_survival(Cabin_Number) %>% arrange(desc(count)) %>% arrange(Cabin_Number%>% as.integer())
```

Cabin number doesn't look very informative. Perhaps it can be binned.
```{r}
data %>%
  mutate(caBIN = factor(Cabin_Number) %>%
           fct_collapse(
             `1-25` = str_c(1:25),
             `26-55` = str_c(26:55),
             `56-150` = str_c(56:150)
           )) -> data
```

```{r}
explore_survival(caBIN)
```

```{r}
explore_survival(Cabin_Multiple)
```

```{r}
#View(data)
```

## Engineer Family Size

```{r}
data %>% 
  mutate(Family_Size = SibSp + Parch) -> data
```

# Data Imputation


```{r}

count_na <- function(){
data %>% 
  select(-Survived) %>%
  summarise_all(~sum(is.na(.))) %>% 
  gather(key = "column", value = "na_count") %>%
  filter(na_count > 0)
}

count_na()
```

Factor certain columns. 

```{r}
data %>%
  mutate(Sex = factor(Sex),
         Survived = factor(Survived),
         Embarked = factor(Embarked),
         Cabin_Letter = factor(Cabin_Letter),
         Cabin_Number = factor(Cabin_Number),
         Cabin_Multiple = factor(Cabin_Multiple),
         ) -> data
```

```{r}
data %>% head
```

```{r}
data %>% 
  mutate_if(is.factor, .funs = 'as.character') -> data
```


```{r}
data %>%
  replace_na(replace = list(
    Cabin_Letter = 0,
    Cabin_Number = 0, 
    Cabin_Multiple = 0, 
    Port = 0,
    Ticket_group = 0,
    caBIN = 0,
    Survived = 0
  )) -> data
```

```{r}
data %>%
  mutate_if(is.character, .funs = "factor") -> data
```

Add NA as a level for factors.

```{r}
# data %>% 
#   mutate_at(.vars = vars(Cabin_Letter, Cabin_Number, Cabin_Multiple, Port, Ticket_group, caBIN), .funs = "addNA") -> data
```


```{r}
count_na()
```

drop unused columns

```{r}
data %>%
  select(-Name, -Ticket, -Cabin, -Ticket_number, -Cabin_Number) -> data
```

```{r}
count_na()
```

## Impute Age

Now we can do some informed imputation. Let's impute missing ages by the median age per title.

```{r}
data %>% 
  group_by(title) %>%
  summarise(mean_age = mean(Age
                            ,na.rm = T))
```

These estimates look very reasonable.

```{r}
data %>% 
  filter(title == 'Master')
```

It looks like the "Master" title was given to the children, hence the young median age.

```{r}
data %>% 
  group_by(title) %>% 
  mutate(Age = if_else(is.na(Age), median(Age, na.rm = T), Age)) %>%
  ungroup() -> data
  
```

## Impute Embarked

```{r}
data %>%
  group_by(Embarked) %>%
  count()
```


```{r}
data %>%
 filter(!(Embarked %in% c("C", "Q", "S")))
```

Let's use mode imputation for Embarked, since the category is overwhelmingly "S".


```{r}
data %>% 
  replace_na(list(
    Embarked = 'S'
  )) -> data
```

## Impute Fare
```{r}
data %>%
  filter(is.na(Fare))
```

Let's take the median fare of lower status males.
```{r}
data %>%
  group_by(Status, Sex) %>%
  summarize(medFare = median(Fare, na.rm = T))
```

We see that the median fare is different per group, so this grouping strategy is appropriate. 

```{r}
data %>%
  group_by(Status, Sex) %>%
  mutate(Fare = ifelse( is.na(Fare), median(Fare, na.rm = T), Fare)) %>% 
  ungroup() -> data
```

```{r}
#View(data)
```

```{r}
count_na()
```






all clean.

## Modeling with h2o

```{r}
data %>% head()
```

```{r}
data %>%
  select(is_train, Survived, everything()) -> data
```

```{r}
data %>% head %>% colnames() %>% setdiff(c("is_train", "Survived")) -> x_predictors
y_target <- "Survived"

train <- data %>% filter(is_train == "train") %>% select(-is_train)
test <- data %>% filter(is_train == "test") %>% select(-is_train, -Survived)
```

```{r}
model_matrix(data = data, formula = Survived ~ . -1) -> model_data
model_train <- model_data %>% filter(is_traintrain == 1) %>% select(-is_traintest, -is_traintrain) %>% bind_cols(train['Survived'])
model_test <-  model_data %>% filter(is_traintrain == 0) %>% select(-is_traintest, -is_traintrain)
```



```{r}
head(train)
```


```{r}
library(h2o)
h2o.init()
```

```{r}
train_h2o <- as.h2o(model_train)
test_h2o <- as.h2o(model_test)

data_split <- h2o.splitFrame(data = train_h2o, ratios = .75, seed = 1)

data_train <- data_split[[1]]
data_test <- data_split[[2]]
```

```{r}
deep_model <- h2o.deeplearning(
                               y = y_target,
                               #distribution = "bernoulli",
                               seed = 1,
                               training_frame = data_train)

rf_model <- h2o.randomForest(y = y_target,
                             seed = 1,
                             training_frame = data_train)
```
```{r}
gbm_model <- h2o.gbm(y = y_target,
                         seed = 1,
                         training_frame = data_train)

nb_model <- h2o.naiveBayes(y = y_target,
                         seed = 1,
                         training_frame = data_train)
```
```{r}
xgb_model <- h2o.xgboost(y = y_target,
                         seed = 1,
                         training_frame = data_train)
```


```{r}
pred_deep <- h2o.predict(deep_model, newdata = data_test)[[1]]
pred_rf <- h2o.predict(rf_model, newdata = data_test)[[1]]
pred_gbm <- h2o.predict(gbm_model, newdata = data_test)[[1]]

h2o_predict <- function(model){
   h2o.predict(model, newdata = data_test)[[1]]
}

pred_nb <- h2o_predict(nb_model)
pred_xgb <- h2o_predict(xgb_model)

accuracy <- function(prediction){
  mean(data_test$Survived == prediction)
}
```

```{r}
accuracy(pred_deep)
```

```{r}
accuracy(pred_rf)
```

```{r}
accuracy(pred_gbm)
```


```{r}
accuracy(pred_nb)
```

```{r}
accuracy(pred_xgb)
```


##Submission

```{r}
final_model <- h2o.automl(y = y_target,
                         training_frame = train_h2o,
                         max_runtime_secs = 1100)
                         
# View the AutoML Leaderboard
lb <- final_model@leaderboard
lb                        
                         
pred_final <- h2o.predict(final_model@leader, newdata = test_h2o)[[1]] %>% as.data.frame()

submission <- data.frame("PassengerId" = read_csv("../input/test.csv")$PassengerId,
                  "Survived" = pred_final[[1]])
                  
write.csv(submission, file = 'TidyTitanic.csv', row.names = F)
```