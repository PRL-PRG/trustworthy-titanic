{"cells":[{"metadata":{"trusted":true,"_uuid":"900c849ead9cb7b74d2ab07c02dfacdc82382bea"},"cell_type":"markdown","source":"This is my very first kernel. I created this kernel to practice my knowlage which I learned during my home study of machine learning. I will appreciate your coments and advises.\n\nI used very known Titanic data set and tested falowing classifiers:\n\n1. Logistic regression\n2. K - nearest neighbors\n3. Linear discriminant analysis\n4. Rule learning algorithm \"RIPPER\"\n3. Decission tree C5.0\n4. Random forest\n5. Extreme gradient boosting tree\n6. Support vector machine  with radial kernel\n7. Neural network\n\nAll the model were trained and little bit tuned with a help of CARET library and for the neural network with Keras library. \nFor the evaluation of the models the F1 score was used for the NN the accuracy was used.\n\nThere are 4 chapters:\n1. Data loading and preparation\n2. Model training\n3. Final results\n4. Submission"},{"metadata":{"_kg_hide-input":false,"_kg_hide-output":true,"trusted":true,"_uuid":"45d5f0dbc48d5246cbcf94bc35316188efbd954e"},"cell_type":"code","source":"#Libraries\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(gridExtra)\nlibrary(caret)\nlibrary(ROCR)\nlibrary(keras)\nlibrary(MLmetrics)\nlibrary(RWeka)\nlibrary(xgboost)\nlibrary(viridis)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"84f3e4981411aa7df70d1bfa86e39a1de46c19be"},"cell_type":"markdown","source":"**Data loading and preparation**\n\n"},{"metadata":{},"cell_type":"markdown","source":"Train data and Test data were joined together in order to perform the data preparation on both datasets at onec."},{"metadata":{"_kg_hide-output":false,"trusted":true,"_uuid":"8783bd67d83bccd97dc730c9e629a8c465964439","_kg_hide-input":false},"cell_type":"code","source":"#Loading data \ntrain_data <- read_csv(\"../input/train.csv\")\nsubmission_test <- read_csv(\"../input/test.csv\")\n\nsubmission_test$Survived <- NA\ndata_titanic <- rbind(train_data, submission_test)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"65d95bb18e692b80eea4434bc4f2f394c2588cf7"},"cell_type":"code","source":"#Data structure\nglimpse(data_titanic)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"8d33dd048235493f02c6235e8f51bbf3360736ff"},"cell_type":"markdown","source":"Quick glimpse on the data:\nThere are 12 variables here is short description:\n1. *PassengerId* - Identification number of passanger\n2. *Survived* - wether the passanger survived or not 0 = No, 1 = Yes\n3. *Pclass* - Ticket class 1st, 2nd, 3rd\n4. *Name* - Passanger name\n5. *Sex* \n6. *Age*\n7. *SibSp* - # of siblings / spouses aboard the Titanic\n8. *Parch* - # of parents / children aboard the Titanic\n9. *Ticket* - Ticket number\n10. *Fare* - Passenger fare\n11. *Cabin* - Cabin number\n12. *Ebarke* - Port of Embarkation"},{"metadata":{"_uuid":"4c17db0bd0c16cf79db9db8a5fbf0a34f2278841"},"cell_type":"markdown","source":"Now we will check of missing values:"},{"metadata":{"trusted":true,"_uuid":"75c072948cdfdd43fd80225b2f5b364f18b70200"},"cell_type":"code","source":"count_na <- function(x){\n  sum(is.na(x))\n}\nsapply(data_titanic, count_na)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"575e4194b3438cd76955766d9717796e3fd94684"},"cell_type":"markdown","source":"Now we have to take care with missing age values. I will estimate the age value based on the name title.\n1. Create new variable *Title* (Master, Mr., Miss., Mrs)\n2. Check the distribution of age in each title\n3. Estimate the age as meadian age for ecah title groupe"},{"metadata":{"_kg_hide-output":false,"trusted":true,"_uuid":"7641d8a681bddb20dc9fe710f1eb0631abe75d42"},"cell_type":"code","source":"#Check how the names looks like\nhead(data_titanic$Name, 5)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"76465a07c0207715722a840adb4156648e4f5d57"},"cell_type":"markdown","source":"1. Creating new variable *Title*"},{"metadata":{"trusted":true,"_uuid":"ea87865785c77fc7fe15efb549aa50c3a05ae01b"},"cell_type":"code","source":"data_titanic_clean <- data_titanic %>%\n  mutate(Name_c = Name) %>%\n  separate(Name_c, c(\"First_name\", \"Title_last_name\"), sep = \",\" ) %>%\n  separate(\"Title_last_name\", c(\"Title\", \"last_name\"), sep = \"\\\\.\") %>%\n  mutate(Title = str_trim(Title)) %>%\n  select(- First_name, - last_name)\n\nunique(data_titanic_clean$Title)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"e87cad520da76ad71e1f96f5bb1b79180dac7135"},"cell_type":"markdown","source":"2. Check the distribution of ange in each Title "},{"metadata":{"trusted":true,"_uuid":"0488f186928d0432939d7dc78341b25228210c37"},"cell_type":"code","source":"ggplot(data_titanic_clean, aes(x = Title, y = Age))+\n  geom_boxplot(na.rm = TRUE)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"29efb5e7236b0e94c5859b76e16503a9c36aa6db"},"cell_type":"markdown","source":"We can see that we can roughly estimate the age according to the title.  \nThere is several titles wich I have never seen before so I check the google and reduced them only to Mister, Mr, Miss, Mrs\n\n* Don. - Spain honorific title - replace with \"Mr\"\n* Rev. - Reverend - replace with \"Mr\"\n* Dr.  - Doctor Replace With \"Mr\"\n* Ms. - It could be Mrs or Miss It is a Female with age 28 lets change it as Miss.\n* Major. - It is clear it is major so lets change it as Mr.\n* Lady. - It is a title for adult womon so lets chage it as Mrs.\n* Sir. - Is cleare lets change it to Mr.\n* Col - It a military title so lets put them to Mr. group\n* Capt. - lets change it to Mr.\n* Mme. - French abraviation for Madam - equivalent \"Mrs\"\n* Mlle. - Frech title equivalent in English is \"Miss\"\n* Johkheer. - Male honorific title so lets put him to Mr. group  \n* the Countess - Lets assumed that it will Mrs."},{"metadata":{"trusted":true,"_uuid":"e38181623f72aa1a31d691811b705b0e3b70268f"},"cell_type":"code","source":"title_Mr <- c (\"Don\", \"Rev\", \"Dr\", \"Major\", \"Sir\", \"Col\", \"Capt\", \"Jonkheer\")\ntitle_Mrs <- c(\"Lady\", \"Mme\", \"the Countess\", \"Dona\")\ntitle_Miss <- c(\"Ms\", \"Mlle\")\n\ndata_titanic_clean$Title[data_titanic_clean$Title %in% title_Mr] <- \"Mr\"\ndata_titanic_clean$Title[data_titanic_clean$Title %in% title_Mrs] <- \"Mrs\"\ndata_titanic_clean$Title[data_titanic_clean$Title %in% title_Miss] <- \"Miss\"","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"94e70e3751df6e038c5aac7c408bc2daad78f52a"},"cell_type":"code","source":"unique(data_titanic_clean$Title)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"b788d637cdb3f2f516515caf81f63ad4defa7e71"},"cell_type":"markdown","source":"Now the last thing is to replace the NA values in *Age* variable by the median for each category in *Title* variable."},{"metadata":{"trusted":true,"_uuid":"4de2e12a58fbe836cf848b9d8737db8fbf95ee33"},"cell_type":"code","source":"#Extract the medians\nmeds <- data_titanic_clean %>%\n  group_by(Title) %>%\n  summarise(med = median (Age, na.rm = TRUE))\n#Simple visualization\nggplot(data_titanic_clean, aes(x = Title, y = Age))+\n  geom_boxplot(na.rm = TRUE) +\n  geom_text(data = meds, aes(x = Title, y = med, label = med), \n            size = 3, vjust = -0.5)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"1c8b2e31691a1041b041892d0d4dcd1849878cea"},"cell_type":"code","source":"#Check which title contains NA value in *Age*\ndata_titanic_clean %>%\n  filter(is.na(Age)) %>%\n  select(Title) %>%\n  distinct()","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"ad4c7c6e9b3c8cd1ef10068c5ebc5b11eab18140"},"cell_type":"code","source":"#Simple replacing function\nfun_age <- function (Tit, Age_med) {\ndata_titanic_clean[(data_titanic_clean$Title == Tit & is.na(data_titanic_clean$Age)), \"Age\"] <- Age_med\ndata_titanic_clean\n}\n\ndata_titanic_clean <- fun_age(\"Mr\", 30)\ndata_titanic_clean <- fun_age(\"Mrs\", 35.5)\ndata_titanic_clean <- fun_age(\"Miss\", 22)\ndata_titanic_clean <- fun_age(\"Master\", 4)\n","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"06df14b6a04da2a002563f6a44d8e12a23b39a0d"},"cell_type":"code","source":"#Data summary\nsummary(data_titanic_clean)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"a36ea6e625c411dce8194c584200a2039807fd6c"},"cell_type":"markdown","source":"Now we have no NA values in *Age* variable. But we have same passanger with tickets which cost nothing this is very unlikely so I will replace the 0 vlues in *Fare* by median value of *Pclass* variable. "},{"metadata":{"trusted":true,"_uuid":"3558280a12225bbf592d5f0d2e81442f1c0bba72"},"cell_type":"code","source":"data_titanic_clean <- data_titanic_clean %>%\n  mutate(Pclass = as.factor(Pclass))\n\nmeds_fare <- data_titanic_clean %>%\n  group_by(Pclass) %>%\n  summarise(med = median (Fare, na.rm = TRUE))\n           \nggplot(data_titanic_clean, aes(x = Pclass, y = Fare))+\n  geom_boxplot(na.rm = TRUE) +\n  geom_text(data = meds_fare, aes(x = Pclass, y = med, label = med), \n            size = 3, vjust = -0.5)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true,"_uuid":"3e30521a5a7e5cfcd591e9f17b14a59822310383"},"cell_type":"code","source":"data_titanic_clean[is.na(data_titanic_clean$Fare) & data_titanic_clean$Pclass == 3, \"Fare\"] <-0\n\nfun_fare <- function (class, Fare_med){\n  data_titanic_clean[data_titanic_clean$Fare == 0 & data_titanic_clean$Pclass == class, \"Fare\"] <- Fare_med\n  data_titanic_clean\n}\n\ndata_titanic_clean  <- fun_fare(1, Fare_med = 60)\ndata_titanic_clean  <- fun_fare(2, Fare_med = 14.25)\ndata_titanic_clean  <- fun_fare(3, Fare_med = 8.05)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"1c4bb0e7e4aa18b5504a3a974fc1ff7529038d30"},"cell_type":"markdown","source":"Now lets clean the data set from variables which We will not need in this kernel (*Name*, *Ticket*)."},{"metadata":{"trusted":true,"_uuid":"989bfeb77ba8b334632e80352823e74d359fdee6"},"cell_type":"code","source":"data_titanic_clean <- data_titanic_clean %>%\n  select(-Ticket, -Name)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"2c43b537c1df294bd243de34f91b6c961110a15e"},"cell_type":"markdown","source":"I will replace *SibSp* and *Parch* variable with one variable called *Family_size*."},{"metadata":{"trusted":true,"_uuid":"c883348090c037dd5ab32fb846337690206dcee1"},"cell_type":"code","source":"data_titanic_clean <- data_titanic_clean %>%\n  mutate(Family_size = SibSp + Parch + 1)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"In the *Cabin* variable the NA values were replaced by \"none\" and the cabin numbers were removed. Only Cabins letters remain. "},{"metadata":{"trusted":true},"cell_type":"code","source":"data_titanic_clean <- data_titanic_clean %>%\n  mutate(Cabin = substr(data_titanic_clean$Cabin, start = 1, stop = 1 ))\n\ndata_titanic_clean[is.na(data_titanic_clean$Cabin), 9] <- \"none\"\nunique(data_titanic_clean$Cabin)\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Replace Embarked missing values by most frequent category"},{"metadata":{"trusted":true},"cell_type":"code","source":"data_titanic_clean[is.na(data_titanic_clean$Embarked), 10] <- \"S\"","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Data exploration / visualisation\n"},{"metadata":{"trusted":true},"cell_type":"code","source":"Pclass <- ggplot(data_titanic_clean)+\n  geom_bar(aes(x = factor(Survived), fill = factor(Pclass) ), position = \"fill\")+\n  scale_fill_viridis(discrete = TRUE)\n\nSex <- ggplot(data_titanic_clean)+\n  geom_bar(aes(x = factor(Survived), fill = factor(Sex) ), position = \"fill\")+\n  scale_fill_viridis(discrete = TRUE)\n\nAge <- ggplot(data_titanic_clean)+\n  geom_violin(aes(x = factor(Survived), y = Age, fill = factor(Survived)))+\n  scale_fill_viridis(discrete = TRUE)\n\nFare <- ggplot(data_titanic_clean)+\n  geom_violin(aes(x = factor(Survived), y = Fare, fill = factor(Survived)))+\n  scale_fill_viridis(discrete = TRUE)\n\nFam_size <- ggplot(data_titanic_clean)+\n  geom_bar(aes(x = factor(Survived), fill = factor(Family_size) ), position = \"fill\")+\n  scale_fill_viridis(discrete = TRUE)\n\nEmbarked <- ggplot(data_titanic_clean)+\n  geom_bar(aes(x = factor(Survived), fill = factor(Embarked) ), position = \"fill\")+\n  scale_fill_viridis(discrete = TRUE)\n\nCabin <- ggplot(data_titanic_clean)+\n  geom_bar(aes(x = factor(Survived), fill = factor(Cabin) ), position = \"fill\")+\n  scale_fill_viridis(discrete = TRUE)\n\nTitle <- ggplot(data_titanic_clean)+\n  geom_bar(aes(x = factor(Survived), fill = factor(Title) ), position = \"fill\")+\n  scale_fill_viridis(discrete = TRUE)","execution_count":null,"outputs":[]},{"metadata":{"trusted":true},"cell_type":"code","source":"grid.arrange(Pclass, Sex, Fam_size, Cabin, Embarked, Title, Age, Fare, \n             nrow = 4, ncol = 2)","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"9e69f620042e120c61cfabcdbe753600dabb9aa0"},"cell_type":"markdown","source":"In the next step I create a dummy variables for all categorical variables. \nFor *Family_size* variable I create two variables *alone* for all with *Family_size* = 1 and *med_fam* for all with *Family_size* 2 - 3.\n*Cabin* variable a replaced with *Cabin_y_n* variable which 1 for passengers with cabin and 0 for those who have missing value in *Cabine* variable."},{"metadata":{"trusted":true,"_uuid":"6417b7ff96f6673fedda0dca9094efe8cd2faebd"},"cell_type":"code","source":"#Creating dummy variables\ndata_titanic_clean <- data_titanic_clean %>%\n  mutate(Survived = as.factor(if_else(Survived == 0, \"No\", \"Yes\")),\n         Pclass1 = if_else(as.numeric(Pclass) == 1, 1, 0),\n         Pclass3 = if_else(as.numeric(Pclass) == 3, 1, 0),\n         Female = if_else(Sex == \"female\", 1, 0),\n         Embarked_C = if_else(Embarked == \"C\",1,0),\n         Embarked_S = if_else(Embarked == \"S\", 1, 0),\n         Title_Miss = if_else(Title == \"Miss\",1,0),\n         Title_Mr = if_else(Title == \"Mr\", 1, 0),\n         Title_Mrs = if_else(Title == \"Mrs\", 1, 0),\n         alone = if_else(Family_size == 1, 1, 0),\n         med_fam = if_else(Family_size %in% c(2,3),1,0),\n         Cabin_y_n = if_else(Cabin == \"none\", 1, 0)\n         ) %>%\n  select(- Parch, - SibSp, - Cabin, - Family_size, - Title, -Pclass, -Sex, -Embarked)\n\nsummary(data_titanic_clean)\n        ","execution_count":null,"outputs":[]},{"metadata":{"_uuid":"2a4c8f6412e4cb4d25b63ca6c0bd500e7942537c"},"cell_type":"markdown","source":"Next step is rescaling *Age* and *Fare* variables and split the data to train and test data sets."},{"metadata":{"trusted":true},"cell_type":"code","source":"set.seed(150)\n\ndata_titanic_clean$Age <- scale(data_titanic_clean$Age, center = TRUE, scale = TRUE)\ndata_titanic_clean$Fare<- scale(data_titanic_clean$Fare, center = TRUE, scale = TRUE)\n\nsubmission <- data_frame(PassengerId = submission_test$PassengerId, Survived = NA)\ntrain_index <- 1:nrow(train_data)\ncomplete_train_data <- data_titanic_clean[train_index,-1]\nsubmission_test <- data_titanic_clean[- train_index, c(-1, -2)]\n\n#Extract the labels\ncomplete_train_labels <- complete_train_data$Survived\n\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"**Modeling**\n"},{"metadata":{"trusted":true},"cell_type":"code","source":"#Vlidation parameters \ntrain_ctrl <- trainControl(method = \"cv\", \n                           number = 10, \n                           selectionFunction = \"oneSE\", \n                           classProb = TRUE, \n                           summaryFunction = prSummary)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":" Logistic regression"},{"metadata":{"trusted":true},"cell_type":"code","source":"set.seed(301)\nmodel_log <- caret::train(Survived ~., data = complete_train_data, method = \"glm\", \n                          metric = \"F\", trControl = train_ctrl)\n\nModel_performance <- tibble(F_1_score = NA, AUC = NA, Model = NA)\n\n#Saving best model results\nModel_performance[1, 1]<- model_log$results$F\nModel_performance[1, 2] <- model_log$results$AUC\nModel_performance[1, 3] <- \"Log_regression\"\n\ncat(\"AUC = \", model_log$results$AUC, \"\\n\")\ncat(\"F1 = \",  model_log$results$F)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"K - Nearest neighors"},{"metadata":{"trusted":true},"cell_type":"code","source":"k_grid <- data.frame(\"k\" = c(1:50))\n\nset.seed(301)\nmodel_KNN <- caret::train(Survived ~., data = complete_train_data, method = \"knn\", \n                          trControl = train_ctrl, tuneGrid = k_grid, metric = \"F\")\n\n#Saving best model results\nbest_k <- model_KNN$bestTune$k\n\nModel_performance[2, 1] <- model_KNN$results[best_k, ]$F\nModel_performance[2, 2] <- model_KNN$results[best_k, ]$AUC\nModel_performance[2, 3] <- \"K_NN\"\n\ncat(\"AUC = \", model_KNN$results[best_k, ]$AUC, \"\\n\")\ncat(\"F1 = \",  model_KNN$results[best_k, ]$F)\n\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Linear discriminant analysis"},{"metadata":{"trusted":true},"cell_type":"code","source":"set.seed(301)\nmodel_LDA <- train(Survived ~., data = complete_train_data, \n                   trControl = train_ctrl, metric = \"F\", method = \"lda\")\n\n#Saving best model results\nModel_performance[3, 1] <- model_KNN$results[best_k, ]$F\nModel_performance[3, 2] <- model_LDA$results$F\nModel_performance[3, 3] <- \"LDA\"\n\ncat(\"AUC = \", model_LDA$results$AUC, \"\\n\")\ncat(\"F1 = \",  model_LDA$results$F)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"RIPPER ruler learner model"},{"metadata":{"trusted":true},"cell_type":"code","source":"grid <- expand.grid(NumOpt = c(1:7),\n                    NumFolds = c(1,2,3),\n                    MinWeights = c(1,2,3)\n                    )\n\nmodel_RIP <- train(Survived ~., data = complete_train_data, trControl = train_ctrl, \n                   method = \"JRip\", metric = \"F\", tuneGrid = grid)\n\n#Saving best model results\nbest <- as.numeric(rownames(model_RIP$bestTune))\n\nbest_k <- model_KNN$bestTune$k\n\nModel_performance[4, 1] <- model_RIP$results[best, ]$F\nModel_performance[4, 2] <- model_RIP$results[best, ]$AUC\nModel_performance[4, 3] <- \"RIPPER\"\n\ncat(\"AUC = \", model_RIP$results[best, ]$AUC, \"\\n\")\ncat(\"F1 = \",  model_RIP$results[best, ]$F)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":" Decision tree C5.0"},{"metadata":{"trusted":true},"cell_type":"code","source":"grid <- expand.grid(model = \"tree\",\n                    trials = c(1:30),\n                    winnow = \"FALSE\")\n\nset.seed(301)\nmodel_Tree <- train(Survived ~ ., data = complete_train_data,\n                           method = \"C5.0\",metric = \"F\", \n                           trControl = train_ctrl, tuneGrid = grid)\n\n#Saving best model results\nbest <- as.numeric(rownames(model_Tree$bestTune))\n\nModel_performance[5, 1] <- model_Tree$results[best, ]$F\nModel_performance[5, 2] <- model_Tree$results[best, ]$AUC\nModel_performance[5, 3] <- \"Decision_Tree\"\n\ncat(\"AUC = \", model_Tree$results[best, ]$AUC, \"\\n\")\ncat(\"F1 = \",  model_Tree$results[best, ]$F)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Random forest"},{"metadata":{"trusted":true},"cell_type":"code","source":"grid <- expand.grid(mtry = c(1:13))\n                    \nset.seed(301)\nmodel_RF <- train(Survived ~., data = complete_train_data, method = \"rf\", \n                  metric = \"F\", trControl = train_ctrl, tuneGrid = grid)\n\n#Saving best model results\nbest <- as.numeric(rownames(model_RF$bestTune))\n\nModel_performance[6, 1] <- model_RF$results[best, ]$F\nModel_performance[6, 2] <- model_RF$results[best, ]$AUC\nModel_performance[6, 3] <- \"Random_Forest\"\n\ncat(\"AUC = \", model_RF$results[best, ]$AUC, \"\\n\")\ncat(\"F1 = \",  model_RF$results[best, ]$F)\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Extreme gradient boosting"},{"metadata":{"trusted":true},"cell_type":"code","source":"#Data preparation\ntrain_xgb_x <- xgb.DMatrix(as.matrix(complete_train_data[,-1]))\nsubmission_xgb_x <- xgb.DMatrix(as.matrix(submission_test))\n\n#Tuning parameters\ngrid <- expand.grid(\n  nrounds = c(100, 200),\n  max_depth = c (2, 6, 10),\n  eta = c (0.01, 0.1),\n  gamma = c(0, 0.05),\n  min_child_weight = c(0.5, 1),\n  colsample_bytree = c(0.1, 0.4, 1),\n  subsample = c(0.5, 1)\n)\n\n#Training model\nset.seed(301)\nmodel_XGB <- caret::train(\n  x = train_xgb_x,\n  y = complete_train_labels,\n  trControl = train_ctrl,\n  method = \"xgbTree\",\n  tuneGrid = grid,\n  metric = \"F\"\n)\n\n#Saving best model results\nbest <- as.numeric(rownames(model_XGB$bestTune))\n\nModel_performance[7, 1] <- model_XGB$results[best, ]$F\nModel_performance[7, 2] <- model_XGB$results[best, ]$AUC\nModel_performance[7, 3] <- \"XGboosting\"\n\ncat(\"AUC = \", model_XGB$results[best, ]$AUC, \"\\n\")\ncat(\"F1 = \",  model_XGB$results[best, ]$F)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"SVM linear kernel"},{"metadata":{"trusted":true},"cell_type":"code","source":"grid <- expand.grid(\n  cost = seq(from = 1, to = 6, by = 1)\n)\n\nset.seed(301)\nmodel_SVM <- train(\n  x = as.matrix(complete_train_data[,-1]),\n  y = complete_train_labels,\n  trControl = train_ctrl,\n  method = \"svmLinear2\",\n  tuneGrid = grid,\n  metric = \"F\"\n)\n\n#Saving best model results\nbest <- as.numeric(rownames(model_SVM$bestTune))\n\nModel_performance[8, 1] <- model_SVM$results[best, ]$F\nModel_performance[8, 2] <- model_SVM$results[best, ]$AUC\nModel_performance[8, 3] <- \"SVM_linear\"\n\ncat(\"AUC = \", model_SVM$results[best, ]$AUC, \"\\n\")\ncat(\"F1 = \",  model_SVM$results[best, ]$F)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Neural Network\n"},{"metadata":{"trusted":true},"cell_type":"code","source":"#Data preparation\ncomplete_train_data_nn <- array(as.matrix(complete_train_data[,-1]), \n                                dim = c(891, 13))\nlevels(complete_train_labels) <- c(0, 1)\ncomplete_train_labels_nn <- array(complete_train_labels, dim = c(891))\nsubmission_nn <- array(as.matrix(submission_test), dim = c(418,13))\n\n#Training model\nmodel_NN <-  keras_model_sequential() %>%\n    layer_dense(units =  5, activation = \"relu\",\n                input_shape = dim(complete_train_data_nn )[[2]]) %>%\n    layer_dense(units = 5, activation = \"relu\") %>%\n    layer_dense(units = 5, activation = \"relu\") %>%\n    layer_dense(units = 1, \"sigmoid\")\n\nmodel_NN %>% compile(\n  optimizer = \"adam\",\n  loss = \"binary_crossentropy\",\n  metrics = c(\"accuracy\")\n  )\n\ntrain_history <- model_NN %>% fit(complete_train_data_nn, complete_train_labels_nn,\n                epochs = 10, batch_size = 1, validation_split = 0.3)","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Final results\n"},{"metadata":{"trusted":true},"cell_type":"code","source":"Model_performance\ncat(\"Neural Network ACC = \", train_history$metrics$val_acc[10], \"\\n\")\n","execution_count":null,"outputs":[]},{"metadata":{},"cell_type":"markdown","source":"Submission"},{"metadata":{},"cell_type":"markdown","source":"For the final submission I used different models and make a average of the prediction. "},{"metadata":{"trusted":true},"cell_type":"code","source":"pred_prob_LOG <- predict(model_log, newdata = submission_test, type = \"prob\")[,2]\npred_prob_LDA <- predict(model_LDA, newdata = submission_test, type = \"prob\")[,2]\npred_prob_RF <- predict(model_RF, newdata = submission_test, type = \"prob\")[,2]\npred_prob_XGB <- predict(model_XGB, newdata = submission_xgb_x, type = \"prob\")[,2]\npred_prob_RIP <- predict(model_RIP, newdata = submission_test , type = \"prob\")[,2]\nmodel_prob_NN <- model_NN %>% predict(submission_nn)\npred_prob_KNN <- predict(model_KNN, newdata = submission_test, type = \"prob\")[,2]\npred_prob_TREE <- predict(model_Tree, newdata = submission_test, type = \"prob\")[,2]\npred_prob_SVM <- predict(model_SVM, newdata = submission_test, type = \"prob\")[,2]\n\nfinal_prob <- (pred_prob_KNN + \n               pred_prob_RF + \n               pred_prob_RIP + \n               pred_prob_LOG  ) / 4\n\n\nfinal_prob <- if_else(final_prob > 0.5,\"1\", \"0\")\n\nsubmission$Survived <- as.numeric(final_prob)\n\nwrite.csv(submission, \"Submission.csv\", col.names = TRUE, row.names = FALSE)","execution_count":null,"outputs":[]}],"metadata":{"kernelspec":{"display_name":"R","language":"R","name":"ir"},"language_info":{"mimetype":"text/x-r-source","name":"R","pygments_lexer":"r","version":"3.4.2","file_extension":".r","codemirror_mode":"r"}},"nbformat":4,"nbformat_minor":1}