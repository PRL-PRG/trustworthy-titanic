<!DOCTYPE html>
<html lang="en">
<head>
    <title>Jetbrain Day Kr 2018 - Titanic Prediction | Kaggle</title>
    <meta charset="utf-8" />
    <meta name="robots" content="index, follow" />
    <meta name="turbolinks-cache-control" content="no-cache" />
                <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">    <meta name="theme-color" content="#008ABC" />
    <script type="text/javascript">
        window["initialPageLoadStartTime"] = new Date().getTime();
    </script>
    <link rel="dns-prefetch" href="https://www.google-analytics.com" /><link rel="dns-prefetch" href="https://stats.g.doubleclick.net" /><link rel="dns-prefetch" href="https://js.intercomcdn.com" /><link rel="dns-prefetch" href="https://storage.googleapis.com/" />
    <link href="/static/images/favicon.ico" rel="shortcut icon" type="image/x-icon" />
    <link rel="manifest" href="/static/json/manifest.json">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:400,300,300italic,400italic,600,600italic,700,700italic" rel='stylesheet' type='text/css'>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" type='text/css'/>
        <link rel="canonical" href="/syleeie/jetbrain-day-kr-2018-titanic-prediction" />                    <link rel="stylesheet" type="text/css" href="/static/assets/vendor.css?v=632d145d8598" />
        <link rel="stylesheet" type="text/css" href="/static/assets/app.css?v=9626e4919bfe" />
    
    
 
        <script>
        try{(function(a,s,y,n,c,h,i,d,e){d=s.createElement("style");
        d.appendChild(s.createTextNode(""));s.head.appendChild(d);d=d.sheet;
        y=y.map(x => d.insertRule(x + "{ opacity: 0 !important }"));
        h.start=1*new Date;h.end=i=function(){y.forEach(x => d.deleteRule(x))};
        (a[n]=a[n]||[]).hide=h;setTimeout(function(){i();h.end=null},c);h.timeout=c;
        })(window,document,['.site-header-react__nav'],'dataLayer',2000,{'GTM-52LNT9S':true});}catch{}
    </script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-12629138-1', {
            'optimize_id': 'GTM-52LNT9S',
            'displayFeaturesTask': null,
            'send_page_view': false
        });
    </script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-12629138-1"></script>

    
<script>
    !function(f,b,e,v,n,t,s)
    {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
            n.callMethod.apply(n,arguments):n.queue.push(arguments)};
        if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
        n.queue=[];t=b.createElement(e);t.async=!0;
        t.src=v;s=b.getElementsByTagName(e)[0];
        s.parentNode.insertBefore(t,s)}(window,document,'script',
        'https://connect.facebook.net/en_US/fbevents.js');
    fbq("set", "autoConfig", "false", "136809193586742");
    fbq('init', '136809193586742'); 
    fbq('track', 'PageView');
</script>
<noscript>
    <img height="1" width="1" src="https://www.facebook.com/tr?id=136809193586742&ev=PageView&noscript=1"/>
</noscript>

<script>window.intercomSettings = {"app_id":"koj6gxx6"};</script>        <script>(function () { var w = window; var ic = w.Intercom; if (typeof ic === "function") { ic('reattach_activator'); ic('update', intercomSettings); } else { var d = document; var i = function () { i.c(arguments) }; i.q = []; i.c = function (args) { i.q.push(args) }; w.Intercom = i; function l() { var s = d.createElement('script'); s.type = 'text/javascript'; s.async = true; s.src = 'https://widget.intercom.io/widget/koj6gxx6'; var x = d.getElementsByTagName('script')[0]; x.parentNode.insertBefore(s, x); } if (w.attachEvent) { w.attachEvent('onload', l); } else { w.addEventListener('load', l, false); } } })()</script>
    
    
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@kaggledatasets" />
    <meta name="og:url" content="https://kaggle.com/syleeie/jetbrain-day-kr-2018-titanic-prediction" />
    <meta name="og:title" content="Jetbrain Day Kr 2018 - Titanic Prediction" />
    <meta name="og:description" content="Using data from multiple data sources" />
    <meta name="og:image" content="https://storage.googleapis.com/kaggle-avatars/thumbnails/136508-fb.jpg" />


    
    

    
    
    
<script type="text/javascript">
    var Kaggle = Kaggle || {};

    Kaggle.Current = {
        antiForgeryToken: 'CfDJ8LdUzqlsSWBPr4Ce3rb9VL_TuZef5tBDDGv6qS7XNOW7BkzIw4iOCNZFiNEAwq8JvfyjRdRqR5qjDTD4qCNaC8stG0NdiA-jnxOrKuyMJOBwBhZE-Sf0nkshDA30SQTEzicitLErqpa0D0gPzpoBlBo',
        isAnonymous: true,
        analyticsToken: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NjAxNjgzNzUsIlVzZXJJZCI6MH0.N73AF2LKx1h-YAO12HhRzXS6-SkzGOqtZMrmdJfiNzE',
        analyticsTokenExpiry: 15,
        internetKernelsEnabled: false,
        
        
        
        
        
        
        
        
        
        
        
    }
        Kaggle.Current.log = function(){};
        Kaggle.Current.warn = function(){};

    var decodeUserDisplayName = function () {
        var escapedUserDisplayName = Kaggle.Current.userDisplayNameEscaped || "";
        try {
            var textVersion = new DOMParser().parseFromString(escapedUserDisplayName, "text/html").documentElement.textContent;
            if (textVersion) {
                return textVersion;
            }
        } catch(ex) {}
        return escapedUserDisplayName;
    }
    Kaggle.Current.userDisplayName = decodeUserDisplayName();
</script>

    

<script type="text/javascript">
    var Kaggle = Kaggle || {};
    Kaggle.PageMessages = [];
</script>

    
<script type="text/javascript">
/* <![CDATA[ */
goog_snippet_vars = function() {
    var w = window;
    w.google_conversion_id = 955616553;
    w.google_conversion_label = "QSjvCKDksHMQqZrWxwM";
    w.google_conversion_value = 0.00;
    w.google_conversion_currency = "USD";
    w.google_remarketing_only = false;
    w.google_conversion_language = "en";
    w.google_conversion_format = "3";
    w.google_conversion_color = "ffffff";
}
// DO NOT CHANGE THE CODE BELOW.
goog_report_conversion = function(url) {
    goog_snippet_vars();
    window.google_conversion_format = "3";
    var opt = new Object();
    opt.onload_callback = function() {
        if (typeof(url) != 'undefined') {
            window.location = url;
        }
    }
    var conv_handler = window['google_trackConversion'];
    if (typeof(conv_handler) == 'function') {
        conv_handler(opt);
    }
}
/* ]]> */
</script>
<script type="text/javascript"
src="//www.googleadservices.com/pagead/conversion_async.js">
</script>



        <script>window['useKaggleAnalytics'] = true;</script>

    <script src="/static/assets/vendor.js?v=4721d2c14786" data-turbolinks-track="reload"></script>
    <script src="/static/assets/app.js?v=1d32f39aa6aa" data-turbolinks-track="reload"></script>
        <script>
            (function() {
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register("/static/assets/service-worker.js").then(function(reg) {
                        reg.onupdatefound = function() {
                            var installingWorker = reg.installing;
                            installingWorker.onstatechange = function() {
                                switch (installingWorker.state) {
                                case 'installed':
                                    if (navigator.serviceWorker.controller) {
                                        console.log('New or updated content is available.');
                                    } else {
                                        console.log('Content is now available offline!');
                                    }
                                    break;
                                case 'redundant':
                                    console.error('The installing service worker became redundant.');
                                    break;
                                }
                            };
                        };
                    }).catch(function(e) {
                      console.error('Error during service worker registration:', e);
                    });
                }
            })();
        </script>
    <script>
        function handleClientLoad() {
            try {
                gapi.load('client:auth2');
            } catch (e) {
                // In Opera, readystatechange is an unreliable detection of script load, causing
                // this function to be called before gapi exists on the window. The onload callback
                // is still called at the correct time, so the feature works as expected - it's
                // just generating noisy errors.
            }
        }
    </script>
    <script async defer src="https://apis.google.com/js/api.js"
            onload="this.googleApiOnLoad=function(){};handleClientLoad()"
            onreadystatechange="if (this.readyState === 'complete') this.googleApiOnLoad()">
    </script>
</head>
<body data-turbolinks="true">
    






<div class="site-layout">
        <div class="site-layout__header">
            <div data-component-name="SiteHeaderContainer" style="display: flex; flex-direction: column; flex: 1 0 auto;"></div><script>var Kaggle=window.Kaggle||{};Kaggle.State=Kaggle.State||[];Kaggle.State.push({});performance && performance.mark && performance.mark("SiteHeaderContainer.componentCouldBootstrap");</script>
        </div>

    <div class="site-layout__main-content">
        

<div data-component-name="KernelViewer" style="display: flex; flex-direction: column; flex: 1 0 auto;"></div><script>var Kaggle=window.Kaggle||{};Kaggle.State=Kaggle.State||[];Kaggle.State.push({"kernel":{"id":2141451,"title":"Jetbrain Day Kr 2018 - Titanic Prediction","forkParent":{"kernelId":1091633,"runId":6344966,"url":"/cdeotte/titanic-wcg-xgboost-0-84688","title":"Titanic WCG+XGBoost [0.84688]","author":{"id":1723677,"displayName":"Chris Deotte","email":null,"editedEmail":null,"editedEmailCode":null,"userName":"cdeotte","thumbnailUrl":"https://storage.googleapis.com/kaggle-avatars/thumbnails/1723677-kg.jpg","profileUrl":"/cdeotte","registerDate":"0001-01-01T00:00:00Z","lastVisitDate":"0001-01-01T00:00:00Z","statusId":0,"performanceTier":0,"userRoles":null,"userLogins":null,"groupIds":null,"duplicateUsers":null,"hasPhoneVerifications":false,"failedNerdchas":0,"hasPendingNerdcha":false,"deleteRequests":null,"userAttributes":null,"isAdmin":false,"isTvc":false,"isKaggleBot":false,"isAdminOrTvc":false,"isAnonymous":false,"canAct":false,"canBeSeen":false,"thumbnailName":null,"activationCode":"00000000-0000-0000-0000-000000000000","isPhoneVerified":false},"diff":{"linesInserted":0,"linesDeleted":0,"linesChanged":0,"linesUnchanged":0,"newTotalLines":0,"url":"/syleeie/jetbrain-day-kr-2018-titanic-prediction/versions#base=6344966\u0026new=7632756"},"isRedacted":false,"dateCreated":"2018-10-10T00:22:20.983Z","outputFilesTotalSizeBytes":1069243,"workerStatus":"complete","isolatorResults":null,"languageId":12},"currentRunId":7632756,"mostRecentRunId":7635716,"url":"/syleeie/jetbrain-day-kr-2018-titanic-prediction","tags":[],"commentCount":0,"upvoteCount":6,"viewCount":268,"forkCount":6,"bestPublicScore":0.84688,"author":{"id":136508,"displayName":"이상열","email":null,"editedEmail":null,"editedEmailCode":null,"userName":"syleeie","thumbnailUrl":"https://storage.googleapis.com/kaggle-avatars/thumbnails/136508-fb.jpg","profileUrl":"/syleeie","registerDate":"0001-01-01T00:00:00Z","lastVisitDate":"0001-01-01T00:00:00Z","statusId":0,"performanceTier":0,"userRoles":null,"userLogins":null,"groupIds":null,"duplicateUsers":null,"hasPhoneVerifications":false,"failedNerdchas":0,"hasPendingNerdcha":false,"deleteRequests":null,"userAttributes":null,"isAdmin":false,"isTvc":false,"isKaggleBot":false,"isAdminOrTvc":false,"isAnonymous":false,"canAct":false,"canBeSeen":false,"thumbnailName":null,"activationCode":"00000000-0000-0000-0000-000000000000","isPhoneVerified":false},"isPrivate":false,"updatedTime":"2018-11-22T03:40:54.73Z","selfLink":"/kernels/2141451","pinnedDockerImageVersionId":null,"isLanguageTemplate":false,"medal":null,"topicId":null,"readGroupId":null,"writeGroupId":null,"slug":"jetbrain-day-kr-2018-titanic-prediction"},"kernelBlob":{"id":112457325,"settings":{"dockerImageVersionId":null,"dataSources":[{"sourceType":"DatasetVersion","sourceId":38352,"databundleVersionId":null},{"sourceType":"Competition","sourceId":3136,"databundleVersionId":null},{"sourceType":"DatasetVersion","sourceId":184856,"databundleVersionId":null}],"sourceType":"notebook","language":"r","isGpuEnabled":true,"isInternetEnabled":false},"source":"{\u0022cells\u0022:[{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00228f2839f25d086af736a60e9eeb907d3b93b6e0e5\u0022,\u0022_cell_guid\u0022:\u0022b1076dfc-b9ad-4769-8c92-a6c4dae69d19\u0022,\u0022trusted\u0022:true,\u0022collapsed\u0022:true},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022# Jetbrain Day Kr 2018 - Titanic Prediction (XGBoost will tell us!)\\n\\nThanks, Chris Deotte, Hitesh palamada 감사합니다. \\n해당 커널 작성한 [Chris Deotte](https://www.kaggle.com/cdeotte), [Hitesh palamada](https://www.kaggle.com/hiteshp) 덕분에 Jetbrain day KR 2018 캐글뽀개기 튜토리얼을 진행할 수 있었습니다. \\n\\n이번 커널은 다음의 3개 커널을 주로 참고 했습니다.\\n\\n\\n[Titantic Mega Model- 0.84210](https://www.kaggle.com/cdeotte/titantic-mega-model-0-84210)\\n\\n[Titanic WCG+XGBoost - 0.84688](https://www.kaggle.com/cdeotte/titanic-wcg-xgboost-0-84688)\\n\\n[Head Start for Data Scientist](https://www.kaggle.com/hiteshp/head-start-for-data-scientist)\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00221d514552aeee76efc362f6873e775beceacb2d45\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002208552a67026efa5adbaa7440da7278adeea51bcb\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022## Titanic Tutorial (Head Start for Data Scientist)\\n-  [Head Start for Data Scientist](https://www.kaggle.com/hiteshp/head-start-for-data-scientist)\\n\\n-  1912 년 4 월 14 일 타이타닉 호는 거대한 빙산을 쳤고 승객과 승무원의 약 1,500 명을 대서양의 얼음 깊이 아래로 데려갔습니다. \\n- 바다에서의 최악의 재해 중 하나인 타이타닉은 비극적인 사건으로 인해 그러한 재앙이 다시 발생하는 것을 방지하기 위한 수많은 안전 규정과 정책이 만들어졌습니다. \\n- 그러나 일부 비평가들은 운이 아닌 다른 상황으로 인해 사망자 수가 불균형을 빚었다고 주장합니다. 이 분석의 목적은 사람의 생존 가능성에 영향을 미치는 요소를 탐색하는 것\\n\\n**#### Import library’s, data\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022e8bad8c98efaa8457173764e6e3a4e66175536d9\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022pacman::p_load(rpart, tidyverse, gridExtra, xgboost, forcats, stringr, caTools, DT, data.table, pander, scales, grid, corrplot, VIM, knitr, vcd, caret, MLmetrics, randomForest, \\n              rpart.plot, car, e1071, ROCR, pROC, glmnet)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00226be880e4ecfdfb102745fbdf2a03fa0520f31232\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022getwd()\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022350667365af855603274846259e1a6b699d31521\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022list.files(\u0027../input/\u0027)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_cell_guid\u0022:\u002279c7e3d0-c299-4dcb-8224-4455121ee9b0\u0022,\u0022_uuid\u0022:\u0022d629ff2d2480ee46fbb7e2d37f6b5fab8052498a\u0022,\u0022trusted\u0022:true,\u0022_kg_hide-input\u0022:true},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022train \u003c- read_csv(file = \u0027../input/titanic/train.csv\u0027)\\ntest \u003c- read_csv(file = \u0027../input/titanic/test.csv\u0027)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00228f7a7251c6dfd5c7865da439d418f6e21093513a\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022| Variable  | Definition | key |\\n| :------------ | :-----------: | :-----------: |\\n| survival | 생존 유무 | 0  = No, 1 = Yes |\\n| pclass | 티켓 클래스 | 1 = 1st, 2 = 2nd, 3 = 3rd |\\n| sex | 성별 ||\\n| Age | 나이 ||\\n| sibsp | 형제 \u0026 배우자 숫자||\\n| parch | 부모님 \u0026 아이들 숫자 ||\\n| ticket | 티켓 번호 ||\\n| fare | 요금 ||\\n| cabin | 객실 번호 ||\\n| embarked | 승선항 |C = Cherbourg, Q = Queenstown, S = Southampton|\\n\\n\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002289fc5efd2b3f45d8a6399446a7154c7950549494\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022train$set \u003c- \\\u0022train\\\u0022\\ntest$set  \u003c- \\\u0022test\\\u0022\\ntest$Survived \u003c- NA\\nfull \u003c- rbind(train, test)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022eef45397c1eef5393c9ee61affa45b3d8489a323\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022str(full)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022c8c046423039ea4ddf462cf272356af851eebaea\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022glimpse(full)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022eda296301c7fbd68ada0b54bdfd98d71162278b5\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022summary(full)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00221ed9076b4e20eda971a8156bde81ddaa4062d04a\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022str(test)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022b017994adde5c138ad2eb11d4d70c9b81f21f477\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022dim(full)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022ea066312de060e1ad8f4b830ef152c9cec59617b\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022# Unique values per column\\nsapply(full, function(x) length(unique(x)))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002298b7c463fc4a5e09cf4950a603d8e9fc9913b21b\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022#Check for Missing values\\nmissing_values \u003c- full %\u003e% summarize_all(funs(sum(is.na(.))/n()))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002297733d6ac3e3dd9114cf8f4c5e8349174ce2cd30\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022missing_values \u003c- gather(missing_values, key=\\\u0022feature\\\u0022, value=\\\u0022missing_pct\\\u0022)\\nmissing_values %\u003e% \\n  ggplot(aes(x=reorder(feature,missing_pct),y=missing_pct)) +\\n  geom_bar(stat=\\\u0022identity\\\u0022,fill=\\\u0022red\\\u0022)+\\n  coord_flip()+theme_bw()\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00222e1d120d46ddd4b98e9a5af2291ecd65bd3dd454\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022checkColumn = function(df,colname){\\n  testData = df[[colname]]\\n  numMissing = max(sum(is.na(testData)|is.nan(testData)|testData==\u0027\u0027),0)\\n  if (class(testData) == \u0027numeric\u0027 | class(testData) == \u0027Date\u0027 | class(testData) == \u0027difftime\u0027 | class(testData) == \u0027integer\u0027){\\n    list(\u0027col\u0027 = colname,\u0027class\u0027 = class(testData), \u0027num\u0027 = length(testData) - numMissing, \u0027numMissing\u0027 = numMissing, \u0027numInfinite\u0027 = sum(is.infinite(testData)), \u0027avgVal\u0027 = mean(testData,na.rm=TRUE), \u0027minVal\u0027 = round(min(testData,na.rm = TRUE)), \u0027maxVal\u0027 = round(max(testData,na.rm = TRUE)))\\n  } else{\\n    list(\u0027col\u0027 = colname,\u0027class\u0027 = class(testData), \u0027num\u0027 = length(testData) - numMissing, \u0027numMissing\u0027 = numMissing, \u0027numInfinite\u0027 = NA,  \u0027avgVal\u0027 = NA, \u0027minVal\u0027 = NA, \u0027maxVal\u0027 = NA)\\n  }\\n}\\n\\ncheckAllCols = function(df){\\n  resDF = data.frame()\\n  for (colName in names(df)){\\n    resDF = rbind(resDF,as.data.frame(checkColumn(df=df,colname=colName)))\\n  }\\n  resDF\\n}\\n\\ncheckAllCols(full)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022a68938ab26725a566bd9cb05c988bb2e688422cd\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022miss_pct \u003c- map_dbl(full, function(x) { round((sum(is.na(x)) / length(x)) * 100, 1) })\\nmiss_pct \u003c- miss_pct[miss_pct \u003e 0]\\n\\ndata.frame(miss=miss_pct, var=names(miss_pct), row.names=NULL) %\u003e%\\n    ggplot(aes(x=reorder(var, miss), y=miss)) + \\n    geom_bar(stat=\u0027identity\u0027, fill=\u0027red\u0027) +\\n    labs(x=\u0027\u0027, y=\u0027% missing\u0027, title=\u0027Percent missing data by feature\u0027) +\\n    theme(axis.text.x=element_text(angle=90, hjust=1))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022c5602ae10d5ce0345dfbe57406f34d2943306548\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022full \u003c- full %\u003e%\\n    mutate(\\n      Age = ifelse(is.na(Age), mean(full$Age, na.rm=TRUE), Age),\\n      `Age Group` = case_when(Age \u003c 13 ~ \\\u0022Age.0012\\\u0022, \\n                                 Age \u003e= 13 \u0026 Age \u003c 18 ~ \\\u0022Age.1317\\\u0022,\\n                                 Age \u003e= 18 \u0026 Age \u003c 60 ~ \\\u0022Age.1859\\\u0022,\\n                                 Age \u003e= 60 ~ \\\u0022Age.60Ov\\\u0022))\\n\\ntable(full$`Age Group`)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022040f0ce215182b6f918d297b625f4e729dbeda32\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022full$Embarked \u003c- replace(full$Embarked, which(is.na(full$Embarked)), \u0027S\u0027)\\ntable(full$Embarked)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00225162b7a8bb31d3913bb3ac9711c9a6a32f31637f\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022names \u003c- full$Name\\ntitle \u003c-  gsub(\\\u0022^.*, (.*?)\\\\\\\\..*$\\\u0022, \\\u0022\\\\\\\\1\\\u0022, names)\\nfull$title \u003c- title\\ntable(title)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022bbc6c20e6c4c50e46b61f3a28e7d90e7a871ce90\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022### MISS, Mrs, Master and Mr은 더 많은 숫자를 사용하고 있습니다.\\n### 성별과 생존율을 확인하여 다른 과목을 더 큰 바구니에 그룹화하는 것이 더 좋음\\n\\nfull$title[full$title == \u0027Mlle\u0027]        \u003c- \u0027Miss\u0027 \\nfull$title[full$title == \u0027Ms\u0027]          \u003c- \u0027Miss\u0027\\nfull$title[full$title == \u0027Mme\u0027]         \u003c- \u0027Mrs\u0027 \\nfull$title[full$title == \u0027Lady\u0027]          \u003c- \u0027Miss\u0027\\nfull$title[full$title == \u0027Dona\u0027]          \u003c- \u0027Miss\u0027\\n\\n# 나는 작은 데이터로 새로운 변수를 생성하는 것이 overfit을 야기 할 수 있다고 생각한다.\\n\\nfull$title[full$title == \u0027Capt\u0027]        \u003c- \u0027Officer\u0027 \\nfull$title[full$title == \u0027Col\u0027]        \u003c- \u0027Officer\u0027 \\nfull$title[full$title == \u0027Major\u0027]   \u003c- \u0027Officer\u0027\\nfull$title[full$title == \u0027Dr\u0027]   \u003c- \u0027Officer\u0027\\nfull$title[full$title == \u0027Rev\u0027]   \u003c- \u0027Officer\u0027\\nfull$title[full$title == \u0027Don\u0027]   \u003c- \u0027Officer\u0027\\nfull$title[full$title == \u0027Sir\u0027]   \u003c- \u0027Officer\u0027\\nfull$title[full$title == \u0027the Countess\u0027]   \u003c- \u0027Officer\u0027\\nfull$title[full$title == \u0027Jonkheer\u0027]   \u003c- \u0027Officer\u0027  \u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00227554fcdb477bd2d49b810e6c5dbab5d6b1d38d21\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022table(full$title)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00225e0ee917fe85c1aa9edbd940dfecb717b6510003\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022full$FamilySize \u003c-full$SibSp + full$Parch + 1 \\nfull$FamilySized[full$FamilySize == 1] \u003c- \u0027Single\u0027 \\nfull$FamilySized[full$FamilySize \u003c 5 \u0026 full$FamilySize \u003e= 2] \u003c- \u0027Small\u0027 \\nfull$FamilySized[full$FamilySize \u003e= 5] \u003c- \u0027Big\u0027 \\nfull$FamilySized=as.factor(full$FamilySized)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022f1a2135efbac75447041ca9e2667b86f8badc6a0\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022plot(full$FamilySized)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022514b8ffb9a8b474cc06c9c9c535ba62dfcf07275\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022##Engineer features based on all the passengers with the same ticket\\nticket.unique \u003c- rep(0, nrow(full))\\ntickets \u003c- unique(full$Ticket)\\n\\nfor (i in 1:length(tickets)) {\\n  current.ticket \u003c- tickets[i]\\n  party.indexes \u003c- which(full$Ticket == current.ticket)\\n  for (k in 1:length(party.indexes)) {\\n    ticket.unique[party.indexes[k]] \u003c- length(party.indexes)\\n  }\\n}\\n\\nfull$ticket.unique \u003c- ticket.unique\\nfull$ticket.size[full$ticket.unique == 1]   \u003c- \u0027Single\u0027\\nfull$ticket.size[full$ticket.unique \u003c 5 \u0026 full$ticket.unique\u003e= 2]   \u003c- \u0027Small\u0027\\nfull$ticket.size[full$ticket.unique \u003e= 5]   \u003c- \u0027Big\u0027\\n\\ntable(full$ticket.size)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022c584aa3e102aca5d87656c1e1cfa792ecdcf0e30\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022full \u003c- full %\u003e%\\n mutate(Survived = case_when(Survived==1 ~ \\\u0022Yes\\\u0022, \\n                              Survived==0 ~ \\\u0022No\\\u0022))\\n\\ncrude_summary \u003c- full %\u003e%\\n  filter(set==\\\u0022train\\\u0022) %\u003e%\\n  select(PassengerId, Survived) %\u003e%\\n  group_by(Survived) %\u003e%\\n  summarise(n = n()) %\u003e%\\n  mutate(freq = n / sum(n))\\n\\ncrude_survrate \u003c- crude_summary$freq[crude_summary$Survived==\\\u0022Yes\\\u0022]\\nkable(crude_summary, caption=\\\u00222x2 Contingency Table on Survival.\\\u0022, format=\\\u0022markdown\\\u0022)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022c36ad2a802afa709da84105d9764f2bfca6d015a\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022g1_pclass \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022), aes(Pclass, fill=Survived)) +\\n  geom_bar(position = \\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by Class\\\u0022) + \\n  theme_minimal()\\n\\ng2_sex \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022), aes(Sex, fill=Survived)) +\\n  geom_bar(position = \\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by Sex\\\u0022) + \\n  theme_minimal()\\n\\ntbl_age \u003c- full %\u003e%\\n  filter(set==\\\u0022train\\\u0022) %\u003e%\\n  select(Age, Survived) %\u003e%\\n  group_by(Survived) %\u003e%\\n  summarise(mean.age = mean(Age, na.rm=TRUE))\\n\\ng3_age \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022), aes(Age, fill=Survived)) +\\n  geom_histogram(aes(y=..density..), alpha=0.5) +\\n  geom_density(alpha=.2, aes(colour=Survived)) +\\n  geom_vline(data=tbl_age, aes(xintercept=mean.age, colour=Survived), lty=2, size=1) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_colour_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Density\\\u0022) +\\n  ggtitle(\\\u0022Survival Rate by Age\\\u0022) + \\n  theme_minimal()\\n\\ng4_agegroup \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022 \u0026 !is.na(Age)), aes(`Age Group`, fill=Survived)) +\\n  geom_bar(position = \\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by Age Group\\\u0022) + \\n  theme_minimal()\\n\\ng5_sibsp \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022), aes(SibSp, fill=Survived)) +\\n  geom_bar(position = \\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by SibSp\\\u0022) + \\n  theme_minimal()\\n\\ng6_parch \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022), aes(Parch, fill=Survived)) +\\n  geom_bar(position = \\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by Parch\\\u0022) + \\n  theme_minimal()\\n\\ng7_embarked \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022), aes(Embarked, fill=Survived)) +\\n  geom_bar(position = \\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by Embarked\\\u0022) + \\n  theme_minimal()\\n\\ng8_title \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022) %\u003e% na.omit, aes(title, fill=Survived)) +\\n  geom_bar(position=\\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by Title\\\u0022) + \\n  theme_minimal() +\\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\\n\\ng9_family \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022) %\u003e% na.omit, aes(`FamilySize`, fill=Survived)) +\\n  geom_bar(position=\\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by Family Group\\\u0022) + \\n  theme_minimal() +\\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00226a84abaebaa1f77565db448d03f4dc9d5a26fcec\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022grid.arrange(g1_pclass, g2_sex)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00225882a16041a98a997060146bf87a2f3f90499a4f\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022grid.arrange(g3_age , g4_agegroup)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022b8470479bc24d336549b9efccf86b33d61d93826\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022grid.arrange(g5_sibsp  , g6_parch)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002265524921f12b5eaba8131deca0cd2e77753cdfef\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022grid.arrange(g7_embarked   , g8_title, g9_family )\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00226c81224f793394d3e017b908bb5c7355ba45bae6\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022tbl_corr \u003c- full %\u003e%\\n  filter(set==\\\u0022train\\\u0022) %\u003e%\\n  select(-PassengerId, -SibSp, -Parch) %\u003e%\\n  select_if(is.numeric) %\u003e%\\n  cor(use=\\\u0022complete.obs\\\u0022) %\u003e%\\n  corrplot.mixed(tl.cex=0.85)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00223eaa5e63ca88aa8149399873c0cda5ab51ed34aa\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022tbl_mosaic \u003c- full %\u003e%\\n  filter(set==\\\u0022train\\\u0022) %\u003e%\\n  select(Survived, Pclass, Sex, AgeGroup=`Age Group`, title, Embarked, `FamilySize`) %\u003e%\\n  mutate_all(as.factor)\\n\\nmosaic(~Pclass+Sex+Survived, data=tbl_mosaic, shade=TRUE, legend=TRUE)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022291dfff7f5e917a340215e2b5050ca9c9fad82e1\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022library(alluvial)\\n\\ntbl_summary \u003c- full %\u003e%\\n  filter(set==\\\u0022train\\\u0022) %\u003e%\\n  group_by(Survived, Sex, Pclass, `Age Group`, title) %\u003e%\\n  summarise(N = n()) %\u003e% \\n  ungroup %\u003e%\\n  na.omit\\n\\nalluvial(tbl_summary[, c(1:4)],\\n         freq=tbl_summary$N, border=NA,\\n         col=ifelse(tbl_summary$Survived == \\\u0022Yes\\\u0022, \\\u0022blue\\\u0022, \\\u0022gray\\\u0022),\\n         cex=0.65,\\n         ordering = list(\\n           order(tbl_summary$Survived, tbl_summary$Pclass==1),\\n           order(tbl_summary$Sex, tbl_summary$Pclass==1),\\n           NULL,\\n           NULL))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00228e46c15a994073a4e91b2f7f2bcaab21dc06122f\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022## Titantic Mega Model - [0.84210] 커널 튜토리얼\\n\\n- 6 가지 모델이 1 가지 모델보다 뛰어날까요?\\n- 타이탄 메가 모형은 Kaggle의 최고 6 개의 타이탄 모형의 앙상블이고 84.2 % 성능!! 먼저 우리는 이름만 모델을 사용하여 간단한 타이타닉으로 시작합니다. Ticket, Fare, Pclass를 조심스럽게 통합함으로써 점수를 83.3 % 인상 할 것입니다. \\n\\n- 모델은 모든 여성과 소년이 살고있는 가정의 모든 소년의 생존율을 예측합니다. 그리고 그것은 모든 여성과 소년들이 죽은 한 가족의 모든 여성들에 대해 사망할 것이라고 예측합니다. \\n- 그것은 단지 22 가지 예언을 합니다. 시험 데이터 세트에 396 명의 승객이 남아 있습니다. 우리는 그 (것)들을 예언하기 위하여 Kaggle의 최고 타이탄 모형의 앙상블을 건설 할 것\\n\\n![Titanic Mega Model](http://playagricola.com/Kaggle/tree6.jpg)\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002287adea7141ce3b909340513cb6287f6964a652ee\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022## PART A: The Woman-Child-Group Model\\n\\n- 여기에 게시 된 Woman-Child-Group 모델에서 여성 - 아동 집단은 surname(칭호, 호칭)으로 형성되었습니다. 그러나 Surname는 항상 승객이 같은 가족에 속해 여행한다는 의미는 아닙니다. 승객 195와 1167을보십시오 :\\n\\n`PId Pclass              Name     Sex Age SibSp Parch   Ticket    Fare Cabin Embarked\\n195   1     Brown, Mrs. James  female  44     0     0 PC 17610 27.7208    B4        C\\n1067  2    Brown, Miss. Edith  female  15     0     2    29750 39.0000              S`  \\n\\n\\n- 그들은 둘 다 Surname이 \u0027브라운\u0027이며 딸과 함께 여행하는 어머니인 것으로 보입니다. 그러나, 그들은 다른 Pclasses, 다른 티켓, 다른 요금, 다른 캐빈, 다른 착륙, 호환되지 않는 SibSp과 Parch 있습니다. 나는 이 두 승객이 관련이 없다고 생각한다. 이제 승객 59, 473 및 1142를 살펴보십시오.\\n\\n`PId Pclass                 Name    Sex   Age SibSp Parch     Ticket  Fare Cabin Embarked\\n59      2 West, Miss. Constance  female  5.00     1     2 C.A. 34651 27.75              S\\n473     2 West, Mrs. Edwy Arthur female 33.00     1     2 C.A. 34651 27.75              S \\n1142    2    West, Miss. Barbara female  0.92     1     2 C.A. 34651 27.75              S`  \\n\\nThey all have the surname \u0027West\u0027 and appear to be a mother traveling with her two daughters. They have the same Pclass, same Ticket, same Fare, same Cabin, same Embarked, and compatible SibSp and Parch. I believe these three passengers are related.\\n\\n- 그들은 모두 \u0027West\u0027라는 Surname을 갖고 있으며 두 딸과 함께 여행하는 어머니 인 것으로 보입니다. 그들에는 동일한 Pclass, 동일한 표, 동일한 운임, 동일한 오두막, 동일한 Embarked 및 겸용성 SibSp 및 Parch가있다. 나는이 세 명의 승객이 관련이 있다고 믿는다.\\n\\n\\n### A1. Engineer a precise GroupId for woman-child-groups\\n\\n- 가족을 정확하게 식별하는 GroupId를 작성합시다. Jack Roberts는 Ticket에는 커널의 Surnames와 동일한 그룹화 정보가 들어 있습니다. 티켓만 사용하거나 그룹을 형성하기 위해 Surname만 사용하면 실수로 이어집니다. \\n- 따라서 각 승객에 대해 연결 그룹 ID = Surname + Pclass + 티켓 + 운임 + 승차권을 형성합시다. \\n- 때로는 함께 여행하는 승객의 티켓이 마지막 자리에서 달라지므로 티켓의 마지막 자리도 제거합시다. 예를 들어, 웨스트 부인의 티켓을 \u0027C.A. 34651 \u0027~\u0027C.A. 3465X \u0027. (나는이 멋진 트릭을 Erik Bruin의 노트 4.2.4 절의 티켓 번호를 제거하기 위해 배웠다.) \\n- 나는 의도적으로 SibSp와 Parch를 GroupId에 포함하지 않습니다. 왜냐하면 많은 오류가 있기 때문입니다 (아래 설명 참조). Cabin 데이터가 너무 많아서 Cabin을 포함하지 않습니다.\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022d675046f9b9378e239a7f41a4456bd87e1d413cc\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data \u003c- rbind(train,test)\\ndata$Surname = substring( data$Name,0,regexpr(\u0027,\u0027,data$Name)-1)\\ndata$GroupId = paste( data$Surname, data$Pclass, sub(\u0027.$\u0027,\u0027X\u0027,data$Ticket), data$Fare, data$Embarked, sep=\u0027-\u0027)\\ndata[c(195,1067,59,473,1142),c(\u0027Name\u0027,\u0027GroupId\u0027)]\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002274d8b0d8fcbd9697c29febf9cdc07890150a3c11\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- 이 새로운 GroupId를 사용하면 West는 함께 여행했지만 Brown은 그렇지 않았음이 분명합니다\\n\\n ### A2. Identify Nannies and Relatives traveling in woman-child-groups\\n \\n -  Now look at the following passengers:\\n\\n`PId Pclass                      Name    Sex Age SibSp Parch   Ticket   Fare      Cabin Embarked\\n312   1    Ryerson, Miss. Emily Borie female  18     2    2 PC 17608 262.375 B57 B59 B63 B66   C\\n743   1  Ryerson, Miss. Susan Parker  female  21     2    2 PC 17608 262.375 B57 B59 B63 B66   C\\n91    1  Ryerson, Mrs. Maria          female  48     1    3 PC 17608 262.375 B57 B59 B63 B66   C\\n951   1   Chaudanson, Miss. Victorine female  36     0    0 PC 17608 262.375             B61   C\\n956   1   Ryerson, Master. John Borie   male  13     2    2 PC 17608 262.375 B57 B59 B63 B66   C\\n1034  1    Ryerson, Mr. Arthur Larned   male  61     1    3 PC 17608 262.375 B57 B59 B63 B66   C`\\n\\n- 이것은 Ryerson 가족입니다. 성인 2 명과 어린이 3 명이 있습니다. 그들은 티켓 = \u0027PC 17608\u0027에서 Cabin B57, B59, B63 및 B66에 머물렀다. \\n- Pclass = 1에서 Embarked = C. Chaudanson Miss도 Ticket = \u0027PC 17608\u0027을 구입하고 그들 옆의 캐빈 인 Cabin = B61에 머물렀다. \\n- 나는 Chaudanson Miss가 Ryerson 가족과 함께 여행했고 유모 또는 친척 중 하나라고 생각합니다. 우리는 보모와 친척을 우리 여성 - 자녀 그룹에 추가하고 싶습니다. 왜냐하면 그 데이터는 그들이 여행 한 여성과 자녀들과 함께 살았거나 사망 한 것을 보여주기 때문입니다.\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002250c5dccbac8641dafd10ec87ab0d7a9b648a8ea5\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022# engineer titles\\ndata$Title \u003c- \u0027man\u0027\\ndata$Title[data$Sex==\u0027female\u0027] \u003c- \u0027woman\u0027\\ndata$Title[grep(\u0027Master\u0027,data$Name)] \u003c- \u0027boy\u0027\\n\\n\\n# color variable is used in plots below\\ndata$Color \u003c- data$Survived\\n\\n\\n# engineer \\\u0022woman-child-groups\\\u0022\\ndata$GroupId[data$Title==\u0027man\u0027] \u003c- \u0027noGroup\u0027\\ndata$GroupFreq \u003c- ave(1:1309,data$GroupId,FUN=length)\\ndata$GroupId[data$GroupFreq\u003c=1] \u003c- \u0027noGroup\u0027\\ndata$TicketId = paste( data$Pclass,sub(\u0027.$\u0027,\u0027X\u0027,data$Ticket),data$Fare,data$Embarked,sep=\u0027-\u0027)\\ncount = 0\\n\\n\\n# add nannies and relatives to groups\\nfor (i in which(data$Title!=\u0027man\u0027 \u0026 data$GroupId==\u0027noGroup\u0027)){\\n    data$GroupId[i] = data$GroupId[data$TicketId==data$TicketId[i]][1]\\n    if (data$GroupId[i]!=\u0027noGroup\u0027) {\\n        # color variable is used in plots below\\n        if (is.na(data$Survived[i])) data$Color[i] = 5\\n        else if (data$Survived[i] == 0) data$Color[i] = -1\\n        else if (data$Survived[i] == 1) data$Color[i] = 2\\n        count = count + 1\\n    }\\n}\\ncat(sprintf(\u0027우리는 %d 명의 보모/친척을 찾아 그룹에 추가했습니다.\\\\n\u0027,count))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002257c2f15d0dae2d9eac8c045818987592a7dd00c6\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022### A3. Classify unknown woman-child-groups\\n\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022d97c10b1ee641419cb80b3c98a15b1b06523fada\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022b3d29e62b1d522c230f30a47f0d5943b47fed74e\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data$GroupName = substring( data$GroupId,0,regexpr(\u0027-\u0027,data$GroupId)-1)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022b2592076beae4035be4ec58fe89b1dbe1522db91\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022table(data$GroupName)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002201dc5ad720f8b1d9708081ff974ab1f38f412997\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data$Color[is.na(data$Color) \u0026 data$Title==\u0027woman\u0027] \u003c- 3\\ndata$Color[is.na(data$Color) \u0026 data$Title==\u0027boy\u0027] \u003c- 4\\nx = data$GroupId[data$GroupId!=\u0027noGroup\u0027]; x = unique(x); x=x[order(x)]\\nplotData \u003c- list(); g \u003c- list()\\n\\nfor (i in 1:3) plotData[[i]] \u003c- data[data$GroupId %in% x[(27*(i-1))+1:27],]\\nfor (i in 1:3) g[[i]] = ggplot(data=plotData[[i]], aes(x=0,y=factor(GroupName))) +\\n    geom_dotplot(dotsize=0.9,binwidth=1,binaxis=\u0027y\u0027,method=\\\u0022histodot\\\u0022,stackgroups=T,\\n        aes(fill=factor(Color),color=Title )) +\\n    scale_color_manual(values=c(\u0027gray70\u0027,\u0027blue\u0027,\u0027gray70\u0027),limits=c(\u0027man\u0027,\u0027boy\u0027,\u0027woman\u0027)) +\\n    scale_fill_manual(values=c(\u0027#BB0000\u0027,\u0027#FF0000\u0027,\u0027#009900\u0027,\u0027#00EE00\u0027,\u0027gray70\u0027,\u0027gray70\u0027,\u0027white\u0027),\\n        limits=c(\u00270\u0027,\u0027-1\u0027,\u00271\u0027,\u00272\u0027,\u00273\u0027,\u00274\u0027,\u00275\u0027)) +\\n    scale_y_discrete(limits = rev(levels(factor(plotData[[i]]$GroupName)))) +\\n        theme(axis.title.x=element_blank(), axis.title.y=element_blank(),\\n        axis.text.x=element_blank(), axis.ticks.x=element_blank(),\\n        legend.position=\u0027none\u0027)\\ngrid.arrange(g[[1]],g[[2]],g[[3]],nrow=1,top=\u0027All 80 woman-child-groups in the test and training datasets combined (228 passengers).\\nRed = deceased female or boy, Green = survived, White or Gray = unknown survival, \\nWhite or LightGreen or LightRed = different surname same ticket, Blue outline = boy\u0027)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022a86809b9380c851cda5fe8abe3c1aa398046af05\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- 테스트 및 훈련 데이터 세트의 모든 80 명의 여성 - 아동 그룹이 합쳐졌습니다 (228 명의 승객). 빨간색 = 사망 한 여성 또는 소년, 녹색 = 생존, 흰색 또는 회색 = 생존 알 수 없음, 흰색 또는 LightGreen 또는 LightRed = 다른 성 이름의 티켓, 파란색 외곽선 = 소년\\n\\n- 첫 번째로 80 명의 여성 - 아동 집단 모두가 살았거나 모두 사망했는지 (우리가 알고있는 생존 정보를 기반으로) 주목합니다. 그것은 여성 - 아동 집단 모델의 숨은 비밀입니다. \\n- 알 수 없는 회색 또는 흰색 원을 앞의 점의 색과 같게 설정하여 예측해야 한다고 합니다. \\n- 예를 들어, Abbott는 살아있는 한 여성이 하나의 알려지지 않은 소년과 함께 여행하는 것을 보여줍니다. 미지의 소년 승객 1284 Master Eugene Abbott가 살아 남았음을 예측해야합니다. \\n\\n- 그룹 전체가 알려지지 않은 네 개의 가족이 있습니다. 이 가족은 Gibson, Klasen, Peacock, van Billiard입니다. 우리는 그들에 대한 예언을 해야합니다. 그래서 어느 여성 - 자녀 집단이 살고 있는지를 탐구합시다.\\n\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00225ef66a9e98d2ab193b01f9c8a1713b3f760d83d7\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data$Survived \u003c- factor(data$Survived)\\ndata$CabinLetter \u003c- substring(data$Cabin,0,1)\\ng1 = ggplot(data=data[data$GroupId!=\u0027noGroup\u0027 \u0026 !is.na(data$Survived),]) +\\n    geom_bar(stat=\u0027count\u0027,aes(x=Pclass,fill=Survived))\\ng2 = ggplot(data=data[data$GroupId!=\u0027noGroup\u0027 \u0026 !is.na(data$Survived) \u0026 !is.na(data$Age),]) +\\n    geom_histogram(bins=20,aes(x=Age,fill=Survived))\\ng3 = ggplot(data=data[data$GroupId!=\u0027noGroup\u0027 \u0026 !is.na(data$Survived),]) +\\n    geom_bar(stat=\u0027count\u0027,aes(x=Embarked,fill=Survived))\\ng4 = ggplot(data=data[data$GroupId!=\u0027noGroup\u0027 \u0026 !is.na(data$Survived),]) +\\n    geom_bar(stat=\u0027count\u0027,aes(x=CabinLetter,fill=Survived))\\ngrid.arrange(g1,g2,g3,g4,nrow=2,top=\u0027Analysis of training set\\\\\u0027s 156 Woman-Child-Group passengers\u0027)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002297d32fc8f739f8b84f824c31dcfd6be08615e663\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- 분석에서 우리는 Pclass = 1 또는 2로 여행하는 여성 - 아동 집단이 대부분 생존하고 Pclass = 3에있는 여성 - 아동 집단이 대부분 사망 한 것을 알 수있다. \\n- Gibsons는 Pclass = 1, Embarked = C 및 Cabin이 없었으므로 Gibsons가 살아남은 것을 예측해야합니다.\\n- Klasen \u0027s, Peacock \u0027s, van billiards는 Pclass = 3, Embarked = S, Cabin은 없었습니다. 그러므로 우리는 이 세 가정이 소멸 될 것이라고 예측해야 합니다.\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022897e18c7c2bd959889d34fd6e281710fddd7f9f1\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022### A4. Cross Validation\\n\\n- 이름 만 사용할 때이 모델은 훈련 데이터 세트에서 83.6 %의 유효성을 확인합니다. (1) 정확한 GroupId 사용, (2) 유모 및 친척 포함, (3) 알 수없는 그룹 분류로 모델의 정확성이 향상되는지 봅시다.\\n\\n[Titanic using Name only - 0.81818](https://www.kaggle.com/cdeotte/titanic-using-name-only-0-81818)\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002265d4298e5ecb24440feaeddfd8f65214754a02ca\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022# engineer titles on training set\\ntrain$Title \u003c- \u0027man\u0027\\ntrain$Title[train$Sex==\u0027female\u0027] \u003c- \u0027woman\u0027\\ntrain$Title[grep(\u0027Master\u0027,train$Name)] \u003c- \u0027boy\u0027\\n\\n\\n# Perform 25 trials of 10-fold cross validation\\ntrials = 25; sum = 0\\n\\nfor (j in 1:trials){\\nx = sample(1:890); s = 0\\nfor (i in 0:9){\\n    # engineer \\\u0022woman-child-groups\\\u0022\\n    train$Surname \u003c- substring(train$Name,0,regexpr(\\\u0022,\\\u0022,train$Name)-1)\\n    train$GroupId = paste( train$Surname, train$Pclass,sub(\u0027.$\u0027,\u0027X\u0027,train$Ticket),train$Fare,train$Embarked,sep=\u0027-\u0027)\\n    train$GroupId[train$Title==\u0027man\u0027] \u003c- \u0027noGroup\u0027\\n    train$GroupFreq \u003c- ave(1:891,train$GroupId,FUN=length)\\n    train$GroupId[train$GroupFreq\u003c=1] \u003c- \u0027noGroup\u0027\\n    # add nannies and relatives to groups.\\n    train$TicketId = paste( train$Pclass,sub(\u0027.$\u0027,\u0027X\u0027,train$Ticket),train$Fare,train$Embarked,sep=\u0027-\u0027)\\n    for (k in which(train$Title!=\u0027man\u0027 \u0026 train$GroupId==\u0027noGroup\u0027))\\n        train$GroupId[k] = train$GroupId[train$TicketId==train$TicketId[k] \u0026 train$PassengerId != train$PassengerId[k]][1]\\n    train$GroupId[is.na(train$GroupId)] \u003c- \u0027noGroup\u0027\\n    train$GroupFreq \u003c- ave(1:891,train$GroupId,FUN=length)\\n    # calculate training subset\u0027s group survival rate\\n    train$GroupSurvival \u003c- NA\\n    train$GroupSurvival[-x[1:89+i*89]] \u003c- ave(train$Survived[-x[1:89+i*89]],train$GroupId[-x[1:89+i*89]])\\n    # calculate testing subset\u0027s group survival rate from training set\u0027s rate\\n    for (k in x[1:89+i*89]){ \\n        train$GroupSurvival[k] \u003c- train$GroupSurvival[which(!is.na(train$GroupSurvival) \u0026 train$GroupId==train$GroupId[k])[1]]\\n        if (is.na(train$GroupSurvival[k])) train$GroupSurvival[k] \u003c- ifelse(train$Pclass[k]==3,0,1)\\n    }\\n    # apply gender model plus WCG\\n    train$predict \u003c- 0\\n    train$predict[train$Title==\u0027woman\u0027] \u003c- 1\\n    train$predict[train$Title==\u0027boy\u0027 \u0026 train$GroupSurvival==1] \u003c- 1\\n    train$predict[train$Title==\u0027woman\u0027 \u0026 train$GroupSurvival==0] \u003c- 0\\n    c = sum(abs(train$predict[x[1:89+i*89]] - train$Survived[x[1:89+i*89]]))\\n    s = s + c\\n}\\n#cat( sprintf(\\\u0022Trial %d has 10-fold CV accuracy = %f\\\\n\\\u0022,j,1-s/890))\\nsum = sum + 1-s/890\\n}\\ncat(sprintf(\\\u0022Average 10-fold CV accuracy from %d trials = %f\\\\n\\\u0022,trials,sum/trials))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022d004f0346a6e35d603fccff8b0a1e2e58bc10dc5\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- 우리의 정확도는 0.8 % 증가하여 84.4 %로 나타났습니다. 우리의 변화가 도움이 된 것 같습니다. 테스트 데이터 세트에 대한 예측을하고 Kaggle에 제출하십시오.\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022a17bd53d48d5d414eb12b940681e4be8e02aee3c\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022### A5. Make Predictions\\n\\n- 테스트 데이터 세트에서 여성 - 아동 그룹의 일부인 72 명의 승객이 있습니다. 두 가지 예측 규칙을 적용 해 보겠습니다.\\n- unknown passenger\u0027s woman-child-group이 모두 살거나 모두 사망 한 경우 (훈련 데이터 세트에 표시된대로), 그들이 동일하게 수행 한 것으로 예측하십시오.\\n- 알 수없는 승객의 woman-child-group에 훈련 데이터 세트에 구성원이 없으면 Pclass = 3 die, Pclass = 1 또는 2 Pclass를 사용하여 생존할 거라고 예측하십시오.\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00229e32eb9ea8d593778d0a288ad7ad50f6afd15023\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data$GroupSurvival \u003c- NA\\ndata$Survived \u003c- as.numeric(as.character(data$Survived))\\ndata$GroupSurvival[1:891] \u003c- ave(data$Survived[1:891],data$GroupId[1:891])\\nfor (i in 892:1309) data$GroupSurvival[i] \u003c- data$GroupSurvival[which(data$GroupId==data$GroupId[i])[1]]\\ndata$GroupSurvival[is.na(data$GroupSurvival) \u0026 data$Pclass==3] \u003c- 0\\ndata$GroupSurvival[is.na(data$GroupSurvival) \u0026 data$Pclass!=3] \u003c- 1\\ndata$Predict \u003c- 0\\ndata$Predict[data$Sex==\u0027female\u0027] \u003c- 1\\ndata$Predict[data$Title==\u0027woman\u0027 \u0026 data$GroupSurvival==0] \u003c- 0\\ndata$Predict[data$Title==\u0027boy\u0027 \u0026 data$GroupSurvival==1] \u003c- 1\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022ea13cc5ec35c494dd8fc5f8d404606d7c439d41b\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022cat(\u0027The following 8 males are predicted to live\\\\n\u0027)\\ndata[data$Sex==\u0027male\u0027 \u0026 data$Predict==1 \u0026 data$PassengerId\u003e891,c(\u0027Name\u0027,\u0027Title\u0027)]\\ncat(\u0027The following 14 females are predicted to die\\\\n\u0027)\\ndata[data$Sex==\u0027female\u0027 \u0026 data$Predict==0 \u0026 data$PassengerId\u003e891,c(\u0027Name\u0027,\u0027Title\u0027)]\\ncat(\u0027The remaining 258 males are predicted to die\\\\n\u0027)\\ncat(\u0027and the remaining 138 females are predicted to live\\\\n\u0027)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022e82007bd3788602fa8c350f0dda2b3e79307819b\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022submit \u003c- data.frame(PassengerId = 892:1309, Survived = data$Predict[892:1309])\\nwrite.csv(submit,\u0027genderSurnameModel2.csv\u0027,row.names=F)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002279426420947ab58a3a5d2947b8ee665a432c062a\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022 ![result](http://playagricola.com/Kaggle/surnameModel2.png)\\n Woohoo!! Our simple woman-child-group model scores 83.3%, incredible!\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022cd97eaa0a3f27649622db315a46f2b687d3be4af\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022### A6. Why didn\u0027t we use SibSp, Parch, Cabin in GroupId?\\n\\n- 왜 우리는 SibSp, Parch 및 Cabin을 사용하여 우리 여성 - 아동 집단을 확인하지 않았습니까? 여성 - 자녀 집단이 속한 80 개 가정에서 SibSp와 Parch는 27 개의 오류가 있습니다. 다음은 오류의 예입니다.\\n\\n`PId Pclass               Name    Sex Age SibSp Parch     Ticket  Fare Embarked\\n162     2     Watt, Mrs. James female  40     0     0 C.A. 33595 15.75        S\\n1012    2   Watt, Miss. Bertha female  12     0     0 C.A. 33595 15.75        S`  \\n\\n- 다음은 딸과 함께 여행하는 어머니입니다. 그들은 동일한 성, 동일한 Pclass, 동일한 표, 동일한 운임, 동일한 승선이 있습니다. 그러나 SibSp와 Parch는 모두 0과 같습니다. Cabin 정보의 77.5 %가 누락 되었기 때문에 우리 그룹에서 Cabin을 사용하지 않았습니다.\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002233b164e59b30446d2841ccca1a826fe4059e5ada\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022## Titanic WCG+XGBoost Tutorial\\n\\n[Titanic WCG+XGBoost - 0.84688](https://www.kaggle.com/cdeotte/titanic-wcg-xgboost-0-84688)\\n\\n- 타이타닉 테스트 데이터 세트에는 성인 남성이 245 명이 있습니다. Kaggle의 모든 상위 모델을 검토하면 모든 성인 남성이 사망 할 것이라고 모든 사람이 예측합니다. \\n\\n- 살았던 성인 남성 한 명 이상을 찾을 수 있습니까? 성인 남성의 생존율을 정확하게 예측할 수 있다면 가장 정확한 타이타닉 모델을 구할 수 있습니다!\\n\\n![tree12](http://playagricola.com/Kaggle/tree12.jpg)  \\n  \\n\\n### Explore adult males survival with XGBoost\\n\\n- 먼저 Titanic 데이터 세트를 로드하고 Age and Fare가 누락된 것을 확인할 수 있습니다.\\n- 다음으로 x1 = Fare / (Ticket Frequency * 10) 및 x2 = Parch + SibSp + 1 + (Age / 70)의 두 가지 새로운 변수를 설계합니다. 형상 공간을 2 차원으로 축소하면 모든 것을 시각화 할 수 있습니다.\\n  \\n[1]:https://www.kaggle.com/cdeotte/titanic-wcg-xgboost-0-84688\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022735b006ad1c995865797083200301025a7efcb01\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022train \u003c- read.csv(\u0027../input/titanic/train.csv\u0027,stringsAsFactors=F)\\ntest \u003c- read.csv(\u0027../input/titanic/test.csv\u0027,stringsAsFactors=F)\\ntest$Survived \u003c- NA; data \u003c- rbind(train,test)\\n# engineer person type\\ndata$Title \u003c- \u0027man\u0027\\ndata$Title[grep(\u0027Master\u0027,data$Name)] \u003c- \u0027boy\u0027\\ndata$Title[data$Sex==\u0027female\u0027] \u003c- \u0027woman\u0027\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00226a1afbd4b4bffae8767fe01c57be4a1dbd60bed4\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022fit \u003c- rpart(Age ~ Title + Pclass + SibSp + Parch,data=data)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00221b3981c92813e76c74b45477a682fe85dee24e85\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022fit\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00222fc4b627d7c2691d274e04f3521d7cae80ac51b1\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data$Age[is.na(data$Age)] \u003c- predict(fit,newdata=data[is.na(data$Age),])\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00224726a460441a97d8e5ee99d367dc35a07c80eb93\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022fit \u003c- rpart(Fare ~ Title + Pclass + Embarked + Sex + Age,data=data)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022118236ffcd686078804db2fe927dfaeebb35dd7c\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022fit\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022831cc392c0feab2009a8310e49260e4227439000\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data$Fare[is.na(data$Fare)] \u003c- predict(fit,newdata=data[is.na(data$Fare),])\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002283184213599c9d11bcaf25ae8bb1ccda67ed9a30\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data \u003c- data %\u003e% as.tibble() %\u003e%\\n    mutate(TicketFreq  = ave(1:1309, Ticket,FUN=length),\\n           FareAdj = Fare / TicketFreq,\\n           FamilySize = SibSp + Parch + 1\\n          )           \u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022a46d95bd9107cd2c9576ca39cf7b326c25d1020f\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data2 \u003c- data[data$PassengerId\u003c=891 \u0026 data$Title==\u0027man\u0027,]\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022d2b7046b25a62f0a28f732eeb92272d86bd9fcfc\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data3 \u003c- data.frame(\\n    y = data2$Survived,\\n    x1 = data2$Fare / (data2$TicketFreq * 10),\\n    x2 = (data2$SibSp + data2$Parch + 1) + (data2$Age / 70),\\n    Pclass = data2$Pclass)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00227c23222b6ea3dcd92165b4520d69db0ad707a9d1\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022g1 = ggplot(data[data$FareAdj\u003e0 \u0026 data$FareAdj\u003c40,]) + \\n    geom_density(aes(x=FareAdj,fill=factor(Pclass)),alpha=0.9,show.legend=F) +\\n    labs(fill=\u0027Pclass\u0027) + geom_vline(xintercept=c(10,20),linetype=\u0027dotted\u0027) +\\n    xlim(0,40) + labs(title=\u0027All Passengers\u0027,x=\u0027x1 = Fare / Ticket Frequency\u0027)\\n\\ng2 = ggplot(data[data$Fare\u003e0 \u0026 data$Fare\u003c40 ,]) +\\n    geom_density(aes(x=Fare,fill=factor(Pclass)),alpha=0.9) +\\n    xlim(0,40) + labs(title=\u0027All Passengers\u0027,fill=\u0027Pclass\u0027,y=\u0027\u0027)\\n\\ng3 = ggplot(data[!is.na(data$Survived) \u0026 data$Title==\u0027man\u0027 \u0026 data$Pclass==1 \u0026 data$FamilySize\u003c4,]) + \\n    geom_density(aes(x=FamilySize+Age/70,fill=factor(Survived)),alpha=0.9,bw=0.04) +\\n    labs(fill=\u0027Survived\u0027) +\\n    annotate(\u0027text\u0027,x=1.4,y=2.4,label=\u0027Age 30\\\\nFS=1\u0027) +\\n    annotate(\u0027text\u0027,x=2.4,y=2.4,label=\u0027Age 30\\\\nFS=2\u0027) +\\n    geom_vline(xintercept=c(1.43,2.43),linetype=\u0027dotted\u0027) +\\n    xlim(1,4) + labs(title=\u0027Adult Males Pclass=1\u0027,x=\u0027x2 = FamilySize + Age/70\u0027)\\n\\ngrid.arrange(g3,g1,g2,layout_matrix = rbind(c(1, 1), c(2, 3)))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022dc15771e73f98220774a5d29adc5604f251a5777\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- FamilySize + Age / 70을 작성하면 1 차원에서 SibSp(같이 탑승한 형제 / 배우자 숫자), Parch (같이 탑승한 부모, 자녀의 숫자) 및 Age를 볼 수 있습니다. \\n- 20 세에서 36 세 사이의 Pclass = 1에서 FamilySize \u003c= 2 인 성인 남성이 생존 확률이 50 % 이상임을 보여줍니다. (정확하게, 훈련 세트에서 56 % = 18 / 32 생존). 또한 FamilySize = 2 인 40 대 남성의 경우 생존 확률이 63 % (= 5/8)입니다. \u0027\\n - Fare를 TicketFrequency로 나눕니다. 실제 가격이 지불 되었기 때문입니다. ( 11 명의 세이지 가족은 그들의 11 번째 3 종 티켓 각각에 대해 69.55 달러를 내지 않았다. )\\n\\n- 그들은 $ 6.32 = 69.55 / 11.를 지불했을 것입니다. \\n- 마지막으로, \u0027x1\u0027을 10으로 나누어 스케일이 \u0027x2\u0027의 스케일과 일치하도록 하여 특정 기계학습 알고리즘을 돕습니다. XGBoost를 변수 쌍 (x1, x2)에 적용하고 어떤 패턴을 발견하는지 살펴 보겠습니다.\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00220e98a9609bd97bcd7b0c856f4ddf1274a2192526\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022# classify males with xgboost\\nset.seed(2310)\\n\\nx1s \u003c- seq(0, 5, length.out = 100)\\nx2s \u003c- seq(1, 3, length.out = 100)\\ng \u003c- data.frame(x1 = rep(x1s, each=100), x2 = rep(x2s, time = 100))\\nparam \u003c- list(objective   = \\\u0022binary:logistic\\\u0022,\\n            eval_metric = \\\u0022error\\\u0022,\\n            max_depth   = 5,\\n            eta         = 0.1,\\n            gammma      = 0.1,\\n            colsample_bytree = 1,\\n            min_child_weight = 1)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022550fcb5dc5994f8169b74bb335921b4f4a431b0e\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022param\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022ebe2fde6d9ea0251cf8e9bc75eb08da344c7f015\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022dim(data.matrix(data3[,c(\u0027x1\u0027,\u0027x2\u0027)]))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022d52baa50024986994b8075f5bf23dd91718df135\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022length(data3$y)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002270ea787f5cd0c1e9fea674cdcb2af88598a6e8b4\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022cat(\u0027XGBoosting begun...\\\\n\u0027)\\nxgb \u003c- xgboost(params  = param,\\n            data    = data.matrix(data3[,c(\u0027x1\u0027,\u0027x2\u0027)]),\\n            label   = as.numeric(as.factor(data3$y)) - 1 , \\n            nrounds = 500,\\n            print_every_n = 100,\\n            verbose = 1)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022449e850b5993f348b3233cbd5451ed26c09984a9\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022p \u003c- predict(xgb,newdata=data.matrix(g[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\ng$y \u003c- ifelse(p\u003e0.5,1,0)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022eae9b02512c62df32fcb008fe59023e570938d92\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022head(g)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022049a124e331d654c9283abd227f2df4f6ee8cce9\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022ggplot(data=data3[data3$x1\u003c5 \u0026 data3$x2\u003c3,]) +\\n    xlim(0,5) + ylim(1,3) +\\n    geom_tile(data=g,aes(x1,x2,fill=factor(y))) +\\n    geom_density_2d(aes(x1,x2,color=factor(y))) +\\n    geom_point(size=2,aes(x1,x2,color=factor(y),shape=factor(Pclass))) +\\n    scale_color_manual(values=c(\u0027#AA0000\u0027,\u0027#00AA00\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    scale_fill_manual(values=c(\u0027#FF9999\u0027,\u0027#99FF99\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    labs(x=\u0027Fare / (10 x TicketFrequency)\u0027,y=\u0027FamilySize + (Age / 70)\u0027,shape=\u0027Pclass\u0027,fill=\u0027Classify\u0027,\\n        title=\u0027XGBoost learns the training set\\\\\u0027s\\n        537 adult males. Green is P(live)\u003e0.5\u0027,color=\u0027Survived\u0027) +\\n    geom_vline(xintercept=2.8, linetype=\u0027dotted\u0027) +\\n    geom_hline(yintercept=c(1.43,2.43), linetype=\u0027dotted\u0027) +\\n    annotate(\u0027text\u0027,x=2.95,y=2.9,label=\u0027Fare = $28\u0027) +\\n    annotate(\u0027text\u0027,x=4.7,y=2.35,label=\u0027Age = 30\u0027) +\\n    annotate(\u0027text\u0027,x=4.7,y=1.35,label=\u0027Age = 30\u0027)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022bd3684494c36610f3938364789630f447bc2e5aa\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022 - XGBoost에서 훈련 데이터 세트의 성인 남성 중 생존 패턴을 찾은 것 같습니다! \\n - 도표에서 우리는 생존 가능성이 가장 높은 성인 남성이 Pclass = 1, FareAdj = 28 달러, SibSp + Parch \u003c= 1, Age = 30이라는 것을 알 수 있습니다. 음영은 XGBoost의 분류 결정이 무엇인지 나타냅니다. 녹색 영역은 P (라이브)\u003e 0.5를 예측하는 XGBoost에 해당합니다.\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00223ee8eb7bae87a79ae0a2e5c4406682d8c45c987b\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022set.seed(300)\\ns = sample(1:537,100)\\ns2 = (1:537)[-s]\\nxgb \u003c- xgboost(params  = param,\\n            data    = data.matrix(data3[s2,c(\u0027x1\u0027,\u0027x2\u0027)]),\\n            label   = as.numeric(as.factor(data3$y[s2])) - 1 ,  \\n            nrounds = 500,\\n            print_every_n = 100,\\n            silent = 1,\\n            verbose = 0)\\n\\np \u003c- predict(xgb,newdata=data.matrix(data3[s,c(\u0027x1\u0027,\u0027x2\u0027)]))\\ndata3$y2 \u003c- NA\\nroc = data.frame(TN=rep(0,102),FP=rep(0,102),FN=rep(0,102)\\n    ,TP=rep(0,102),FPR=rep(0,102),TPR=rep(0,102))\\nrownames(roc) \u003c- seq(0,1.01,0.01)\\nfor (i in 1:102){\\n    data3$y2[s] \u003c- ifelse(p\u003c(i-1)/100,0,1)\\n    roc$TP[i] \u003c- length(which(data3$y==1 \u0026 data3$y2==1))\\n    roc$TN[i] \u003c- length(which(data3$y==0 \u0026 data3$y2==0))\\n    roc$FP[i] \u003c- length(which(data3$y==0 \u0026 data3$y2==1))\\n    roc$FN[i] \u003c- length(which(data3$y==1 \u0026 data3$y2==0))\\n    roc$FPR[i] \u003c- roc$FP[i] / (roc$FP[i] + roc$TN[i])\\n    roc$TPR[i] \u003c- roc$TP[i] / (roc$TP[i] + roc$FN[i])\\n}\\ndiag \u003c- data.frame(x=c(0,1),y=c(0,1))\\nggplot(roc,aes(x=FPR,y=TPR)) + \\n    geom_line() + labs(title=\u0027ROC curve where \\\u0022positive\\\u0022 = male survives\u0027,\\n        x=\u0027False positive rate\u0027,y=\u0027True positive rate\u0027) +\\n    geom_point(data=roc[91,],aes(x=FPR,y=TPR),size=3,color=\u0027red\u0027) +\\n    annotate(\u0027text\u0027,x=0.13,y=0.12,label=\u0027threshold p\u003e=0.9\u0027,color=\u0027red\u0027) +\\n    geom_point(data=roc[76,],aes(x=FPR,y=TPR),size=3,color=\u0027darkgreen\u0027) +\\n    annotate(\u0027text\u0027,x=0.16,y=0.30,label=\u0027threshold p\u003e=0.75\u0027,color=\u0027darkgreen\u0027) +\\n    geom_point(data=roc[51,],aes(x=FPR,y=TPR),size=3,color=\u0027blue\u0027) +\\n    annotate(\u0027text\u0027,x=0.20,y=0.5,label=\u0027threshold p\u003e=0.5\u0027,color=\u0027blue\u0027) +\\n    geom_line(data=diag,aes(x=x,y=y),linetype=\u0027dotted\u0027)\\narea = 0\\nfor(i in 1:101){\\n    area = area + roc$TPR[i] * (roc$FPR[i]-roc$FPR[i+1])\\n}\\ncat(sprintf(\u0027Area under ROC = %f\\\\n\u0027,area))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00223345019f7c301ae5ed7cfa7540310ecc524c69a3\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- ROC 아래의 AUC는 0.82\u003e 0.50입니다. (100 회 시행중인 평균 AUC = 0.70) 즉, XGBoost가 생존 패턴을 발견했습니다.\\n- ROC 플롯은 또한 XGBoost가 P (live)\u003e 0.5라고 말할 때마다 생존 할 것으로 예측하면 많은 1종 오류를 만듭니다 (즉, 성인 남성이 생존하지 않을 때 생존하는 것으로 잘못 예측합니다). 정확도를 극대화하기 위해 임계 값을 신중하게 선택해야 하므로 그리드 검색을 사용하여 0.50, 0.75, 0.90 및 0.92 중에서 최상의 임계 값을 찾습니다.\\n\\n\\n## Grid search and cross validate\\n- 그리드 검색을 사용하여 XGBoost에 대한 최적의 매개 변수가 treeDepth = 5, p\u003e = 0.90임을 알 수 있습니다. \\n- 그리드 검색을 수행하려면 아래 코드에서 for 루프의 주석 처리를 제거하고 검색 할 하이퍼 매개 변수를 추가하십시오.이 노트에서는 그리드 검색을 수행하지 않습니다. . 이제 XGBoost가 CV = 78.6 % 인 성별 모델보다 더 정확한지 확인하기 위해 교차 유효성 검사를 수행해 봅시다.\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022d8c6c46d68f88e47351ad0b64c2bdb8686625ba1\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022#accuracy = matrix(nrow=4,ncol=4)\\n#rownames(accuracy) \u003c- c(\u0027d=3\u0027,\u0027d=4\u0027,\u0027d=5\u0027,\u0027d=6\u0027)\\n#colnames(accuracy) \u003c- c(\u00270.50\u0027,\u00270.75\u0027,\u00270.90\u0027,\u00270.92\u0027)\\n#for (j in 1:4)\\n#for (k in 1:4){\\nset.seed(2)\\ntrials=100; sum=0\\nfor (i in 1:trials){\\n    s = sample(1:891,800)\\n    s2 = (1:891)[-s]\\n    dataB \u003c- data[data$PassengerId %in% s \u0026 data$Title==\u0027man\u0027,]\\n    dataC \u003c- data[data$PassengerId %in% s2 \u0026 data$Title==\u0027man\u0027,]\\n    data$Predict \u003c- 0\\n    data$Predict[data$Sex==\u0027female\u0027] \u003c- 1\\n    dataTrain \u003c- data.frame(y=as.numeric(as.factor(dataB$Survived)) - 1,x1=dataB$FareAdj/10,x2=dataB$FamilySize+dataB$Age/70)\\n    dataTest \u003c- data.frame(y=as.numeric(as.factor(dataC$Survived)) - 1,x1=dataC$FareAdj/10\\n        ,x2=dataC$FamilySize+dataC$Age/70,PassengerId=dataC$PassengerId)\\n    param \u003c- list(objective   = \\\u0022binary:logistic\\\u0022,\\n              eval_metric = \\\u0022error\\\u0022,\\n              max_depth   = 5,\\n              eta         = 0.1,\\n              gammma      = 0.1,\\n              colsample_bytree = 1,\\n              min_child_weight = 1)\\n    xgb \u003c- xgboost(params  = param,\\n              data    = data.matrix(dataTrain[,c(\u0027x1\u0027,\u0027x2\u0027)]),\\n              label   = dataTrain$y, \\n              nrounds = 500,\\n              silent = 1,\\n              print_every_n = 100,\\n              verbose = 0)\\n    p \u003c- predict(xgb,newdata=data.matrix(dataTest[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\n    dataTest$p \u003c- ifelse(p\u003e=0.90,1,0)\\n    data$Predict[dataTest$PassengerId] \u003c- dataTest$p \\n    sm = sum(abs(as.integer(data$Predict[s2]) - as.integer(data$Survived[s2])))\\n    cv = 1 - sm/length(s2)\\n    #if (i %% 25==0) \\n    #cat(sprintf(\u0027Trial %d has CV = %f\\\\n\u0027,i,cv))\\n    sum = sum + cv\\n}\\ncat(sprintf(\u0027Average CV of %d trials = %f\\\\n\u0027,trials,sum/trials))\\n#accuracy[j,k] \u003c- sum/trials\\n#}\\n#accuracy\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022699fa387f05fb88dc228bc048f4c40b0450202b3\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- CV 정확도는 79.0 %입니다. (위에 표시된 결과는 k 배 CV의 무작위 특성으로 인해 달라질 수 있지만 오프라인에서는 10,000 회의 평가에서 79.0 %를 확인했습니다.) \\n- 성별 모델의 CV 정확도는 78.6 %이므로 약간 개선되었습니다. 다행히도, 이것은 우리가 테스트 데이터 세트에서 적어도 살아남은 성인 남성 1 명을 발견 할 수있게 해줍니다!\\n\\n\\n## Submission to Kaggle\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022scrolled\u0022:false,\u0022_uuid\u0022:\u0022d5aa5fbf16ce8dfb18aa4a57af50a41d375ca373\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022dataB \u003c- data[data$PassengerId %in% 1:891 \u0026 data$Title==\u0027man\u0027,]\\ndataC \u003c- data[data$PassengerId %in% 892:1309 \u0026 data$Title==\u0027man\u0027,]\\ndata$Predict \u003c- 0\\ndata$Predict[data$Sex==\u0027female\u0027] \u003c- 1\\ndataTrain \u003c- data.frame(y=as.numeric(as.factor(dataB$Survived)) - 1,x1=dataB$FareAdj/10,x2=dataB$FamilySize+dataB$Age/70)\\ndataTest \u003c- data.frame(y=as.numeric(as.factor(dataC$Survived)) - 1,x1=dataC$FareAdj/10,Pclass=dataC$Pclass\\n    ,x2=dataC$FamilySize+dataC$Age/70,PassengerId=dataC$PassengerId)\\n\\nparam \u003c- list(objective   = \\\u0022binary:logistic\\\u0022,\\n              eval_metric = \\\u0022error\\\u0022,\\n              max_depth   = 5,\\n              eta         = 0.1,\\n              gammma      = 0.1,\\n              colsample_bytree = 1,\\n              min_child_weight = 1)\\n\\nxgb \u003c- xgboost(params  = param,\\n              data    = data.matrix(dataTrain[,c(\u0027x1\u0027,\u0027x2\u0027)]),\\n              label   = dataTrain$y, \\n              nrounds = 500,\\n              silent = 1,\\n              print_every_n = 100,\\n              verbose = 0)\\n\\np \u003c- predict(xgb,newdata=data.matrix(dataTest[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\ndataTest$p \u003c- ifelse(p\u003e=0.90,1,0)\\ndata$Predict[dataTest$PassengerId] \u003c- dataTest$p \\nmaleLive = which(data$Title==\u0027man\u0027 \u0026 data$Predict==1)\\ncat(sprintf(\u0027The following %d adult males are predicted to live\\\\n\u0027,length(maleLive)))\\ndata[maleLive,c(\u0027PassengerId\u0027,\u0027Pclass\u0027,\u0027Name\u0027,\u0027Age\u0027,\u0027SibSp\u0027,\u0027Parch\u0027,\u0027FareAdj\u0027)]\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022972c374198100eaab09cab8ac1289f5cfed6714f\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022x1s \u003c- seq(2, 5, length.out = 100)\\nx2s \u003c- seq(1, 3, length.out = 100)\\ng \u003c- data.frame(x1 = rep(x1s, each=100), x2 = rep(x2s, time = 100))\\np \u003c- predict(xgb,newdata=data.matrix(g[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\ng$y \u003c- ifelse(p\u003e=0.90,1,0)\\ng1 \u003c- ggplot(data=dataTest[dataTest$x1\u003e2 \u0026 dataTest$x1\u003c5 \u0026 dataTest$x2\u003e1 \u0026 dataTest$x2\u003c3,]) +\\n    xlim(2,5) + ylim(1,3) +\\n    geom_tile(data=g,aes(x1,x2,fill=factor(y))) +\\n    geom_point(size=2,aes(x1,x2,color=factor(p),shape=factor(Pclass))) +\\n    scale_color_manual(values=c(\u0027#666666\u0027,\u0027#0000FF\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    scale_fill_manual(values=c(\u0027#FF9999\u0027,\u0027#99FF99\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    labs(x=\u0027Fare / (10 x TicketFrequency)\u0027,y=\u0027FamilySize + (Age / 70)\u0027,shape=\u0027Pclass\u0027,fill=\u0027Classifier\u0027,\\n        title=\u0027XGBoost classifies the test set.\\n        It predicts 4 adult males have P(live)\u003e=0.9\u0027,color=\u0027Predict\u0027) +\\n    geom_vline(xintercept=2.8, linetype=\u0027dotted\u0027) +\\n    geom_hline(yintercept=c(1.43,2.43), linetype=\u0027dotted\u0027) +\\n    annotate(\u0027text\u0027,x=2.95,y=2.9,label=\u0027Fare = $28\u0027) +\\n    annotate(\u0027text\u0027,x=4.7,y=2.35,label=\u0027Age = 30\u0027) +\\n    annotate(\u0027text\u0027,x=4.7,y=1.35,label=\u0027Age = 30\u0027)\\n\\nfor (i in which(dataTest$p==1)){\\n    g1 \u003c- g1 + annotate(\u0027text\u0027,x=dataTest$x1[i]-0.15,y=dataTest$x2[i],label=dataTest$PassengerId[i]\\n        ,color=\u0027darkblue\u0027,size=4)\\n}\\ng1\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022d51253343dbdd0e4cf55c6789e4629869e389ebd\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022나머지 예측에서는 다음 두 가지 간단한 규칙 (WCG model, woman-child-groups)을 사용합니다.\\n\\n* 모든 여성과 소년이 살고있는 가정의 모든 소년에 대한 생존율 예측.\\n* 모든 여성과 소년이 사망하는 가정의 모든 여성에 대한 사망 예측.\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022b52547199323effbc4ea8c844da7579d1f8854f0\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022# engineer \\\u0022woman-child-groups\\\u0022\\ndata$Surname = substring( data$Name,0,regexpr(\u0027,\u0027,data$Name)-1)\\ndata$GroupId = paste( data$Surname, data$Pclass, sub(\u0027.$\u0027,\u0027X\u0027,data$Ticket), data$Fare, data$Embarked, sep=\u0027-\u0027)\\ndata$GroupId[data$Title==\u0027man\u0027] \u003c- \u0027noGroup\u0027\\n# Mrs Wilkes (Needs) is Mrs Hocking (Needs) sister\\ndata$GroupId[893] \u003c- data$GroupId[775]\\ndata$GroupFreq \u003c- ave(1:1309,data$GroupId,FUN=length)\\ndata$GroupId[data$GroupFreq\u003c=1] \u003c- \u0027noGroup\u0027\\ncat(sprintf(\u0027We found %d woman-child-groups\\\\n\u0027,length(unique(data$GroupId))-1))\\ndata$TicketId = paste( data$Pclass,sub(\u0027.$\u0027,\u0027X\u0027,data$Ticket),data$Fare,data$Embarked,sep=\u0027-\u0027)\\n# add nannies and relatives to groups\\nc = 0\\nfor (i in which(data$Title!=\u0027man\u0027 \u0026 data$GroupId==\u0027noGroup\u0027)){\\n    data$GroupId[i] = data$GroupId[data$TicketId==data$TicketId[i]][1]\\n    if (data$GroupId[i]!=\u0027noGroup\u0027) c = c + 1\\n}\\ncat(sprintf(\u0027We found %d nannies/relatives and added them to groups.\\\\n\u0027,c))\\n# calculate group survival rates\\ndata$GroupSurvival \u003c- NA\\ndata$Survived \u003c- as.numeric(as.character(data$Survived))\\ndata$GroupSurvival[1:891] \u003c- ave(data$Survived[1:891],data$GroupId[1:891])\\nfor (i in 892:1309) data$GroupSurvival[i] \u003c- data$GroupSurvival[which(data$GroupId==data$GroupId[i])[1]]\\n# classify unknown groups\\ndata$GroupSurvival[is.na(data$GroupSurvival) \u0026 data$Pclass==3] \u003c- 0\\ndata$GroupSurvival[is.na(data$GroupSurvival) \u0026 data$Pclass!=3] \u003c- 1\\n# make predictions\\ndata$Predict \u003c- 0\\ndata$Predict[data$Sex==\u0027female\u0027] \u003c- 1\\ndata$Predict[data$Title==\u0027woman\u0027 \u0026 data$GroupSurvival==0] \u003c- 0\\ndata$Predict[data$Title==\u0027boy\u0027 \u0026 data$GroupSurvival==1] \u003c- 1\\nx = which(data$Sex==\u0027male\u0027 \u0026 data$Predict==1 \u0026 data$PassengerId\u003e891)\\ncat(sprintf(\u0027We found %d boys predicted to live\\\\n\u0027,length(x)))\\nx = which(data$Sex==\u0027female\u0027 \u0026 data$Predict==0 \u0026 data$PassengerId\u003e891)\\ncat(sprintf(\u0027We found %d females predicted to die\\\\n\u0027,length(x)))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022610b70aadbd710768900a2133578c79149a4acb2\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022submit \u003c- data.frame(PassengerId=892:1309,Survived=data$Predict[892:1309])\\nsubmit$Survived[maleLive-891] \u003c- 1\\nwrite.csv(submit,\u0027WCG_XGBoost1.csv\u0027,row.names=F)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002258d691a040537ac7350ced4225aa191d59e03368\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- 성인 남성이 생존할 것으로 예측한 절반이 옳았고 절반은 잘못되었다고 생각됩니다. \\n- WCG 제출과 함께 추가로 4 가지 예언을 통해 WCG 점수가 변경되지는 않았지만 교차 검증을 통해 다음과 같은 결과를 얻을 수 있습니다 . 그러나 우리는 성인 남성 1 ~ 2 명을 발견했습니다.\\n\\n\\n# Explore solo females survival with XGBoost\\n- XGBoost 기술을 솔로 여성에게 적용해 봅시다. 솔로 여성의 생존율을 정확하게 예측할 수 있다면 WCG 모델과 결합하여 가장 정확한 타이타닉 모델을 구할 수 있습니다! \\n- 훈련 데이터 세트에는 304 명의 여성이 포함되어 있습니다. 그 중 108 명이 WCG에, 126 명이 솔로로, 80 명이 동생이나 남편과 함께 여행하며 아이들이 없습니다. 여기에서는 솔로 여성을 탐구 할 것입니다.\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022a13427eb18ee37641580d400b129b310025f9aed\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022# identify WCG females\\nWCGtrain = which(data$Passenger\u003c=891 \u0026 (data$GroupSurvival==0 | data$GroupSurvival==1))\\nWCGtest = which(data$Passenger\u003e891 \u0026 (data$GroupSurvival==0 | data$GroupSurvival==1))\\n# identify solo females\\ndata2 \u003c- data[data$PassengerId\u003c=891 \u0026 data$Title==\u0027woman\u0027 \u0026 data$FamilySize==1,]\\ndata3 \u003c- data.frame(y=data2$Survived,x1=data2$FareAdj/10,x2=data2$Age/15,Pclass=data2$Pclass)\\n# set zoom\\nx1s \u003c- seq(0.5, 1.5, length.out = 100)\\nx2s \u003c- seq(1, 3, length.out = 100)\\ng \u003c- data.frame(x1 = rep(x1s, each=100), x2 = rep(x2s, time = 100))\\n\\ndim(data3)\\nstr(data3)\\n\\n# classify females with XGBoost\\nparam \u003c- list(objective   = \\\u0022binary:logistic\\\u0022,\\n              eval_metric = \\\u0022error\\\u0022,\\n              max_depth   = 5,\\n              eta         = 0.1,\\n              gammma      = 0.1,\\n              colsample_bytree = 1,\\n              min_child_weight = 1)\\ncat(\u0027XGBoosting begun...\\\\n\u0027)\\nxgb \u003c- xgboost(params  = param,\\n               data    = data.matrix(data3[,c(\u0027x1\u0027,\u0027x2\u0027)]),\\n              label   = data3$y, \\n              nrounds = 500,\\n              print_every_n = 100,\\n              verbose = 1)\\np \u003c- predict(xgb,newdata=data.matrix(g[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\ng$y \u003c- ifelse(p\u003c=0.25,0,1)\\n# plot results\\nggplot(data=data3[data3$x1\u003e0.5 \u0026 data3$x1\u003c1.5 \u0026 data3$x2\u003e1 \u0026 data3$x2\u003c3,]) +\\n    xlim(0.5,1.5) + ylim(1,3) +\\n    geom_tile(data=g,aes(x1,x2,fill=factor(y))) +\\n    geom_density_2d(aes(x1,x2,color=factor(y))) +\\n    geom_point(size=2,aes(x1,x2,color=factor(y),shape=factor(Pclass))) +\\n    scale_color_manual(values=c(\u0027#AA0000\u0027,\u0027#00AA00\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    scale_fill_manual(values=c(\u0027#FF9999\u0027,\u0027#99FF99\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    labs(x=\u0027Fare / (10 x TicketFrequency)\u0027,y=\u0027Age / 15\u0027,shape=\u0027Pclass\u0027,fill=\u0027Classify\u0027,\\n        title=\u0027XGBoost learns the training set\\\\\u0027s\\n        126 solo females. Red is P(die)\u003e=0.75\u0027,color=\u0027Survived\u0027) +\\n    geom_vline(xintercept=c(0.8,0.9), linetype=\u0027dotted\u0027) +\\n    annotate(\u0027text\u0027,x=0.77,y=2.95,label=\u0027Fare = $8\u0027) +\\n    annotate(\u0027text\u0027,x=0.93,y=2.95,label=\u0027Fare = $9\u0027) +\\n    geom_hline(yintercept=c(1.33,1.67), linetype=\u0027dotted\u0027) +\\n    annotate(\u0027text\u0027,x=1.35,y=1.61,label=\u0027Age = 25\u0027) +\\n    annotate(\u0027text\u0027,x=1.35,y=1.28,label=\u0027Age = 20\u0027)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00227fb48b4a812bcceff3148760ffdbc3d149e6425f\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- XGBoost에서 훈련 데이터 세트의 솔로 여성 중 생존 패턴을 찾은 것 같습니다! \\n- 위의 그림에서 가장 유망한 솔로 여성은 Pclass = 3, FareAdj = 9, Age = 22입니다. 또는 Pclass = 3, FareAdj = 8, Age = 34입니다. 음영은 XGBoost의 분류 결정은 있습니다. 빨간색 영역은 P(die)\u003e 0.75를 예측하는 XGBoost에 해당합니다.\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00227eb6934e513bdb26148dc579531fc8f76bee9f1c\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022## Grid search and cross validation\\n- 그리드 검색을 사용하여 XGBoost에 대한 최적의 매개 변수가 treeDepth = 5, p \u003c= 0.08임을 알 수 있습니다. 그리드 검색을 수행하려면 아래 코드에서 for 루프의 주석 처리를 제거하고 검색 할 하이퍼 매개 변수를 추가하십시오.이 노트에서는 그리드 검색을 수행하지 않습니다. 이제 XGBoost가 CV = 78.6 % 인 성별 모델보다 더 정확한지 확인하기 위해 교차 유효성 검사를 수행해 봅시다.\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00224fab6ee6b21cf70b2b53ea6f0d3b756ba6739022\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022#accuracy = matrix(nrow=4,ncol=4)\\n#rownames(accuracy) \u003c- c(\u0027d=3\u0027,\u0027d=4\u0027,\u0027d=5\u0027,\u0027d=6\u0027)\\n#colnames(accuracy) \u003c- c(\u00270.08\u0027,\u00270.10\u0027,\u00270.25\u0027,\u00270.50\u0027)\\n#for (j in 1:4)\\n#for (k in 1:4){\\ntrials=100; sum=0\\nfor (i in 1:trials){\\n    s = sample(1:891,800)\\n    s2 = (1:891)[-s]\\n    dataB \u003c- data[data$PassengerId %in% s \u0026 data$Title==\u0027woman\u0027 \u0026 data$FamilySize==1,]\\n    dataC \u003c- data[data$PassengerId %in% s2 \u0026 data$Title==\u0027woman\u0027\u0026 data$FamilySize==1,]\\n    data$Predict \u003c- 0\\n    data$Predict[data$Sex==\u0027female\u0027] \u003c- 1\\n    dataTrain \u003c- data.frame(y=dataB$Survived,x1=dataB$FareAdj/10,x2=dataB$Age/15)\\n    dataTest \u003c- data.frame(y=dataC$Survived,x1=dataC$FareAdj/10\\n        ,x2=dataC$Age/15,PassengerId=dataC$PassengerId)\\n    param \u003c- list(objective   = \\\u0022binary:logistic\\\u0022,\\n              eval_metric = \\\u0022error\\\u0022,\\n              max_depth   = 5,\\n              eta         = 0.1,\\n              gammma      = 0.1,\\n              colsample_bytree = 1,\\n              min_child_weight = 1)\\n    xgb \u003c- xgboost(params  = param,\\n              data    = data.matrix(dataTrain[,c(\u0027x1\u0027,\u0027x2\u0027)]),\\n              label   = dataTrain$y, \\n              nrounds = 500,\\n              silent = 1,\\n              print_every_n = 100,\\n              verbose = 0)\\n    p \u003c- predict(xgb,newdata=data.matrix(dataTest[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\n    dataTest$p \u003c- ifelse(p\u003c=0.08,0,1)\\n    data$Predict[dataTest$PassengerId] \u003c- dataTest$p \\n    sm = sum(abs(data$Predict[s2] - data$Survived[s2]))\\n    cv = 1 - sm/length(s2)\\n    #if (i %% 25==0) \\n    #cat(sprintf(\u0027Trial %d has CV = %f\\\\n\u0027,i,cv))\\n    sum = sum + cv\\n}\\ncat(sprintf(\u0027Average CV of %d trials = %f\\\\n\u0027,trials,sum/trials))\\n#accuracy[j,k] \u003c- sum/trials\\n#}\\n#accuracy\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022ccf503c30530b6fbc6bf74b0698e9ee91918205a\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- CV 정확도는 79.0 %입니다. (위에 표시된 결과는 k 배 CV의 무작위 특성으로 인해 달라질 수 있지만 오프라인에서는 10,000 회의 평가에서 79.0 %를 확인했습니다.) 성별 모델의 CV 정확도는 78.6 %이므로 약간 개선되었습니다. 바라건대, 우리는 공개 점수에도 약간의 개선을 이룰 수 있습니다. 어디 보자.\\n\\n\\n## Submission to Kaggle\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022111b732164fb2b525ed1b2788ab69438815ccce0\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022dataB \u003c- data[data$PassengerId %in% 1:891 \u0026 data$Title==\u0027woman\u0027 \u0026 data$FamilySize==1,]\\ndataC \u003c- data[data$PassengerId %in% 892:1309 \u0026 data$Title==\u0027woman\u0027 \u0026 data$FamilySize==1 \\n    \u0026 !data$PassengerId %in% WCGtest,]\\ndata$Predict \u003c- 0\\ndata$Predict[data$Sex==\u0027female\u0027] \u003c- 1\\ndataTrain \u003c- data.frame(y=dataB$Survived,x1=dataB$FareAdj/10,x2=dataB$Age/15)\\ndataTest \u003c- data.frame(y=dataC$Survived,x1=dataC$FareAdj/10\\n    ,x2=dataC$Age/15,PassengerId=dataC$PassengerId,Pclass=dataC$Pclass)\\nparam \u003c- list(objective   = \\\u0022binary:logistic\\\u0022,\\n              eval_metric = \\\u0022error\\\u0022,\\n              max_depth   = 5,\\n              eta         = 0.1,\\n              gammma      = 0.1,\\n              colsample_bytree = 1,\\n              min_child_weight = 1)\\nxgb \u003c- xgboost(params  = param,\\n              data    = data.matrix(dataTrain[,c(\u0027x1\u0027,\u0027x2\u0027)]),\\n              label   = dataTrain$y, \\n              nrounds = 500,\\n              silent = 1,\\n              print_every_n = 100,\\n              verbose = 0)\\np \u003c- predict(xgb,newdata=data.matrix(dataTest[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\ndataTest$p \u003c- ifelse(p\u003c=0.08,0,1)\\ndata$Predict[dataTest$PassengerId] \u003c- dataTest$p \\nfemalePerish = which(data$Title==\u0027woman\u0027 \u0026 data$Predict==0)\\ncat(sprintf(\u0027The following %d females are predicted to die\\\\n\u0027,length(femalePerish)))\\ndata[femalePerish,c(\u0027PassengerId\u0027,\u0027Pclass\u0027,\u0027Name\u0027,\u0027Age\u0027,\u0027SibSp\u0027,\u0027Parch\u0027,\u0027FareAdj\u0027)]\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00223508715bb323bac2a811f0e656b0e5d1972ff98a\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022x1s \u003c- seq(0.6, 1, length.out = 100)\\nx2s \u003c- seq(1, 3, length.out = 100)\\ng \u003c- data.frame(x1 = rep(x1s, each=100), x2 = rep(x2s, time = 100))\\np \u003c- predict(xgb,newdata=data.matrix(g[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\ng$y \u003c- ifelse(p\u003c=0.08,0,1)\\ng1 \u003c- ggplot(data=dataTest[dataTest$x1\u003c1 \u0026 dataTest$x2\u003c3,]) +\\n    xlim(0.6,1) + ylim(1,3) +\\n    geom_tile(data=g,aes(x1,x2,fill=factor(y))) +\\n    geom_point(size=2,aes(x1,x2,color=factor(p),shape=factor(Pclass))) +\\n    scale_color_manual(values=c(\u0027#0000FF\u0027,\u0027#666666\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    scale_fill_manual(values=c(\u0027#FF9999\u0027,\u0027#99FF99\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    labs(x=\u0027Fare / (10 x TicketFrequency)\u0027,y=\u0027Age / 15\u0027,shape=\u0027Pclass\u0027,fill=\u0027Classifier\u0027,\\n        title=\u0027XGBoost classifies the test set.\\n        It predicts 10 non-WCG females have P(die)\u003e=0.92\u0027,color=\u0027Predict\u0027) +\\n    geom_vline(xintercept=c(0.8,0.9), linetype=\u0027dotted\u0027) +\\n    geom_hline(yintercept=c(1.33,1.67), linetype=\u0027dotted\u0027) +\\n    annotate(\u0027text\u0027,x=0.8,y=2.95,label=\u0027Fare = $8\u0027) +\\n    annotate(\u0027text\u0027,x=0.9,y=2.95,label=\u0027Fare = $9\u0027) +\\n    annotate(\u0027text\u0027,x=0.65,y=1.61,label=\u0027Age = 25\u0027) +\\n    annotate(\u0027text\u0027,x=0.65,y=1.28,label=\u0027Age = 20\u0027)\\n# plot passenger numbers\\nv = c(0.07,0.02,0.02,0.02,-0.04,0.02,0.02,0.02,0.02,0.02); c = 0\\nfor (i in which(dataTest$p==0)){\\n    c = c + 1;\\n    g1 \u003c- g1 + annotate(\u0027text\u0027,x=dataTest$x1[i]+0.015,y=dataTest$x2[i]+v[c],label=dataTest$PassengerId[i]\\n        ,color=\u0027darkblue\u0027,size=3)\\n}\\ng1\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00229f3beb2366557e7e3f15a40529a98e016677da30\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022submit$Survived[femalePerish-891] \u003c- 0\\nwrite.csv(submit,\u0027WCG_XGBoost2.csv\u0027,row.names=F)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00225b1e323c6ceadce25dbacfb4924eb4e6ab69ead3\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022![result-female](http://playagricola.com/Kaggle/surnameModel5.png)\\n\\n- 굉장해! 대부분의 여성들의 예측이 옳았다. 우리 점수는 83.3 %에서 84.7 %로 증가했습니다 !! 이것은 우리의 10 가지 여성 예측 중 80 %가 정확하고 좋았음을 의미합니다. 와우, 우리는 이제까지 가장 정확한 타이탄 모델을 가지고 있습니다!\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022813546fa6fef9686024c8faa82e4b594bffa30ca\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022## Comparison with CART, kNN, SVM, Random Forest\\n\\n- 아래는 Pclass = 3 (60 명의 여성)으로 제한된 솔로 여성을 다양한 방법으로 분류하는 방법을 보여줍니다. CART, kNN 및 SVM 교차 검증은 78.9 % 및 랜덤포레스트 78.7 %입니다. \\n- 네 가지 모델은 WCG에서 16, 16, 6,  9 솔로 여성에 대해서 예측을 변경하고 83.8 %, 83.3 %, 83.3 % 및 84.2 %의 점수를 각각 획득합니다. (WCG는 그 자체로 83.3 %를 얻습니다.) \\n- Random Forest에 의해 생성 된 영역은 위의 XGBoost와 가장 유사합니다. 그리고 가장 비슷한 점수를 얻습니다. CART는 매우 읽기 쉽기 때문에 좋습니다. CART는 P class = 3의 솔로 여학생이 FareAdj \u003e $8 or Age \u003e 25 로 사망한다고 말합니다. 이 패턴은 학습 데이터 세트에 있습니다. 이 조건들을 충만한 22 명의 여성 중 64 % = 14/22 명이 사망합니다.\\n\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002298c26b4f688106d323285ff411723ed1ee1e8ff2\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022g = list(); gp = list()\\ngt = c(\u0027CART learns the training set\u0027,\u0027kNN k=5 learns the training set\u0027\\n       ,\u0027SVM with radial kernel\u0027,\u0027Random Forest with P(die)\u003e0.75\u0027)\\ndata2 \u003c- data[data$PassengerId\u003c=891 \u0026 data$Title==\u0027woman\u0027 \u0026 data$FamilySize==1 \u0026 data$Pclass==3,]\\ndata3 \u003c- data.frame(y=data2$Survived,x1=data2$FareAdj/10,x2=data2$Age/15)\\n# set zoom\\nx1s \u003c- seq(0.6, 1, length.out = 50)\\nx2s \u003c- seq(1, 3, length.out = 50)\\nfor (i in 1:4){\\n    g[[i]] \u003c- data.frame(x1 = rep(x1s, each=100), x2 = rep(x2s, time = 100))\\n    if (i==1){\\n        fit \u003c- rpart(factor(y) ~ x1 + x2,data3)\\n        p \u003c- predict(fit,newdata=g[[i]])[,2]\\n        g[[i]]$y \u003c- ifelse(p\u003c=0.5,0,1)\\n    } else if (i==2){\\n        fit \u003c- knn3(factor(y) ~ x1 + x2,data3,k=3)\\n        p \u003c- predict(fit,newdata=g[[i]])[,2]\\n        g[[i]]$y \u003c- ifelse(p\u003c=0.5,0,1)\\n    } else if (i==3){\\n        fit \u003c- svm(factor(y)~ x1 + x2,data3,kernel=\u0027radial\u0027)\\n        p \u003c- predict(fit,newdata=g[[i]])\\n        g[[i]]$y \u003c- as.numeric(as.character(p))\\n    } else if (i==4){\\n        fit \u003c- randomForest(factor(y) ~ x1 + x2,data3)\\n        p \u003c- predict(fit,newdata=g[[i]],type=\u0027prob\u0027)[,2]\\n        g[[i]]$y \u003c- ifelse(p\u003c=0.25,0,1)\\n    }\\n    # plot results\\n    gp[[i]] \u003c- ggplot(data=data3[data3$x1\u003e0.6 \u0026 data3$x1\u003c1 \u0026 data3$x2\u003e1 \u0026 data3$x2\u003c3,]) +\\n        xlim(0.6,1) + ylim(1,3) +\\n        geom_tile(data=g[[i]],aes(x1,x2,fill=factor(y)),show.legend=F) +\\n        geom_point(size=1.5,aes(x1,x2,color=factor(y)),show.legend=F) +\\n        scale_color_manual(values=c(\u0027#AA0000\u0027,\u0027#00AA00\u0027),\\n            limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n        scale_fill_manual(values=c(\u0027#FF9999\u0027,\u0027#99FF99\u0027),\\n            limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n        #labs(x=\u0027Fare / (10 x TicketFrequency)\u0027,y=\u0027Age / 15\u0027,fill=\u0027Classify\u0027,\\n        labs(x=\u0027\u0027,y=\u0027\u0027,title=gt[i],color=\u0027Survived\u0027) +\\n        geom_vline(xintercept=c(0.8,0.9), linetype=\u0027dotted\u0027) +\\n        geom_hline(yintercept=c(1.33,1.67), linetype=\u0027dotted\u0027)\\n}\\ngrid.arrange(gp[[1]],gp[[2]],gp[[3]],gp[[4]],nrow=2)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022bc9d7c9a5aba8ee3931ac68dcc13322359bde0ca\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022# Conclusion\\n\\n- 해당 튜토리얼 노트는 성인 남성의 생존을 예측하는 것이 매우 어렵다는 것을 보여주었습니다. \\n- 위의 분석에서, 훈련 데이터에서 성인 남성 생존 패턴이 있는 것으로 보인다. 그러나 이러한 패턴은 테스트 데이터 집합으로 이어지지는 않습니다. \\n    - 저는 성인 남성이 Pclass, Age, Family Size 및 Fare만으로도 생존 할 수 있다고 예측할 수는 없다고 생각합니다. 훈련 세트가 당신을 속일 수 있다고 생각하게 만듭니다. 남성의 생존을 예측하려면 기능을 설계해야 합니다.\\n\\n- 여성에 관해서는 예측이 더 성공적입니다. WCG 모델 자체만으로도 많은 여성들을 발견되지만,해당 커널은 non-WCG 여성들간에 여전히 패턴이 있음을 보여줍니다. \\n    - 예를 들어, 훈련 세트에는 Pclass = 3 인 6 명의 독신 여행 여성이 있고, $ 8 ~ $ 9 사이의 FareAdj, 20 ~ 25 세의 여성이 있습니다.이 여성 6 명 모두 사망했습니다. 그게 하나의 패턴입니다. \\n    - Pclass, Age, Family Size 및 Fare를 사용하여 우리는 여성 모델이 성공할 것이라고 예측할 수 있다는 것을 보여주었습니다. 우리는 또한 FareAdj가 8 세 근처에 있고 34 세 근처에있는 여성이 멸망 할 가능성이 있음을 발견했습니다.\\n\\n- 우리는 85 %보다 잘 할 수 있습니까? WCG 모델은 84.4 %의 CV와 83.3 %의 점수를 견고하게 달성 할 수 있습니다. 이 커널은 데이터에 더 많은 패턴이 있고 Mega Model의 앙상블이 데이터에 더 많은 패턴이 있음을 보여 줬습니다. 여기 XGBoost가 메가 모델의 앙상블보다 다른 여성을 찾았다는 것은 고무적입니다. \\n    - 이는 단일 모델이 아직 모든 non WCG 여성을 분류하지 못했다는 것을 의미합니다. 모든 사람들이 WCG가 아닌 승객을 위해 분류기를 직접 만들어이 커널을 포크하고 개선 할 것을 권장합니다. (참고 :이 커널을 포크하는 경우 설정에서 GPU를 켜십시오)\\n\\nXGBoost에 대해 더 자세히 알고 싶다면 Tae Hyon Whang의 XGBoost, 173/209 LB가있는 Titanic Starter라고 불리는 위대한 Python 커널을 확인하십시오.\\nTo learn more about XGBoost, check out [Tae Hyon Whang\u0027s][1] great Python kernel called [Titanic Starter with XGBoost, 173/209 LB][2].  \\n  \\n[1]:https://www.kaggle.com/numbersareuseful\\n[2]:https://www.kaggle.com/numbersareuseful/titanic-starter-with-xgboost-173-209-lb\\n\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002214d091833121a4d676b3d5d0ba42ab0eb2148eec\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022# Summary of Titanic models\\n Here\u0027s a review of this notebook and my previous two. First the population was divided into 5 groups:  \\n* (A) Males adults - 61% of population  \\n* (B) Males boys (Master title) - 5% of population  \\n* (C) Females that have children, sisters, or mothers (brothers, husbands optional) - 12%\\n* (D) Females that have brothers, or husbands (no children, no sisters, no mothers) - 8%  \\n* (E) Females traveling alone - 14% of population  \\n  \\nNext we built 3 classifiers:    \\n* (1) [WCG classifies B+C][1]  \\n* (2) [Ensemble of top 5 Kaggle classifies A+D+E][1]  \\n* (3) [XGBoost classifies E][2]  \\n  \\nFinally we assembled 4 models. Here are cross validations and public scores:  \\n* WCG + GenderModel = 84.4% CV and 83.3% PS  \\n* WCG + Ensemble = unknown CV and 84.2% PS  \\n* WCG + XGBoost + GenderModel = 85.2% CV and 84.7% PS  \\n* WCG + XGBoost + Ensemble = unknown CV and 85.2% PS  \\n\\nThank you for reading my notebook #3! I hope you enjoyed it. Check out notebooks [#1][3] and [#2][1]. Feel free to use my classifiers, improve them, add your own, and assemble new models. I believe it is possible to increase CV and PS above 85%. Good luck! (_NOTE: if you fork this kernel, turn on GPU under settings_)  \\n  \\n[1]:https://www.kaggle.com/cdeotte/titantic-mega-model-0-84210\\n[2]:https://www.kaggle.com/cdeotte/titanic-wcg-xgboost-0-84688\\n[3]:https://www.kaggle.com/cdeotte/titanic-using-name-only-0-81818\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00226af53ed5b639b9e8c6ed594f34de1e78219d363b\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022![hist](http://playagricola.com/Kaggle/histXGB.png)\u0022}],\u0022metadata\u0022:{\u0022kernelspec\u0022:{\u0022display_name\u0022:\u0022R\u0022,\u0022language\u0022:\u0022R\u0022,\u0022name\u0022:\u0022ir\u0022},\u0022language_info\u0022:{\u0022mimetype\u0022:\u0022text/x-r-source\u0022,\u0022name\u0022:\u0022R\u0022,\u0022pygments_lexer\u0022:\u0022r\u0022,\u0022version\u0022:\u00223.4.2\u0022,\u0022file_extension\u0022:\u0022.r\u0022,\u0022codemirror_mode\u0022:\u0022r\u0022}},\u0022nbformat\u0022:4,\u0022nbformat_minor\u0022:1}","dateCreated":"2018-11-22T03:40:53.3335614Z"},"kernelRun":{"id":7632756,"kernelId":2141451,"status":"complete","type":"batch","sourceType":"notebook","language":"r","title":"Jetbrain Day Kr 2018 - Titanic Prediction","dateCreated":"2018-11-22T03:40:53.52Z","dateEvaluated":"2018-11-22T03:40:54.73Z","workerContainerPort":null,"workerUptimeSeconds":17176,"workerIPAddress":"172.16.18.39   ","scriptLanguageId":12,"scriptLanguageName":"R Notebook HTML","renderedOutputUrl":"https://www.kaggleusercontent.com/kf/7632756/eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..kKbVT1mQrRCSisxHcXFZSg.pUUyYYii43NH0MZwQcNsIJhWKb8vC9rbO1vA2ZSCre_aN7w4FtxIquDGTJZYinug3gA9Dfop2D1xQcjzjmC3-RyayD_nCdg-bSq3Xg6Lw1dnhPj0PLEMuZ74T8CDZQQNjYBeoqyfblfpMdbRqDRZNsO3XLc3IQjR3gi409GAEs8.OClwS0y-oDBrjPjT_C9eiw/__results__.html","commit":{"id":112457325,"settings":{"dockerImageVersionId":null,"dataSources":[{"sourceType":"DatasetVersion","sourceId":38352,"databundleVersionId":null},{"sourceType":"Competition","sourceId":3136,"databundleVersionId":null},{"sourceType":"DatasetVersion","sourceId":184856,"databundleVersionId":null}],"sourceType":"notebook","language":"r","isGpuEnabled":true,"isInternetEnabled":false},"source":"{\u0022cells\u0022:[{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00228f2839f25d086af736a60e9eeb907d3b93b6e0e5\u0022,\u0022_cell_guid\u0022:\u0022b1076dfc-b9ad-4769-8c92-a6c4dae69d19\u0022,\u0022trusted\u0022:true,\u0022collapsed\u0022:true},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022# Jetbrain Day Kr 2018 - Titanic Prediction (XGBoost will tell us!)\\n\\nThanks, Chris Deotte, Hitesh palamada 감사합니다. \\n해당 커널 작성한 [Chris Deotte](https://www.kaggle.com/cdeotte), [Hitesh palamada](https://www.kaggle.com/hiteshp) 덕분에 Jetbrain day KR 2018 캐글뽀개기 튜토리얼을 진행할 수 있었습니다. \\n\\n이번 커널은 다음의 3개 커널을 주로 참고 했습니다.\\n\\n\\n[Titantic Mega Model- 0.84210](https://www.kaggle.com/cdeotte/titantic-mega-model-0-84210)\\n\\n[Titanic WCG+XGBoost - 0.84688](https://www.kaggle.com/cdeotte/titanic-wcg-xgboost-0-84688)\\n\\n[Head Start for Data Scientist](https://www.kaggle.com/hiteshp/head-start-for-data-scientist)\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00221d514552aeee76efc362f6873e775beceacb2d45\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002208552a67026efa5adbaa7440da7278adeea51bcb\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022## Titanic Tutorial (Head Start for Data Scientist)\\n-  [Head Start for Data Scientist](https://www.kaggle.com/hiteshp/head-start-for-data-scientist)\\n\\n-  1912 년 4 월 14 일 타이타닉 호는 거대한 빙산을 쳤고 승객과 승무원의 약 1,500 명을 대서양의 얼음 깊이 아래로 데려갔습니다. \\n- 바다에서의 최악의 재해 중 하나인 타이타닉은 비극적인 사건으로 인해 그러한 재앙이 다시 발생하는 것을 방지하기 위한 수많은 안전 규정과 정책이 만들어졌습니다. \\n- 그러나 일부 비평가들은 운이 아닌 다른 상황으로 인해 사망자 수가 불균형을 빚었다고 주장합니다. 이 분석의 목적은 사람의 생존 가능성에 영향을 미치는 요소를 탐색하는 것\\n\\n**#### Import library’s, data\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022e8bad8c98efaa8457173764e6e3a4e66175536d9\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022pacman::p_load(rpart, tidyverse, gridExtra, xgboost, forcats, stringr, caTools, DT, data.table, pander, scales, grid, corrplot, VIM, knitr, vcd, caret, MLmetrics, randomForest, \\n              rpart.plot, car, e1071, ROCR, pROC, glmnet)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00226be880e4ecfdfb102745fbdf2a03fa0520f31232\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022getwd()\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022350667365af855603274846259e1a6b699d31521\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022list.files(\u0027../input/\u0027)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_cell_guid\u0022:\u002279c7e3d0-c299-4dcb-8224-4455121ee9b0\u0022,\u0022_uuid\u0022:\u0022d629ff2d2480ee46fbb7e2d37f6b5fab8052498a\u0022,\u0022trusted\u0022:true,\u0022_kg_hide-input\u0022:true},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022train \u003c- read_csv(file = \u0027../input/titanic/train.csv\u0027)\\ntest \u003c- read_csv(file = \u0027../input/titanic/test.csv\u0027)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00228f7a7251c6dfd5c7865da439d418f6e21093513a\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022| Variable  | Definition | key |\\n| :------------ | :-----------: | :-----------: |\\n| survival | 생존 유무 | 0  = No, 1 = Yes |\\n| pclass | 티켓 클래스 | 1 = 1st, 2 = 2nd, 3 = 3rd |\\n| sex | 성별 ||\\n| Age | 나이 ||\\n| sibsp | 형제 \u0026 배우자 숫자||\\n| parch | 부모님 \u0026 아이들 숫자 ||\\n| ticket | 티켓 번호 ||\\n| fare | 요금 ||\\n| cabin | 객실 번호 ||\\n| embarked | 승선항 |C = Cherbourg, Q = Queenstown, S = Southampton|\\n\\n\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002289fc5efd2b3f45d8a6399446a7154c7950549494\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022train$set \u003c- \\\u0022train\\\u0022\\ntest$set  \u003c- \\\u0022test\\\u0022\\ntest$Survived \u003c- NA\\nfull \u003c- rbind(train, test)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022eef45397c1eef5393c9ee61affa45b3d8489a323\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022str(full)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022c8c046423039ea4ddf462cf272356af851eebaea\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022glimpse(full)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022eda296301c7fbd68ada0b54bdfd98d71162278b5\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022summary(full)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00221ed9076b4e20eda971a8156bde81ddaa4062d04a\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022str(test)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022b017994adde5c138ad2eb11d4d70c9b81f21f477\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022dim(full)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022ea066312de060e1ad8f4b830ef152c9cec59617b\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022# Unique values per column\\nsapply(full, function(x) length(unique(x)))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002298b7c463fc4a5e09cf4950a603d8e9fc9913b21b\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022#Check for Missing values\\nmissing_values \u003c- full %\u003e% summarize_all(funs(sum(is.na(.))/n()))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002297733d6ac3e3dd9114cf8f4c5e8349174ce2cd30\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022missing_values \u003c- gather(missing_values, key=\\\u0022feature\\\u0022, value=\\\u0022missing_pct\\\u0022)\\nmissing_values %\u003e% \\n  ggplot(aes(x=reorder(feature,missing_pct),y=missing_pct)) +\\n  geom_bar(stat=\\\u0022identity\\\u0022,fill=\\\u0022red\\\u0022)+\\n  coord_flip()+theme_bw()\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00222e1d120d46ddd4b98e9a5af2291ecd65bd3dd454\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022checkColumn = function(df,colname){\\n  testData = df[[colname]]\\n  numMissing = max(sum(is.na(testData)|is.nan(testData)|testData==\u0027\u0027),0)\\n  if (class(testData) == \u0027numeric\u0027 | class(testData) == \u0027Date\u0027 | class(testData) == \u0027difftime\u0027 | class(testData) == \u0027integer\u0027){\\n    list(\u0027col\u0027 = colname,\u0027class\u0027 = class(testData), \u0027num\u0027 = length(testData) - numMissing, \u0027numMissing\u0027 = numMissing, \u0027numInfinite\u0027 = sum(is.infinite(testData)), \u0027avgVal\u0027 = mean(testData,na.rm=TRUE), \u0027minVal\u0027 = round(min(testData,na.rm = TRUE)), \u0027maxVal\u0027 = round(max(testData,na.rm = TRUE)))\\n  } else{\\n    list(\u0027col\u0027 = colname,\u0027class\u0027 = class(testData), \u0027num\u0027 = length(testData) - numMissing, \u0027numMissing\u0027 = numMissing, \u0027numInfinite\u0027 = NA,  \u0027avgVal\u0027 = NA, \u0027minVal\u0027 = NA, \u0027maxVal\u0027 = NA)\\n  }\\n}\\n\\ncheckAllCols = function(df){\\n  resDF = data.frame()\\n  for (colName in names(df)){\\n    resDF = rbind(resDF,as.data.frame(checkColumn(df=df,colname=colName)))\\n  }\\n  resDF\\n}\\n\\ncheckAllCols(full)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022a68938ab26725a566bd9cb05c988bb2e688422cd\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022miss_pct \u003c- map_dbl(full, function(x) { round((sum(is.na(x)) / length(x)) * 100, 1) })\\nmiss_pct \u003c- miss_pct[miss_pct \u003e 0]\\n\\ndata.frame(miss=miss_pct, var=names(miss_pct), row.names=NULL) %\u003e%\\n    ggplot(aes(x=reorder(var, miss), y=miss)) + \\n    geom_bar(stat=\u0027identity\u0027, fill=\u0027red\u0027) +\\n    labs(x=\u0027\u0027, y=\u0027% missing\u0027, title=\u0027Percent missing data by feature\u0027) +\\n    theme(axis.text.x=element_text(angle=90, hjust=1))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022c5602ae10d5ce0345dfbe57406f34d2943306548\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022full \u003c- full %\u003e%\\n    mutate(\\n      Age = ifelse(is.na(Age), mean(full$Age, na.rm=TRUE), Age),\\n      `Age Group` = case_when(Age \u003c 13 ~ \\\u0022Age.0012\\\u0022, \\n                                 Age \u003e= 13 \u0026 Age \u003c 18 ~ \\\u0022Age.1317\\\u0022,\\n                                 Age \u003e= 18 \u0026 Age \u003c 60 ~ \\\u0022Age.1859\\\u0022,\\n                                 Age \u003e= 60 ~ \\\u0022Age.60Ov\\\u0022))\\n\\ntable(full$`Age Group`)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022040f0ce215182b6f918d297b625f4e729dbeda32\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022full$Embarked \u003c- replace(full$Embarked, which(is.na(full$Embarked)), \u0027S\u0027)\\ntable(full$Embarked)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00225162b7a8bb31d3913bb3ac9711c9a6a32f31637f\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022names \u003c- full$Name\\ntitle \u003c-  gsub(\\\u0022^.*, (.*?)\\\\\\\\..*$\\\u0022, \\\u0022\\\\\\\\1\\\u0022, names)\\nfull$title \u003c- title\\ntable(title)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022bbc6c20e6c4c50e46b61f3a28e7d90e7a871ce90\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022### MISS, Mrs, Master and Mr은 더 많은 숫자를 사용하고 있습니다.\\n### 성별과 생존율을 확인하여 다른 과목을 더 큰 바구니에 그룹화하는 것이 더 좋음\\n\\nfull$title[full$title == \u0027Mlle\u0027]        \u003c- \u0027Miss\u0027 \\nfull$title[full$title == \u0027Ms\u0027]          \u003c- \u0027Miss\u0027\\nfull$title[full$title == \u0027Mme\u0027]         \u003c- \u0027Mrs\u0027 \\nfull$title[full$title == \u0027Lady\u0027]          \u003c- \u0027Miss\u0027\\nfull$title[full$title == \u0027Dona\u0027]          \u003c- \u0027Miss\u0027\\n\\n# 나는 작은 데이터로 새로운 변수를 생성하는 것이 overfit을 야기 할 수 있다고 생각한다.\\n\\nfull$title[full$title == \u0027Capt\u0027]        \u003c- \u0027Officer\u0027 \\nfull$title[full$title == \u0027Col\u0027]        \u003c- \u0027Officer\u0027 \\nfull$title[full$title == \u0027Major\u0027]   \u003c- \u0027Officer\u0027\\nfull$title[full$title == \u0027Dr\u0027]   \u003c- \u0027Officer\u0027\\nfull$title[full$title == \u0027Rev\u0027]   \u003c- \u0027Officer\u0027\\nfull$title[full$title == \u0027Don\u0027]   \u003c- \u0027Officer\u0027\\nfull$title[full$title == \u0027Sir\u0027]   \u003c- \u0027Officer\u0027\\nfull$title[full$title == \u0027the Countess\u0027]   \u003c- \u0027Officer\u0027\\nfull$title[full$title == \u0027Jonkheer\u0027]   \u003c- \u0027Officer\u0027  \u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00227554fcdb477bd2d49b810e6c5dbab5d6b1d38d21\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022table(full$title)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00225e0ee917fe85c1aa9edbd940dfecb717b6510003\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022full$FamilySize \u003c-full$SibSp + full$Parch + 1 \\nfull$FamilySized[full$FamilySize == 1] \u003c- \u0027Single\u0027 \\nfull$FamilySized[full$FamilySize \u003c 5 \u0026 full$FamilySize \u003e= 2] \u003c- \u0027Small\u0027 \\nfull$FamilySized[full$FamilySize \u003e= 5] \u003c- \u0027Big\u0027 \\nfull$FamilySized=as.factor(full$FamilySized)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022f1a2135efbac75447041ca9e2667b86f8badc6a0\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022plot(full$FamilySized)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022514b8ffb9a8b474cc06c9c9c535ba62dfcf07275\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022##Engineer features based on all the passengers with the same ticket\\nticket.unique \u003c- rep(0, nrow(full))\\ntickets \u003c- unique(full$Ticket)\\n\\nfor (i in 1:length(tickets)) {\\n  current.ticket \u003c- tickets[i]\\n  party.indexes \u003c- which(full$Ticket == current.ticket)\\n  for (k in 1:length(party.indexes)) {\\n    ticket.unique[party.indexes[k]] \u003c- length(party.indexes)\\n  }\\n}\\n\\nfull$ticket.unique \u003c- ticket.unique\\nfull$ticket.size[full$ticket.unique == 1]   \u003c- \u0027Single\u0027\\nfull$ticket.size[full$ticket.unique \u003c 5 \u0026 full$ticket.unique\u003e= 2]   \u003c- \u0027Small\u0027\\nfull$ticket.size[full$ticket.unique \u003e= 5]   \u003c- \u0027Big\u0027\\n\\ntable(full$ticket.size)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022c584aa3e102aca5d87656c1e1cfa792ecdcf0e30\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022full \u003c- full %\u003e%\\n mutate(Survived = case_when(Survived==1 ~ \\\u0022Yes\\\u0022, \\n                              Survived==0 ~ \\\u0022No\\\u0022))\\n\\ncrude_summary \u003c- full %\u003e%\\n  filter(set==\\\u0022train\\\u0022) %\u003e%\\n  select(PassengerId, Survived) %\u003e%\\n  group_by(Survived) %\u003e%\\n  summarise(n = n()) %\u003e%\\n  mutate(freq = n / sum(n))\\n\\ncrude_survrate \u003c- crude_summary$freq[crude_summary$Survived==\\\u0022Yes\\\u0022]\\nkable(crude_summary, caption=\\\u00222x2 Contingency Table on Survival.\\\u0022, format=\\\u0022markdown\\\u0022)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022c36ad2a802afa709da84105d9764f2bfca6d015a\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022g1_pclass \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022), aes(Pclass, fill=Survived)) +\\n  geom_bar(position = \\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by Class\\\u0022) + \\n  theme_minimal()\\n\\ng2_sex \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022), aes(Sex, fill=Survived)) +\\n  geom_bar(position = \\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by Sex\\\u0022) + \\n  theme_minimal()\\n\\ntbl_age \u003c- full %\u003e%\\n  filter(set==\\\u0022train\\\u0022) %\u003e%\\n  select(Age, Survived) %\u003e%\\n  group_by(Survived) %\u003e%\\n  summarise(mean.age = mean(Age, na.rm=TRUE))\\n\\ng3_age \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022), aes(Age, fill=Survived)) +\\n  geom_histogram(aes(y=..density..), alpha=0.5) +\\n  geom_density(alpha=.2, aes(colour=Survived)) +\\n  geom_vline(data=tbl_age, aes(xintercept=mean.age, colour=Survived), lty=2, size=1) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_colour_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Density\\\u0022) +\\n  ggtitle(\\\u0022Survival Rate by Age\\\u0022) + \\n  theme_minimal()\\n\\ng4_agegroup \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022 \u0026 !is.na(Age)), aes(`Age Group`, fill=Survived)) +\\n  geom_bar(position = \\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by Age Group\\\u0022) + \\n  theme_minimal()\\n\\ng5_sibsp \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022), aes(SibSp, fill=Survived)) +\\n  geom_bar(position = \\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by SibSp\\\u0022) + \\n  theme_minimal()\\n\\ng6_parch \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022), aes(Parch, fill=Survived)) +\\n  geom_bar(position = \\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by Parch\\\u0022) + \\n  theme_minimal()\\n\\ng7_embarked \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022), aes(Embarked, fill=Survived)) +\\n  geom_bar(position = \\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by Embarked\\\u0022) + \\n  theme_minimal()\\n\\ng8_title \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022) %\u003e% na.omit, aes(title, fill=Survived)) +\\n  geom_bar(position=\\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by Title\\\u0022) + \\n  theme_minimal() +\\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\\n\\ng9_family \u003c- ggplot(full %\u003e% filter(set==\\\u0022train\\\u0022) %\u003e% na.omit, aes(`FamilySize`, fill=Survived)) +\\n  geom_bar(position=\\\u0022fill\\\u0022) +\\n  scale_fill_brewer(palette=\\\u0022Set1\\\u0022) +\\n  scale_y_continuous(labels=percent) +\\n  ylab(\\\u0022Survival Rate\\\u0022) +\\n  geom_hline(yintercept=crude_survrate, col=\\\u0022white\\\u0022, lty=2, size=2) +\\n  ggtitle(\\\u0022Survival Rate by Family Group\\\u0022) + \\n  theme_minimal() +\\n  theme(axis.text.x = element_text(angle = 90, hjust = 1))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00226a84abaebaa1f77565db448d03f4dc9d5a26fcec\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022grid.arrange(g1_pclass, g2_sex)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00225882a16041a98a997060146bf87a2f3f90499a4f\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022grid.arrange(g3_age , g4_agegroup)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022b8470479bc24d336549b9efccf86b33d61d93826\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022grid.arrange(g5_sibsp  , g6_parch)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002265524921f12b5eaba8131deca0cd2e77753cdfef\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022grid.arrange(g7_embarked   , g8_title, g9_family )\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00226c81224f793394d3e017b908bb5c7355ba45bae6\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022tbl_corr \u003c- full %\u003e%\\n  filter(set==\\\u0022train\\\u0022) %\u003e%\\n  select(-PassengerId, -SibSp, -Parch) %\u003e%\\n  select_if(is.numeric) %\u003e%\\n  cor(use=\\\u0022complete.obs\\\u0022) %\u003e%\\n  corrplot.mixed(tl.cex=0.85)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00223eaa5e63ca88aa8149399873c0cda5ab51ed34aa\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022tbl_mosaic \u003c- full %\u003e%\\n  filter(set==\\\u0022train\\\u0022) %\u003e%\\n  select(Survived, Pclass, Sex, AgeGroup=`Age Group`, title, Embarked, `FamilySize`) %\u003e%\\n  mutate_all(as.factor)\\n\\nmosaic(~Pclass+Sex+Survived, data=tbl_mosaic, shade=TRUE, legend=TRUE)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022291dfff7f5e917a340215e2b5050ca9c9fad82e1\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022library(alluvial)\\n\\ntbl_summary \u003c- full %\u003e%\\n  filter(set==\\\u0022train\\\u0022) %\u003e%\\n  group_by(Survived, Sex, Pclass, `Age Group`, title) %\u003e%\\n  summarise(N = n()) %\u003e% \\n  ungroup %\u003e%\\n  na.omit\\n\\nalluvial(tbl_summary[, c(1:4)],\\n         freq=tbl_summary$N, border=NA,\\n         col=ifelse(tbl_summary$Survived == \\\u0022Yes\\\u0022, \\\u0022blue\\\u0022, \\\u0022gray\\\u0022),\\n         cex=0.65,\\n         ordering = list(\\n           order(tbl_summary$Survived, tbl_summary$Pclass==1),\\n           order(tbl_summary$Sex, tbl_summary$Pclass==1),\\n           NULL,\\n           NULL))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00228e46c15a994073a4e91b2f7f2bcaab21dc06122f\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022## Titantic Mega Model - [0.84210] 커널 튜토리얼\\n\\n- 6 가지 모델이 1 가지 모델보다 뛰어날까요?\\n- 타이탄 메가 모형은 Kaggle의 최고 6 개의 타이탄 모형의 앙상블이고 84.2 % 성능!! 먼저 우리는 이름만 모델을 사용하여 간단한 타이타닉으로 시작합니다. Ticket, Fare, Pclass를 조심스럽게 통합함으로써 점수를 83.3 % 인상 할 것입니다. \\n\\n- 모델은 모든 여성과 소년이 살고있는 가정의 모든 소년의 생존율을 예측합니다. 그리고 그것은 모든 여성과 소년들이 죽은 한 가족의 모든 여성들에 대해 사망할 것이라고 예측합니다. \\n- 그것은 단지 22 가지 예언을 합니다. 시험 데이터 세트에 396 명의 승객이 남아 있습니다. 우리는 그 (것)들을 예언하기 위하여 Kaggle의 최고 타이탄 모형의 앙상블을 건설 할 것\\n\\n![Titanic Mega Model](http://playagricola.com/Kaggle/tree6.jpg)\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002287adea7141ce3b909340513cb6287f6964a652ee\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022## PART A: The Woman-Child-Group Model\\n\\n- 여기에 게시 된 Woman-Child-Group 모델에서 여성 - 아동 집단은 surname(칭호, 호칭)으로 형성되었습니다. 그러나 Surname는 항상 승객이 같은 가족에 속해 여행한다는 의미는 아닙니다. 승객 195와 1167을보십시오 :\\n\\n`PId Pclass              Name     Sex Age SibSp Parch   Ticket    Fare Cabin Embarked\\n195   1     Brown, Mrs. James  female  44     0     0 PC 17610 27.7208    B4        C\\n1067  2    Brown, Miss. Edith  female  15     0     2    29750 39.0000              S`  \\n\\n\\n- 그들은 둘 다 Surname이 \u0027브라운\u0027이며 딸과 함께 여행하는 어머니인 것으로 보입니다. 그러나, 그들은 다른 Pclasses, 다른 티켓, 다른 요금, 다른 캐빈, 다른 착륙, 호환되지 않는 SibSp과 Parch 있습니다. 나는 이 두 승객이 관련이 없다고 생각한다. 이제 승객 59, 473 및 1142를 살펴보십시오.\\n\\n`PId Pclass                 Name    Sex   Age SibSp Parch     Ticket  Fare Cabin Embarked\\n59      2 West, Miss. Constance  female  5.00     1     2 C.A. 34651 27.75              S\\n473     2 West, Mrs. Edwy Arthur female 33.00     1     2 C.A. 34651 27.75              S \\n1142    2    West, Miss. Barbara female  0.92     1     2 C.A. 34651 27.75              S`  \\n\\nThey all have the surname \u0027West\u0027 and appear to be a mother traveling with her two daughters. They have the same Pclass, same Ticket, same Fare, same Cabin, same Embarked, and compatible SibSp and Parch. I believe these three passengers are related.\\n\\n- 그들은 모두 \u0027West\u0027라는 Surname을 갖고 있으며 두 딸과 함께 여행하는 어머니 인 것으로 보입니다. 그들에는 동일한 Pclass, 동일한 표, 동일한 운임, 동일한 오두막, 동일한 Embarked 및 겸용성 SibSp 및 Parch가있다. 나는이 세 명의 승객이 관련이 있다고 믿는다.\\n\\n\\n### A1. Engineer a precise GroupId for woman-child-groups\\n\\n- 가족을 정확하게 식별하는 GroupId를 작성합시다. Jack Roberts는 Ticket에는 커널의 Surnames와 동일한 그룹화 정보가 들어 있습니다. 티켓만 사용하거나 그룹을 형성하기 위해 Surname만 사용하면 실수로 이어집니다. \\n- 따라서 각 승객에 대해 연결 그룹 ID = Surname + Pclass + 티켓 + 운임 + 승차권을 형성합시다. \\n- 때로는 함께 여행하는 승객의 티켓이 마지막 자리에서 달라지므로 티켓의 마지막 자리도 제거합시다. 예를 들어, 웨스트 부인의 티켓을 \u0027C.A. 34651 \u0027~\u0027C.A. 3465X \u0027. (나는이 멋진 트릭을 Erik Bruin의 노트 4.2.4 절의 티켓 번호를 제거하기 위해 배웠다.) \\n- 나는 의도적으로 SibSp와 Parch를 GroupId에 포함하지 않습니다. 왜냐하면 많은 오류가 있기 때문입니다 (아래 설명 참조). Cabin 데이터가 너무 많아서 Cabin을 포함하지 않습니다.\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022d675046f9b9378e239a7f41a4456bd87e1d413cc\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data \u003c- rbind(train,test)\\ndata$Surname = substring( data$Name,0,regexpr(\u0027,\u0027,data$Name)-1)\\ndata$GroupId = paste( data$Surname, data$Pclass, sub(\u0027.$\u0027,\u0027X\u0027,data$Ticket), data$Fare, data$Embarked, sep=\u0027-\u0027)\\ndata[c(195,1067,59,473,1142),c(\u0027Name\u0027,\u0027GroupId\u0027)]\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002274d8b0d8fcbd9697c29febf9cdc07890150a3c11\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- 이 새로운 GroupId를 사용하면 West는 함께 여행했지만 Brown은 그렇지 않았음이 분명합니다\\n\\n ### A2. Identify Nannies and Relatives traveling in woman-child-groups\\n \\n -  Now look at the following passengers:\\n\\n`PId Pclass                      Name    Sex Age SibSp Parch   Ticket   Fare      Cabin Embarked\\n312   1    Ryerson, Miss. Emily Borie female  18     2    2 PC 17608 262.375 B57 B59 B63 B66   C\\n743   1  Ryerson, Miss. Susan Parker  female  21     2    2 PC 17608 262.375 B57 B59 B63 B66   C\\n91    1  Ryerson, Mrs. Maria          female  48     1    3 PC 17608 262.375 B57 B59 B63 B66   C\\n951   1   Chaudanson, Miss. Victorine female  36     0    0 PC 17608 262.375             B61   C\\n956   1   Ryerson, Master. John Borie   male  13     2    2 PC 17608 262.375 B57 B59 B63 B66   C\\n1034  1    Ryerson, Mr. Arthur Larned   male  61     1    3 PC 17608 262.375 B57 B59 B63 B66   C`\\n\\n- 이것은 Ryerson 가족입니다. 성인 2 명과 어린이 3 명이 있습니다. 그들은 티켓 = \u0027PC 17608\u0027에서 Cabin B57, B59, B63 및 B66에 머물렀다. \\n- Pclass = 1에서 Embarked = C. Chaudanson Miss도 Ticket = \u0027PC 17608\u0027을 구입하고 그들 옆의 캐빈 인 Cabin = B61에 머물렀다. \\n- 나는 Chaudanson Miss가 Ryerson 가족과 함께 여행했고 유모 또는 친척 중 하나라고 생각합니다. 우리는 보모와 친척을 우리 여성 - 자녀 그룹에 추가하고 싶습니다. 왜냐하면 그 데이터는 그들이 여행 한 여성과 자녀들과 함께 살았거나 사망 한 것을 보여주기 때문입니다.\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002250c5dccbac8641dafd10ec87ab0d7a9b648a8ea5\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022# engineer titles\\ndata$Title \u003c- \u0027man\u0027\\ndata$Title[data$Sex==\u0027female\u0027] \u003c- \u0027woman\u0027\\ndata$Title[grep(\u0027Master\u0027,data$Name)] \u003c- \u0027boy\u0027\\n\\n\\n# color variable is used in plots below\\ndata$Color \u003c- data$Survived\\n\\n\\n# engineer \\\u0022woman-child-groups\\\u0022\\ndata$GroupId[data$Title==\u0027man\u0027] \u003c- \u0027noGroup\u0027\\ndata$GroupFreq \u003c- ave(1:1309,data$GroupId,FUN=length)\\ndata$GroupId[data$GroupFreq\u003c=1] \u003c- \u0027noGroup\u0027\\ndata$TicketId = paste( data$Pclass,sub(\u0027.$\u0027,\u0027X\u0027,data$Ticket),data$Fare,data$Embarked,sep=\u0027-\u0027)\\ncount = 0\\n\\n\\n# add nannies and relatives to groups\\nfor (i in which(data$Title!=\u0027man\u0027 \u0026 data$GroupId==\u0027noGroup\u0027)){\\n    data$GroupId[i] = data$GroupId[data$TicketId==data$TicketId[i]][1]\\n    if (data$GroupId[i]!=\u0027noGroup\u0027) {\\n        # color variable is used in plots below\\n        if (is.na(data$Survived[i])) data$Color[i] = 5\\n        else if (data$Survived[i] == 0) data$Color[i] = -1\\n        else if (data$Survived[i] == 1) data$Color[i] = 2\\n        count = count + 1\\n    }\\n}\\ncat(sprintf(\u0027우리는 %d 명의 보모/친척을 찾아 그룹에 추가했습니다.\\\\n\u0027,count))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002257c2f15d0dae2d9eac8c045818987592a7dd00c6\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022### A3. Classify unknown woman-child-groups\\n\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022d97c10b1ee641419cb80b3c98a15b1b06523fada\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022b3d29e62b1d522c230f30a47f0d5943b47fed74e\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data$GroupName = substring( data$GroupId,0,regexpr(\u0027-\u0027,data$GroupId)-1)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022b2592076beae4035be4ec58fe89b1dbe1522db91\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022table(data$GroupName)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002201dc5ad720f8b1d9708081ff974ab1f38f412997\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data$Color[is.na(data$Color) \u0026 data$Title==\u0027woman\u0027] \u003c- 3\\ndata$Color[is.na(data$Color) \u0026 data$Title==\u0027boy\u0027] \u003c- 4\\nx = data$GroupId[data$GroupId!=\u0027noGroup\u0027]; x = unique(x); x=x[order(x)]\\nplotData \u003c- list(); g \u003c- list()\\n\\nfor (i in 1:3) plotData[[i]] \u003c- data[data$GroupId %in% x[(27*(i-1))+1:27],]\\nfor (i in 1:3) g[[i]] = ggplot(data=plotData[[i]], aes(x=0,y=factor(GroupName))) +\\n    geom_dotplot(dotsize=0.9,binwidth=1,binaxis=\u0027y\u0027,method=\\\u0022histodot\\\u0022,stackgroups=T,\\n        aes(fill=factor(Color),color=Title )) +\\n    scale_color_manual(values=c(\u0027gray70\u0027,\u0027blue\u0027,\u0027gray70\u0027),limits=c(\u0027man\u0027,\u0027boy\u0027,\u0027woman\u0027)) +\\n    scale_fill_manual(values=c(\u0027#BB0000\u0027,\u0027#FF0000\u0027,\u0027#009900\u0027,\u0027#00EE00\u0027,\u0027gray70\u0027,\u0027gray70\u0027,\u0027white\u0027),\\n        limits=c(\u00270\u0027,\u0027-1\u0027,\u00271\u0027,\u00272\u0027,\u00273\u0027,\u00274\u0027,\u00275\u0027)) +\\n    scale_y_discrete(limits = rev(levels(factor(plotData[[i]]$GroupName)))) +\\n        theme(axis.title.x=element_blank(), axis.title.y=element_blank(),\\n        axis.text.x=element_blank(), axis.ticks.x=element_blank(),\\n        legend.position=\u0027none\u0027)\\ngrid.arrange(g[[1]],g[[2]],g[[3]],nrow=1,top=\u0027All 80 woman-child-groups in the test and training datasets combined (228 passengers).\\nRed = deceased female or boy, Green = survived, White or Gray = unknown survival, \\nWhite or LightGreen or LightRed = different surname same ticket, Blue outline = boy\u0027)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022a86809b9380c851cda5fe8abe3c1aa398046af05\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- 테스트 및 훈련 데이터 세트의 모든 80 명의 여성 - 아동 그룹이 합쳐졌습니다 (228 명의 승객). 빨간색 = 사망 한 여성 또는 소년, 녹색 = 생존, 흰색 또는 회색 = 생존 알 수 없음, 흰색 또는 LightGreen 또는 LightRed = 다른 성 이름의 티켓, 파란색 외곽선 = 소년\\n\\n- 첫 번째로 80 명의 여성 - 아동 집단 모두가 살았거나 모두 사망했는지 (우리가 알고있는 생존 정보를 기반으로) 주목합니다. 그것은 여성 - 아동 집단 모델의 숨은 비밀입니다. \\n- 알 수 없는 회색 또는 흰색 원을 앞의 점의 색과 같게 설정하여 예측해야 한다고 합니다. \\n- 예를 들어, Abbott는 살아있는 한 여성이 하나의 알려지지 않은 소년과 함께 여행하는 것을 보여줍니다. 미지의 소년 승객 1284 Master Eugene Abbott가 살아 남았음을 예측해야합니다. \\n\\n- 그룹 전체가 알려지지 않은 네 개의 가족이 있습니다. 이 가족은 Gibson, Klasen, Peacock, van Billiard입니다. 우리는 그들에 대한 예언을 해야합니다. 그래서 어느 여성 - 자녀 집단이 살고 있는지를 탐구합시다.\\n\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00225ef66a9e98d2ab193b01f9c8a1713b3f760d83d7\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data$Survived \u003c- factor(data$Survived)\\ndata$CabinLetter \u003c- substring(data$Cabin,0,1)\\ng1 = ggplot(data=data[data$GroupId!=\u0027noGroup\u0027 \u0026 !is.na(data$Survived),]) +\\n    geom_bar(stat=\u0027count\u0027,aes(x=Pclass,fill=Survived))\\ng2 = ggplot(data=data[data$GroupId!=\u0027noGroup\u0027 \u0026 !is.na(data$Survived) \u0026 !is.na(data$Age),]) +\\n    geom_histogram(bins=20,aes(x=Age,fill=Survived))\\ng3 = ggplot(data=data[data$GroupId!=\u0027noGroup\u0027 \u0026 !is.na(data$Survived),]) +\\n    geom_bar(stat=\u0027count\u0027,aes(x=Embarked,fill=Survived))\\ng4 = ggplot(data=data[data$GroupId!=\u0027noGroup\u0027 \u0026 !is.na(data$Survived),]) +\\n    geom_bar(stat=\u0027count\u0027,aes(x=CabinLetter,fill=Survived))\\ngrid.arrange(g1,g2,g3,g4,nrow=2,top=\u0027Analysis of training set\\\\\u0027s 156 Woman-Child-Group passengers\u0027)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002297d32fc8f739f8b84f824c31dcfd6be08615e663\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- 분석에서 우리는 Pclass = 1 또는 2로 여행하는 여성 - 아동 집단이 대부분 생존하고 Pclass = 3에있는 여성 - 아동 집단이 대부분 사망 한 것을 알 수있다. \\n- Gibsons는 Pclass = 1, Embarked = C 및 Cabin이 없었으므로 Gibsons가 살아남은 것을 예측해야합니다.\\n- Klasen \u0027s, Peacock \u0027s, van billiards는 Pclass = 3, Embarked = S, Cabin은 없었습니다. 그러므로 우리는 이 세 가정이 소멸 될 것이라고 예측해야 합니다.\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022897e18c7c2bd959889d34fd6e281710fddd7f9f1\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022### A4. Cross Validation\\n\\n- 이름 만 사용할 때이 모델은 훈련 데이터 세트에서 83.6 %의 유효성을 확인합니다. (1) 정확한 GroupId 사용, (2) 유모 및 친척 포함, (3) 알 수없는 그룹 분류로 모델의 정확성이 향상되는지 봅시다.\\n\\n[Titanic using Name only - 0.81818](https://www.kaggle.com/cdeotte/titanic-using-name-only-0-81818)\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002265d4298e5ecb24440feaeddfd8f65214754a02ca\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022# engineer titles on training set\\ntrain$Title \u003c- \u0027man\u0027\\ntrain$Title[train$Sex==\u0027female\u0027] \u003c- \u0027woman\u0027\\ntrain$Title[grep(\u0027Master\u0027,train$Name)] \u003c- \u0027boy\u0027\\n\\n\\n# Perform 25 trials of 10-fold cross validation\\ntrials = 25; sum = 0\\n\\nfor (j in 1:trials){\\nx = sample(1:890); s = 0\\nfor (i in 0:9){\\n    # engineer \\\u0022woman-child-groups\\\u0022\\n    train$Surname \u003c- substring(train$Name,0,regexpr(\\\u0022,\\\u0022,train$Name)-1)\\n    train$GroupId = paste( train$Surname, train$Pclass,sub(\u0027.$\u0027,\u0027X\u0027,train$Ticket),train$Fare,train$Embarked,sep=\u0027-\u0027)\\n    train$GroupId[train$Title==\u0027man\u0027] \u003c- \u0027noGroup\u0027\\n    train$GroupFreq \u003c- ave(1:891,train$GroupId,FUN=length)\\n    train$GroupId[train$GroupFreq\u003c=1] \u003c- \u0027noGroup\u0027\\n    # add nannies and relatives to groups.\\n    train$TicketId = paste( train$Pclass,sub(\u0027.$\u0027,\u0027X\u0027,train$Ticket),train$Fare,train$Embarked,sep=\u0027-\u0027)\\n    for (k in which(train$Title!=\u0027man\u0027 \u0026 train$GroupId==\u0027noGroup\u0027))\\n        train$GroupId[k] = train$GroupId[train$TicketId==train$TicketId[k] \u0026 train$PassengerId != train$PassengerId[k]][1]\\n    train$GroupId[is.na(train$GroupId)] \u003c- \u0027noGroup\u0027\\n    train$GroupFreq \u003c- ave(1:891,train$GroupId,FUN=length)\\n    # calculate training subset\u0027s group survival rate\\n    train$GroupSurvival \u003c- NA\\n    train$GroupSurvival[-x[1:89+i*89]] \u003c- ave(train$Survived[-x[1:89+i*89]],train$GroupId[-x[1:89+i*89]])\\n    # calculate testing subset\u0027s group survival rate from training set\u0027s rate\\n    for (k in x[1:89+i*89]){ \\n        train$GroupSurvival[k] \u003c- train$GroupSurvival[which(!is.na(train$GroupSurvival) \u0026 train$GroupId==train$GroupId[k])[1]]\\n        if (is.na(train$GroupSurvival[k])) train$GroupSurvival[k] \u003c- ifelse(train$Pclass[k]==3,0,1)\\n    }\\n    # apply gender model plus WCG\\n    train$predict \u003c- 0\\n    train$predict[train$Title==\u0027woman\u0027] \u003c- 1\\n    train$predict[train$Title==\u0027boy\u0027 \u0026 train$GroupSurvival==1] \u003c- 1\\n    train$predict[train$Title==\u0027woman\u0027 \u0026 train$GroupSurvival==0] \u003c- 0\\n    c = sum(abs(train$predict[x[1:89+i*89]] - train$Survived[x[1:89+i*89]]))\\n    s = s + c\\n}\\n#cat( sprintf(\\\u0022Trial %d has 10-fold CV accuracy = %f\\\\n\\\u0022,j,1-s/890))\\nsum = sum + 1-s/890\\n}\\ncat(sprintf(\\\u0022Average 10-fold CV accuracy from %d trials = %f\\\\n\\\u0022,trials,sum/trials))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022d004f0346a6e35d603fccff8b0a1e2e58bc10dc5\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- 우리의 정확도는 0.8 % 증가하여 84.4 %로 나타났습니다. 우리의 변화가 도움이 된 것 같습니다. 테스트 데이터 세트에 대한 예측을하고 Kaggle에 제출하십시오.\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022a17bd53d48d5d414eb12b940681e4be8e02aee3c\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022### A5. Make Predictions\\n\\n- 테스트 데이터 세트에서 여성 - 아동 그룹의 일부인 72 명의 승객이 있습니다. 두 가지 예측 규칙을 적용 해 보겠습니다.\\n- unknown passenger\u0027s woman-child-group이 모두 살거나 모두 사망 한 경우 (훈련 데이터 세트에 표시된대로), 그들이 동일하게 수행 한 것으로 예측하십시오.\\n- 알 수없는 승객의 woman-child-group에 훈련 데이터 세트에 구성원이 없으면 Pclass = 3 die, Pclass = 1 또는 2 Pclass를 사용하여 생존할 거라고 예측하십시오.\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00229e32eb9ea8d593778d0a288ad7ad50f6afd15023\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data$GroupSurvival \u003c- NA\\ndata$Survived \u003c- as.numeric(as.character(data$Survived))\\ndata$GroupSurvival[1:891] \u003c- ave(data$Survived[1:891],data$GroupId[1:891])\\nfor (i in 892:1309) data$GroupSurvival[i] \u003c- data$GroupSurvival[which(data$GroupId==data$GroupId[i])[1]]\\ndata$GroupSurvival[is.na(data$GroupSurvival) \u0026 data$Pclass==3] \u003c- 0\\ndata$GroupSurvival[is.na(data$GroupSurvival) \u0026 data$Pclass!=3] \u003c- 1\\ndata$Predict \u003c- 0\\ndata$Predict[data$Sex==\u0027female\u0027] \u003c- 1\\ndata$Predict[data$Title==\u0027woman\u0027 \u0026 data$GroupSurvival==0] \u003c- 0\\ndata$Predict[data$Title==\u0027boy\u0027 \u0026 data$GroupSurvival==1] \u003c- 1\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022ea13cc5ec35c494dd8fc5f8d404606d7c439d41b\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022cat(\u0027The following 8 males are predicted to live\\\\n\u0027)\\ndata[data$Sex==\u0027male\u0027 \u0026 data$Predict==1 \u0026 data$PassengerId\u003e891,c(\u0027Name\u0027,\u0027Title\u0027)]\\ncat(\u0027The following 14 females are predicted to die\\\\n\u0027)\\ndata[data$Sex==\u0027female\u0027 \u0026 data$Predict==0 \u0026 data$PassengerId\u003e891,c(\u0027Name\u0027,\u0027Title\u0027)]\\ncat(\u0027The remaining 258 males are predicted to die\\\\n\u0027)\\ncat(\u0027and the remaining 138 females are predicted to live\\\\n\u0027)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022e82007bd3788602fa8c350f0dda2b3e79307819b\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022submit \u003c- data.frame(PassengerId = 892:1309, Survived = data$Predict[892:1309])\\nwrite.csv(submit,\u0027genderSurnameModel2.csv\u0027,row.names=F)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002279426420947ab58a3a5d2947b8ee665a432c062a\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022 ![result](http://playagricola.com/Kaggle/surnameModel2.png)\\n Woohoo!! Our simple woman-child-group model scores 83.3%, incredible!\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022cd97eaa0a3f27649622db315a46f2b687d3be4af\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022### A6. Why didn\u0027t we use SibSp, Parch, Cabin in GroupId?\\n\\n- 왜 우리는 SibSp, Parch 및 Cabin을 사용하여 우리 여성 - 아동 집단을 확인하지 않았습니까? 여성 - 자녀 집단이 속한 80 개 가정에서 SibSp와 Parch는 27 개의 오류가 있습니다. 다음은 오류의 예입니다.\\n\\n`PId Pclass               Name    Sex Age SibSp Parch     Ticket  Fare Embarked\\n162     2     Watt, Mrs. James female  40     0     0 C.A. 33595 15.75        S\\n1012    2   Watt, Miss. Bertha female  12     0     0 C.A. 33595 15.75        S`  \\n\\n- 다음은 딸과 함께 여행하는 어머니입니다. 그들은 동일한 성, 동일한 Pclass, 동일한 표, 동일한 운임, 동일한 승선이 있습니다. 그러나 SibSp와 Parch는 모두 0과 같습니다. Cabin 정보의 77.5 %가 누락 되었기 때문에 우리 그룹에서 Cabin을 사용하지 않았습니다.\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002233b164e59b30446d2841ccca1a826fe4059e5ada\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022## Titanic WCG+XGBoost Tutorial\\n\\n[Titanic WCG+XGBoost - 0.84688](https://www.kaggle.com/cdeotte/titanic-wcg-xgboost-0-84688)\\n\\n- 타이타닉 테스트 데이터 세트에는 성인 남성이 245 명이 있습니다. Kaggle의 모든 상위 모델을 검토하면 모든 성인 남성이 사망 할 것이라고 모든 사람이 예측합니다. \\n\\n- 살았던 성인 남성 한 명 이상을 찾을 수 있습니까? 성인 남성의 생존율을 정확하게 예측할 수 있다면 가장 정확한 타이타닉 모델을 구할 수 있습니다!\\n\\n![tree12](http://playagricola.com/Kaggle/tree12.jpg)  \\n  \\n\\n### Explore adult males survival with XGBoost\\n\\n- 먼저 Titanic 데이터 세트를 로드하고 Age and Fare가 누락된 것을 확인할 수 있습니다.\\n- 다음으로 x1 = Fare / (Ticket Frequency * 10) 및 x2 = Parch + SibSp + 1 + (Age / 70)의 두 가지 새로운 변수를 설계합니다. 형상 공간을 2 차원으로 축소하면 모든 것을 시각화 할 수 있습니다.\\n  \\n[1]:https://www.kaggle.com/cdeotte/titanic-wcg-xgboost-0-84688\u0022},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022735b006ad1c995865797083200301025a7efcb01\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022train \u003c- read.csv(\u0027../input/titanic/train.csv\u0027,stringsAsFactors=F)\\ntest \u003c- read.csv(\u0027../input/titanic/test.csv\u0027,stringsAsFactors=F)\\ntest$Survived \u003c- NA; data \u003c- rbind(train,test)\\n# engineer person type\\ndata$Title \u003c- \u0027man\u0027\\ndata$Title[grep(\u0027Master\u0027,data$Name)] \u003c- \u0027boy\u0027\\ndata$Title[data$Sex==\u0027female\u0027] \u003c- \u0027woman\u0027\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00226a1afbd4b4bffae8767fe01c57be4a1dbd60bed4\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022fit \u003c- rpart(Age ~ Title + Pclass + SibSp + Parch,data=data)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00221b3981c92813e76c74b45477a682fe85dee24e85\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022fit\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00222fc4b627d7c2691d274e04f3521d7cae80ac51b1\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data$Age[is.na(data$Age)] \u003c- predict(fit,newdata=data[is.na(data$Age),])\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00224726a460441a97d8e5ee99d367dc35a07c80eb93\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022fit \u003c- rpart(Fare ~ Title + Pclass + Embarked + Sex + Age,data=data)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022118236ffcd686078804db2fe927dfaeebb35dd7c\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022fit\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022831cc392c0feab2009a8310e49260e4227439000\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data$Fare[is.na(data$Fare)] \u003c- predict(fit,newdata=data[is.na(data$Fare),])\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002283184213599c9d11bcaf25ae8bb1ccda67ed9a30\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data \u003c- data %\u003e% as.tibble() %\u003e%\\n    mutate(TicketFreq  = ave(1:1309, Ticket,FUN=length),\\n           FareAdj = Fare / TicketFreq,\\n           FamilySize = SibSp + Parch + 1\\n          )           \u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022a46d95bd9107cd2c9576ca39cf7b326c25d1020f\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data2 \u003c- data[data$PassengerId\u003c=891 \u0026 data$Title==\u0027man\u0027,]\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022d2b7046b25a62f0a28f732eeb92272d86bd9fcfc\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022data3 \u003c- data.frame(\\n    y = data2$Survived,\\n    x1 = data2$Fare / (data2$TicketFreq * 10),\\n    x2 = (data2$SibSp + data2$Parch + 1) + (data2$Age / 70),\\n    Pclass = data2$Pclass)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00227c23222b6ea3dcd92165b4520d69db0ad707a9d1\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022g1 = ggplot(data[data$FareAdj\u003e0 \u0026 data$FareAdj\u003c40,]) + \\n    geom_density(aes(x=FareAdj,fill=factor(Pclass)),alpha=0.9,show.legend=F) +\\n    labs(fill=\u0027Pclass\u0027) + geom_vline(xintercept=c(10,20),linetype=\u0027dotted\u0027) +\\n    xlim(0,40) + labs(title=\u0027All Passengers\u0027,x=\u0027x1 = Fare / Ticket Frequency\u0027)\\n\\ng2 = ggplot(data[data$Fare\u003e0 \u0026 data$Fare\u003c40 ,]) +\\n    geom_density(aes(x=Fare,fill=factor(Pclass)),alpha=0.9) +\\n    xlim(0,40) + labs(title=\u0027All Passengers\u0027,fill=\u0027Pclass\u0027,y=\u0027\u0027)\\n\\ng3 = ggplot(data[!is.na(data$Survived) \u0026 data$Title==\u0027man\u0027 \u0026 data$Pclass==1 \u0026 data$FamilySize\u003c4,]) + \\n    geom_density(aes(x=FamilySize+Age/70,fill=factor(Survived)),alpha=0.9,bw=0.04) +\\n    labs(fill=\u0027Survived\u0027) +\\n    annotate(\u0027text\u0027,x=1.4,y=2.4,label=\u0027Age 30\\\\nFS=1\u0027) +\\n    annotate(\u0027text\u0027,x=2.4,y=2.4,label=\u0027Age 30\\\\nFS=2\u0027) +\\n    geom_vline(xintercept=c(1.43,2.43),linetype=\u0027dotted\u0027) +\\n    xlim(1,4) + labs(title=\u0027Adult Males Pclass=1\u0027,x=\u0027x2 = FamilySize + Age/70\u0027)\\n\\ngrid.arrange(g3,g1,g2,layout_matrix = rbind(c(1, 1), c(2, 3)))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022dc15771e73f98220774a5d29adc5604f251a5777\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- FamilySize + Age / 70을 작성하면 1 차원에서 SibSp(같이 탑승한 형제 / 배우자 숫자), Parch (같이 탑승한 부모, 자녀의 숫자) 및 Age를 볼 수 있습니다. \\n- 20 세에서 36 세 사이의 Pclass = 1에서 FamilySize \u003c= 2 인 성인 남성이 생존 확률이 50 % 이상임을 보여줍니다. (정확하게, 훈련 세트에서 56 % = 18 / 32 생존). 또한 FamilySize = 2 인 40 대 남성의 경우 생존 확률이 63 % (= 5/8)입니다. \u0027\\n - Fare를 TicketFrequency로 나눕니다. 실제 가격이 지불 되었기 때문입니다. ( 11 명의 세이지 가족은 그들의 11 번째 3 종 티켓 각각에 대해 69.55 달러를 내지 않았다. )\\n\\n- 그들은 $ 6.32 = 69.55 / 11.를 지불했을 것입니다. \\n- 마지막으로, \u0027x1\u0027을 10으로 나누어 스케일이 \u0027x2\u0027의 스케일과 일치하도록 하여 특정 기계학습 알고리즘을 돕습니다. XGBoost를 변수 쌍 (x1, x2)에 적용하고 어떤 패턴을 발견하는지 살펴 보겠습니다.\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00220e98a9609bd97bcd7b0c856f4ddf1274a2192526\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022# classify males with xgboost\\nset.seed(2310)\\n\\nx1s \u003c- seq(0, 5, length.out = 100)\\nx2s \u003c- seq(1, 3, length.out = 100)\\ng \u003c- data.frame(x1 = rep(x1s, each=100), x2 = rep(x2s, time = 100))\\nparam \u003c- list(objective   = \\\u0022binary:logistic\\\u0022,\\n            eval_metric = \\\u0022error\\\u0022,\\n            max_depth   = 5,\\n            eta         = 0.1,\\n            gammma      = 0.1,\\n            colsample_bytree = 1,\\n            min_child_weight = 1)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022550fcb5dc5994f8169b74bb335921b4f4a431b0e\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022param\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022ebe2fde6d9ea0251cf8e9bc75eb08da344c7f015\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022dim(data.matrix(data3[,c(\u0027x1\u0027,\u0027x2\u0027)]))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022d52baa50024986994b8075f5bf23dd91718df135\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022length(data3$y)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002270ea787f5cd0c1e9fea674cdcb2af88598a6e8b4\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022cat(\u0027XGBoosting begun...\\\\n\u0027)\\nxgb \u003c- xgboost(params  = param,\\n            data    = data.matrix(data3[,c(\u0027x1\u0027,\u0027x2\u0027)]),\\n            label   = as.numeric(as.factor(data3$y)) - 1 , \\n            nrounds = 500,\\n            print_every_n = 100,\\n            verbose = 1)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022449e850b5993f348b3233cbd5451ed26c09984a9\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022p \u003c- predict(xgb,newdata=data.matrix(g[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\ng$y \u003c- ifelse(p\u003e0.5,1,0)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022eae9b02512c62df32fcb008fe59023e570938d92\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022head(g)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022049a124e331d654c9283abd227f2df4f6ee8cce9\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022ggplot(data=data3[data3$x1\u003c5 \u0026 data3$x2\u003c3,]) +\\n    xlim(0,5) + ylim(1,3) +\\n    geom_tile(data=g,aes(x1,x2,fill=factor(y))) +\\n    geom_density_2d(aes(x1,x2,color=factor(y))) +\\n    geom_point(size=2,aes(x1,x2,color=factor(y),shape=factor(Pclass))) +\\n    scale_color_manual(values=c(\u0027#AA0000\u0027,\u0027#00AA00\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    scale_fill_manual(values=c(\u0027#FF9999\u0027,\u0027#99FF99\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    labs(x=\u0027Fare / (10 x TicketFrequency)\u0027,y=\u0027FamilySize + (Age / 70)\u0027,shape=\u0027Pclass\u0027,fill=\u0027Classify\u0027,\\n        title=\u0027XGBoost learns the training set\\\\\u0027s\\n        537 adult males. Green is P(live)\u003e0.5\u0027,color=\u0027Survived\u0027) +\\n    geom_vline(xintercept=2.8, linetype=\u0027dotted\u0027) +\\n    geom_hline(yintercept=c(1.43,2.43), linetype=\u0027dotted\u0027) +\\n    annotate(\u0027text\u0027,x=2.95,y=2.9,label=\u0027Fare = $28\u0027) +\\n    annotate(\u0027text\u0027,x=4.7,y=2.35,label=\u0027Age = 30\u0027) +\\n    annotate(\u0027text\u0027,x=4.7,y=1.35,label=\u0027Age = 30\u0027)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022bd3684494c36610f3938364789630f447bc2e5aa\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022 - XGBoost에서 훈련 데이터 세트의 성인 남성 중 생존 패턴을 찾은 것 같습니다! \\n - 도표에서 우리는 생존 가능성이 가장 높은 성인 남성이 Pclass = 1, FareAdj = 28 달러, SibSp + Parch \u003c= 1, Age = 30이라는 것을 알 수 있습니다. 음영은 XGBoost의 분류 결정이 무엇인지 나타냅니다. 녹색 영역은 P (라이브)\u003e 0.5를 예측하는 XGBoost에 해당합니다.\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00223ee8eb7bae87a79ae0a2e5c4406682d8c45c987b\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022set.seed(300)\\ns = sample(1:537,100)\\ns2 = (1:537)[-s]\\nxgb \u003c- xgboost(params  = param,\\n            data    = data.matrix(data3[s2,c(\u0027x1\u0027,\u0027x2\u0027)]),\\n            label   = as.numeric(as.factor(data3$y[s2])) - 1 ,  \\n            nrounds = 500,\\n            print_every_n = 100,\\n            silent = 1,\\n            verbose = 0)\\n\\np \u003c- predict(xgb,newdata=data.matrix(data3[s,c(\u0027x1\u0027,\u0027x2\u0027)]))\\ndata3$y2 \u003c- NA\\nroc = data.frame(TN=rep(0,102),FP=rep(0,102),FN=rep(0,102)\\n    ,TP=rep(0,102),FPR=rep(0,102),TPR=rep(0,102))\\nrownames(roc) \u003c- seq(0,1.01,0.01)\\nfor (i in 1:102){\\n    data3$y2[s] \u003c- ifelse(p\u003c(i-1)/100,0,1)\\n    roc$TP[i] \u003c- length(which(data3$y==1 \u0026 data3$y2==1))\\n    roc$TN[i] \u003c- length(which(data3$y==0 \u0026 data3$y2==0))\\n    roc$FP[i] \u003c- length(which(data3$y==0 \u0026 data3$y2==1))\\n    roc$FN[i] \u003c- length(which(data3$y==1 \u0026 data3$y2==0))\\n    roc$FPR[i] \u003c- roc$FP[i] / (roc$FP[i] + roc$TN[i])\\n    roc$TPR[i] \u003c- roc$TP[i] / (roc$TP[i] + roc$FN[i])\\n}\\ndiag \u003c- data.frame(x=c(0,1),y=c(0,1))\\nggplot(roc,aes(x=FPR,y=TPR)) + \\n    geom_line() + labs(title=\u0027ROC curve where \\\u0022positive\\\u0022 = male survives\u0027,\\n        x=\u0027False positive rate\u0027,y=\u0027True positive rate\u0027) +\\n    geom_point(data=roc[91,],aes(x=FPR,y=TPR),size=3,color=\u0027red\u0027) +\\n    annotate(\u0027text\u0027,x=0.13,y=0.12,label=\u0027threshold p\u003e=0.9\u0027,color=\u0027red\u0027) +\\n    geom_point(data=roc[76,],aes(x=FPR,y=TPR),size=3,color=\u0027darkgreen\u0027) +\\n    annotate(\u0027text\u0027,x=0.16,y=0.30,label=\u0027threshold p\u003e=0.75\u0027,color=\u0027darkgreen\u0027) +\\n    geom_point(data=roc[51,],aes(x=FPR,y=TPR),size=3,color=\u0027blue\u0027) +\\n    annotate(\u0027text\u0027,x=0.20,y=0.5,label=\u0027threshold p\u003e=0.5\u0027,color=\u0027blue\u0027) +\\n    geom_line(data=diag,aes(x=x,y=y),linetype=\u0027dotted\u0027)\\narea = 0\\nfor(i in 1:101){\\n    area = area + roc$TPR[i] * (roc$FPR[i]-roc$FPR[i+1])\\n}\\ncat(sprintf(\u0027Area under ROC = %f\\\\n\u0027,area))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00223345019f7c301ae5ed7cfa7540310ecc524c69a3\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- ROC 아래의 AUC는 0.82\u003e 0.50입니다. (100 회 시행중인 평균 AUC = 0.70) 즉, XGBoost가 생존 패턴을 발견했습니다.\\n- ROC 플롯은 또한 XGBoost가 P (live)\u003e 0.5라고 말할 때마다 생존 할 것으로 예측하면 많은 1종 오류를 만듭니다 (즉, 성인 남성이 생존하지 않을 때 생존하는 것으로 잘못 예측합니다). 정확도를 극대화하기 위해 임계 값을 신중하게 선택해야 하므로 그리드 검색을 사용하여 0.50, 0.75, 0.90 및 0.92 중에서 최상의 임계 값을 찾습니다.\\n\\n\\n## Grid search and cross validate\\n- 그리드 검색을 사용하여 XGBoost에 대한 최적의 매개 변수가 treeDepth = 5, p\u003e = 0.90임을 알 수 있습니다. \\n- 그리드 검색을 수행하려면 아래 코드에서 for 루프의 주석 처리를 제거하고 검색 할 하이퍼 매개 변수를 추가하십시오.이 노트에서는 그리드 검색을 수행하지 않습니다. . 이제 XGBoost가 CV = 78.6 % 인 성별 모델보다 더 정확한지 확인하기 위해 교차 유효성 검사를 수행해 봅시다.\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022d8c6c46d68f88e47351ad0b64c2bdb8686625ba1\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022#accuracy = matrix(nrow=4,ncol=4)\\n#rownames(accuracy) \u003c- c(\u0027d=3\u0027,\u0027d=4\u0027,\u0027d=5\u0027,\u0027d=6\u0027)\\n#colnames(accuracy) \u003c- c(\u00270.50\u0027,\u00270.75\u0027,\u00270.90\u0027,\u00270.92\u0027)\\n#for (j in 1:4)\\n#for (k in 1:4){\\nset.seed(2)\\ntrials=100; sum=0\\nfor (i in 1:trials){\\n    s = sample(1:891,800)\\n    s2 = (1:891)[-s]\\n    dataB \u003c- data[data$PassengerId %in% s \u0026 data$Title==\u0027man\u0027,]\\n    dataC \u003c- data[data$PassengerId %in% s2 \u0026 data$Title==\u0027man\u0027,]\\n    data$Predict \u003c- 0\\n    data$Predict[data$Sex==\u0027female\u0027] \u003c- 1\\n    dataTrain \u003c- data.frame(y=as.numeric(as.factor(dataB$Survived)) - 1,x1=dataB$FareAdj/10,x2=dataB$FamilySize+dataB$Age/70)\\n    dataTest \u003c- data.frame(y=as.numeric(as.factor(dataC$Survived)) - 1,x1=dataC$FareAdj/10\\n        ,x2=dataC$FamilySize+dataC$Age/70,PassengerId=dataC$PassengerId)\\n    param \u003c- list(objective   = \\\u0022binary:logistic\\\u0022,\\n              eval_metric = \\\u0022error\\\u0022,\\n              max_depth   = 5,\\n              eta         = 0.1,\\n              gammma      = 0.1,\\n              colsample_bytree = 1,\\n              min_child_weight = 1)\\n    xgb \u003c- xgboost(params  = param,\\n              data    = data.matrix(dataTrain[,c(\u0027x1\u0027,\u0027x2\u0027)]),\\n              label   = dataTrain$y, \\n              nrounds = 500,\\n              silent = 1,\\n              print_every_n = 100,\\n              verbose = 0)\\n    p \u003c- predict(xgb,newdata=data.matrix(dataTest[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\n    dataTest$p \u003c- ifelse(p\u003e=0.90,1,0)\\n    data$Predict[dataTest$PassengerId] \u003c- dataTest$p \\n    sm = sum(abs(as.integer(data$Predict[s2]) - as.integer(data$Survived[s2])))\\n    cv = 1 - sm/length(s2)\\n    #if (i %% 25==0) \\n    #cat(sprintf(\u0027Trial %d has CV = %f\\\\n\u0027,i,cv))\\n    sum = sum + cv\\n}\\ncat(sprintf(\u0027Average CV of %d trials = %f\\\\n\u0027,trials,sum/trials))\\n#accuracy[j,k] \u003c- sum/trials\\n#}\\n#accuracy\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022699fa387f05fb88dc228bc048f4c40b0450202b3\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- CV 정확도는 79.0 %입니다. (위에 표시된 결과는 k 배 CV의 무작위 특성으로 인해 달라질 수 있지만 오프라인에서는 10,000 회의 평가에서 79.0 %를 확인했습니다.) \\n- 성별 모델의 CV 정확도는 78.6 %이므로 약간 개선되었습니다. 다행히도, 이것은 우리가 테스트 데이터 세트에서 적어도 살아남은 성인 남성 1 명을 발견 할 수있게 해줍니다!\\n\\n\\n## Submission to Kaggle\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022scrolled\u0022:false,\u0022_uuid\u0022:\u0022d5aa5fbf16ce8dfb18aa4a57af50a41d375ca373\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022dataB \u003c- data[data$PassengerId %in% 1:891 \u0026 data$Title==\u0027man\u0027,]\\ndataC \u003c- data[data$PassengerId %in% 892:1309 \u0026 data$Title==\u0027man\u0027,]\\ndata$Predict \u003c- 0\\ndata$Predict[data$Sex==\u0027female\u0027] \u003c- 1\\ndataTrain \u003c- data.frame(y=as.numeric(as.factor(dataB$Survived)) - 1,x1=dataB$FareAdj/10,x2=dataB$FamilySize+dataB$Age/70)\\ndataTest \u003c- data.frame(y=as.numeric(as.factor(dataC$Survived)) - 1,x1=dataC$FareAdj/10,Pclass=dataC$Pclass\\n    ,x2=dataC$FamilySize+dataC$Age/70,PassengerId=dataC$PassengerId)\\n\\nparam \u003c- list(objective   = \\\u0022binary:logistic\\\u0022,\\n              eval_metric = \\\u0022error\\\u0022,\\n              max_depth   = 5,\\n              eta         = 0.1,\\n              gammma      = 0.1,\\n              colsample_bytree = 1,\\n              min_child_weight = 1)\\n\\nxgb \u003c- xgboost(params  = param,\\n              data    = data.matrix(dataTrain[,c(\u0027x1\u0027,\u0027x2\u0027)]),\\n              label   = dataTrain$y, \\n              nrounds = 500,\\n              silent = 1,\\n              print_every_n = 100,\\n              verbose = 0)\\n\\np \u003c- predict(xgb,newdata=data.matrix(dataTest[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\ndataTest$p \u003c- ifelse(p\u003e=0.90,1,0)\\ndata$Predict[dataTest$PassengerId] \u003c- dataTest$p \\nmaleLive = which(data$Title==\u0027man\u0027 \u0026 data$Predict==1)\\ncat(sprintf(\u0027The following %d adult males are predicted to live\\\\n\u0027,length(maleLive)))\\ndata[maleLive,c(\u0027PassengerId\u0027,\u0027Pclass\u0027,\u0027Name\u0027,\u0027Age\u0027,\u0027SibSp\u0027,\u0027Parch\u0027,\u0027FareAdj\u0027)]\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022972c374198100eaab09cab8ac1289f5cfed6714f\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022x1s \u003c- seq(2, 5, length.out = 100)\\nx2s \u003c- seq(1, 3, length.out = 100)\\ng \u003c- data.frame(x1 = rep(x1s, each=100), x2 = rep(x2s, time = 100))\\np \u003c- predict(xgb,newdata=data.matrix(g[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\ng$y \u003c- ifelse(p\u003e=0.90,1,0)\\ng1 \u003c- ggplot(data=dataTest[dataTest$x1\u003e2 \u0026 dataTest$x1\u003c5 \u0026 dataTest$x2\u003e1 \u0026 dataTest$x2\u003c3,]) +\\n    xlim(2,5) + ylim(1,3) +\\n    geom_tile(data=g,aes(x1,x2,fill=factor(y))) +\\n    geom_point(size=2,aes(x1,x2,color=factor(p),shape=factor(Pclass))) +\\n    scale_color_manual(values=c(\u0027#666666\u0027,\u0027#0000FF\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    scale_fill_manual(values=c(\u0027#FF9999\u0027,\u0027#99FF99\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    labs(x=\u0027Fare / (10 x TicketFrequency)\u0027,y=\u0027FamilySize + (Age / 70)\u0027,shape=\u0027Pclass\u0027,fill=\u0027Classifier\u0027,\\n        title=\u0027XGBoost classifies the test set.\\n        It predicts 4 adult males have P(live)\u003e=0.9\u0027,color=\u0027Predict\u0027) +\\n    geom_vline(xintercept=2.8, linetype=\u0027dotted\u0027) +\\n    geom_hline(yintercept=c(1.43,2.43), linetype=\u0027dotted\u0027) +\\n    annotate(\u0027text\u0027,x=2.95,y=2.9,label=\u0027Fare = $28\u0027) +\\n    annotate(\u0027text\u0027,x=4.7,y=2.35,label=\u0027Age = 30\u0027) +\\n    annotate(\u0027text\u0027,x=4.7,y=1.35,label=\u0027Age = 30\u0027)\\n\\nfor (i in which(dataTest$p==1)){\\n    g1 \u003c- g1 + annotate(\u0027text\u0027,x=dataTest$x1[i]-0.15,y=dataTest$x2[i],label=dataTest$PassengerId[i]\\n        ,color=\u0027darkblue\u0027,size=4)\\n}\\ng1\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022d51253343dbdd0e4cf55c6789e4629869e389ebd\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022나머지 예측에서는 다음 두 가지 간단한 규칙 (WCG model, woman-child-groups)을 사용합니다.\\n\\n* 모든 여성과 소년이 살고있는 가정의 모든 소년에 대한 생존율 예측.\\n* 모든 여성과 소년이 사망하는 가정의 모든 여성에 대한 사망 예측.\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022b52547199323effbc4ea8c844da7579d1f8854f0\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022# engineer \\\u0022woman-child-groups\\\u0022\\ndata$Surname = substring( data$Name,0,regexpr(\u0027,\u0027,data$Name)-1)\\ndata$GroupId = paste( data$Surname, data$Pclass, sub(\u0027.$\u0027,\u0027X\u0027,data$Ticket), data$Fare, data$Embarked, sep=\u0027-\u0027)\\ndata$GroupId[data$Title==\u0027man\u0027] \u003c- \u0027noGroup\u0027\\n# Mrs Wilkes (Needs) is Mrs Hocking (Needs) sister\\ndata$GroupId[893] \u003c- data$GroupId[775]\\ndata$GroupFreq \u003c- ave(1:1309,data$GroupId,FUN=length)\\ndata$GroupId[data$GroupFreq\u003c=1] \u003c- \u0027noGroup\u0027\\ncat(sprintf(\u0027We found %d woman-child-groups\\\\n\u0027,length(unique(data$GroupId))-1))\\ndata$TicketId = paste( data$Pclass,sub(\u0027.$\u0027,\u0027X\u0027,data$Ticket),data$Fare,data$Embarked,sep=\u0027-\u0027)\\n# add nannies and relatives to groups\\nc = 0\\nfor (i in which(data$Title!=\u0027man\u0027 \u0026 data$GroupId==\u0027noGroup\u0027)){\\n    data$GroupId[i] = data$GroupId[data$TicketId==data$TicketId[i]][1]\\n    if (data$GroupId[i]!=\u0027noGroup\u0027) c = c + 1\\n}\\ncat(sprintf(\u0027We found %d nannies/relatives and added them to groups.\\\\n\u0027,c))\\n# calculate group survival rates\\ndata$GroupSurvival \u003c- NA\\ndata$Survived \u003c- as.numeric(as.character(data$Survived))\\ndata$GroupSurvival[1:891] \u003c- ave(data$Survived[1:891],data$GroupId[1:891])\\nfor (i in 892:1309) data$GroupSurvival[i] \u003c- data$GroupSurvival[which(data$GroupId==data$GroupId[i])[1]]\\n# classify unknown groups\\ndata$GroupSurvival[is.na(data$GroupSurvival) \u0026 data$Pclass==3] \u003c- 0\\ndata$GroupSurvival[is.na(data$GroupSurvival) \u0026 data$Pclass!=3] \u003c- 1\\n# make predictions\\ndata$Predict \u003c- 0\\ndata$Predict[data$Sex==\u0027female\u0027] \u003c- 1\\ndata$Predict[data$Title==\u0027woman\u0027 \u0026 data$GroupSurvival==0] \u003c- 0\\ndata$Predict[data$Title==\u0027boy\u0027 \u0026 data$GroupSurvival==1] \u003c- 1\\nx = which(data$Sex==\u0027male\u0027 \u0026 data$Predict==1 \u0026 data$PassengerId\u003e891)\\ncat(sprintf(\u0027We found %d boys predicted to live\\\\n\u0027,length(x)))\\nx = which(data$Sex==\u0027female\u0027 \u0026 data$Predict==0 \u0026 data$PassengerId\u003e891)\\ncat(sprintf(\u0027We found %d females predicted to die\\\\n\u0027,length(x)))\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022610b70aadbd710768900a2133578c79149a4acb2\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022submit \u003c- data.frame(PassengerId=892:1309,Survived=data$Predict[892:1309])\\nsubmit$Survived[maleLive-891] \u003c- 1\\nwrite.csv(submit,\u0027WCG_XGBoost1.csv\u0027,row.names=F)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002258d691a040537ac7350ced4225aa191d59e03368\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- 성인 남성이 생존할 것으로 예측한 절반이 옳았고 절반은 잘못되었다고 생각됩니다. \\n- WCG 제출과 함께 추가로 4 가지 예언을 통해 WCG 점수가 변경되지는 않았지만 교차 검증을 통해 다음과 같은 결과를 얻을 수 있습니다 . 그러나 우리는 성인 남성 1 ~ 2 명을 발견했습니다.\\n\\n\\n# Explore solo females survival with XGBoost\\n- XGBoost 기술을 솔로 여성에게 적용해 봅시다. 솔로 여성의 생존율을 정확하게 예측할 수 있다면 WCG 모델과 결합하여 가장 정확한 타이타닉 모델을 구할 수 있습니다! \\n- 훈련 데이터 세트에는 304 명의 여성이 포함되어 있습니다. 그 중 108 명이 WCG에, 126 명이 솔로로, 80 명이 동생이나 남편과 함께 여행하며 아이들이 없습니다. 여기에서는 솔로 여성을 탐구 할 것입니다.\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022a13427eb18ee37641580d400b129b310025f9aed\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022# identify WCG females\\nWCGtrain = which(data$Passenger\u003c=891 \u0026 (data$GroupSurvival==0 | data$GroupSurvival==1))\\nWCGtest = which(data$Passenger\u003e891 \u0026 (data$GroupSurvival==0 | data$GroupSurvival==1))\\n# identify solo females\\ndata2 \u003c- data[data$PassengerId\u003c=891 \u0026 data$Title==\u0027woman\u0027 \u0026 data$FamilySize==1,]\\ndata3 \u003c- data.frame(y=data2$Survived,x1=data2$FareAdj/10,x2=data2$Age/15,Pclass=data2$Pclass)\\n# set zoom\\nx1s \u003c- seq(0.5, 1.5, length.out = 100)\\nx2s \u003c- seq(1, 3, length.out = 100)\\ng \u003c- data.frame(x1 = rep(x1s, each=100), x2 = rep(x2s, time = 100))\\n\\ndim(data3)\\nstr(data3)\\n\\n# classify females with XGBoost\\nparam \u003c- list(objective   = \\\u0022binary:logistic\\\u0022,\\n              eval_metric = \\\u0022error\\\u0022,\\n              max_depth   = 5,\\n              eta         = 0.1,\\n              gammma      = 0.1,\\n              colsample_bytree = 1,\\n              min_child_weight = 1)\\ncat(\u0027XGBoosting begun...\\\\n\u0027)\\nxgb \u003c- xgboost(params  = param,\\n               data    = data.matrix(data3[,c(\u0027x1\u0027,\u0027x2\u0027)]),\\n              label   = data3$y, \\n              nrounds = 500,\\n              print_every_n = 100,\\n              verbose = 1)\\np \u003c- predict(xgb,newdata=data.matrix(g[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\ng$y \u003c- ifelse(p\u003c=0.25,0,1)\\n# plot results\\nggplot(data=data3[data3$x1\u003e0.5 \u0026 data3$x1\u003c1.5 \u0026 data3$x2\u003e1 \u0026 data3$x2\u003c3,]) +\\n    xlim(0.5,1.5) + ylim(1,3) +\\n    geom_tile(data=g,aes(x1,x2,fill=factor(y))) +\\n    geom_density_2d(aes(x1,x2,color=factor(y))) +\\n    geom_point(size=2,aes(x1,x2,color=factor(y),shape=factor(Pclass))) +\\n    scale_color_manual(values=c(\u0027#AA0000\u0027,\u0027#00AA00\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    scale_fill_manual(values=c(\u0027#FF9999\u0027,\u0027#99FF99\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    labs(x=\u0027Fare / (10 x TicketFrequency)\u0027,y=\u0027Age / 15\u0027,shape=\u0027Pclass\u0027,fill=\u0027Classify\u0027,\\n        title=\u0027XGBoost learns the training set\\\\\u0027s\\n        126 solo females. Red is P(die)\u003e=0.75\u0027,color=\u0027Survived\u0027) +\\n    geom_vline(xintercept=c(0.8,0.9), linetype=\u0027dotted\u0027) +\\n    annotate(\u0027text\u0027,x=0.77,y=2.95,label=\u0027Fare = $8\u0027) +\\n    annotate(\u0027text\u0027,x=0.93,y=2.95,label=\u0027Fare = $9\u0027) +\\n    geom_hline(yintercept=c(1.33,1.67), linetype=\u0027dotted\u0027) +\\n    annotate(\u0027text\u0027,x=1.35,y=1.61,label=\u0027Age = 25\u0027) +\\n    annotate(\u0027text\u0027,x=1.35,y=1.28,label=\u0027Age = 20\u0027)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00227fb48b4a812bcceff3148760ffdbc3d149e6425f\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- XGBoost에서 훈련 데이터 세트의 솔로 여성 중 생존 패턴을 찾은 것 같습니다! \\n- 위의 그림에서 가장 유망한 솔로 여성은 Pclass = 3, FareAdj = 9, Age = 22입니다. 또는 Pclass = 3, FareAdj = 8, Age = 34입니다. 음영은 XGBoost의 분류 결정은 있습니다. 빨간색 영역은 P(die)\u003e 0.75를 예측하는 XGBoost에 해당합니다.\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00227eb6934e513bdb26148dc579531fc8f76bee9f1c\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022## Grid search and cross validation\\n- 그리드 검색을 사용하여 XGBoost에 대한 최적의 매개 변수가 treeDepth = 5, p \u003c= 0.08임을 알 수 있습니다. 그리드 검색을 수행하려면 아래 코드에서 for 루프의 주석 처리를 제거하고 검색 할 하이퍼 매개 변수를 추가하십시오.이 노트에서는 그리드 검색을 수행하지 않습니다. 이제 XGBoost가 CV = 78.6 % 인 성별 모델보다 더 정확한지 확인하기 위해 교차 유효성 검사를 수행해 봅시다.\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00224fab6ee6b21cf70b2b53ea6f0d3b756ba6739022\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022#accuracy = matrix(nrow=4,ncol=4)\\n#rownames(accuracy) \u003c- c(\u0027d=3\u0027,\u0027d=4\u0027,\u0027d=5\u0027,\u0027d=6\u0027)\\n#colnames(accuracy) \u003c- c(\u00270.08\u0027,\u00270.10\u0027,\u00270.25\u0027,\u00270.50\u0027)\\n#for (j in 1:4)\\n#for (k in 1:4){\\ntrials=100; sum=0\\nfor (i in 1:trials){\\n    s = sample(1:891,800)\\n    s2 = (1:891)[-s]\\n    dataB \u003c- data[data$PassengerId %in% s \u0026 data$Title==\u0027woman\u0027 \u0026 data$FamilySize==1,]\\n    dataC \u003c- data[data$PassengerId %in% s2 \u0026 data$Title==\u0027woman\u0027\u0026 data$FamilySize==1,]\\n    data$Predict \u003c- 0\\n    data$Predict[data$Sex==\u0027female\u0027] \u003c- 1\\n    dataTrain \u003c- data.frame(y=dataB$Survived,x1=dataB$FareAdj/10,x2=dataB$Age/15)\\n    dataTest \u003c- data.frame(y=dataC$Survived,x1=dataC$FareAdj/10\\n        ,x2=dataC$Age/15,PassengerId=dataC$PassengerId)\\n    param \u003c- list(objective   = \\\u0022binary:logistic\\\u0022,\\n              eval_metric = \\\u0022error\\\u0022,\\n              max_depth   = 5,\\n              eta         = 0.1,\\n              gammma      = 0.1,\\n              colsample_bytree = 1,\\n              min_child_weight = 1)\\n    xgb \u003c- xgboost(params  = param,\\n              data    = data.matrix(dataTrain[,c(\u0027x1\u0027,\u0027x2\u0027)]),\\n              label   = dataTrain$y, \\n              nrounds = 500,\\n              silent = 1,\\n              print_every_n = 100,\\n              verbose = 0)\\n    p \u003c- predict(xgb,newdata=data.matrix(dataTest[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\n    dataTest$p \u003c- ifelse(p\u003c=0.08,0,1)\\n    data$Predict[dataTest$PassengerId] \u003c- dataTest$p \\n    sm = sum(abs(data$Predict[s2] - data$Survived[s2]))\\n    cv = 1 - sm/length(s2)\\n    #if (i %% 25==0) \\n    #cat(sprintf(\u0027Trial %d has CV = %f\\\\n\u0027,i,cv))\\n    sum = sum + cv\\n}\\ncat(sprintf(\u0027Average CV of %d trials = %f\\\\n\u0027,trials,sum/trials))\\n#accuracy[j,k] \u003c- sum/trials\\n#}\\n#accuracy\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022ccf503c30530b6fbc6bf74b0698e9ee91918205a\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022- CV 정확도는 79.0 %입니다. (위에 표시된 결과는 k 배 CV의 무작위 특성으로 인해 달라질 수 있지만 오프라인에서는 10,000 회의 평가에서 79.0 %를 확인했습니다.) 성별 모델의 CV 정확도는 78.6 %이므로 약간 개선되었습니다. 바라건대, 우리는 공개 점수에도 약간의 개선을 이룰 수 있습니다. 어디 보자.\\n\\n\\n## Submission to Kaggle\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u0022111b732164fb2b525ed1b2788ab69438815ccce0\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022dataB \u003c- data[data$PassengerId %in% 1:891 \u0026 data$Title==\u0027woman\u0027 \u0026 data$FamilySize==1,]\\ndataC \u003c- data[data$PassengerId %in% 892:1309 \u0026 data$Title==\u0027woman\u0027 \u0026 data$FamilySize==1 \\n    \u0026 !data$PassengerId %in% WCGtest,]\\ndata$Predict \u003c- 0\\ndata$Predict[data$Sex==\u0027female\u0027] \u003c- 1\\ndataTrain \u003c- data.frame(y=dataB$Survived,x1=dataB$FareAdj/10,x2=dataB$Age/15)\\ndataTest \u003c- data.frame(y=dataC$Survived,x1=dataC$FareAdj/10\\n    ,x2=dataC$Age/15,PassengerId=dataC$PassengerId,Pclass=dataC$Pclass)\\nparam \u003c- list(objective   = \\\u0022binary:logistic\\\u0022,\\n              eval_metric = \\\u0022error\\\u0022,\\n              max_depth   = 5,\\n              eta         = 0.1,\\n              gammma      = 0.1,\\n              colsample_bytree = 1,\\n              min_child_weight = 1)\\nxgb \u003c- xgboost(params  = param,\\n              data    = data.matrix(dataTrain[,c(\u0027x1\u0027,\u0027x2\u0027)]),\\n              label   = dataTrain$y, \\n              nrounds = 500,\\n              silent = 1,\\n              print_every_n = 100,\\n              verbose = 0)\\np \u003c- predict(xgb,newdata=data.matrix(dataTest[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\ndataTest$p \u003c- ifelse(p\u003c=0.08,0,1)\\ndata$Predict[dataTest$PassengerId] \u003c- dataTest$p \\nfemalePerish = which(data$Title==\u0027woman\u0027 \u0026 data$Predict==0)\\ncat(sprintf(\u0027The following %d females are predicted to die\\\\n\u0027,length(femalePerish)))\\ndata[femalePerish,c(\u0027PassengerId\u0027,\u0027Pclass\u0027,\u0027Name\u0027,\u0027Age\u0027,\u0027SibSp\u0027,\u0027Parch\u0027,\u0027FareAdj\u0027)]\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00223508715bb323bac2a811f0e656b0e5d1972ff98a\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022x1s \u003c- seq(0.6, 1, length.out = 100)\\nx2s \u003c- seq(1, 3, length.out = 100)\\ng \u003c- data.frame(x1 = rep(x1s, each=100), x2 = rep(x2s, time = 100))\\np \u003c- predict(xgb,newdata=data.matrix(g[,c(\u0027x1\u0027,\u0027x2\u0027)]))\\ng$y \u003c- ifelse(p\u003c=0.08,0,1)\\ng1 \u003c- ggplot(data=dataTest[dataTest$x1\u003c1 \u0026 dataTest$x2\u003c3,]) +\\n    xlim(0.6,1) + ylim(1,3) +\\n    geom_tile(data=g,aes(x1,x2,fill=factor(y))) +\\n    geom_point(size=2,aes(x1,x2,color=factor(p),shape=factor(Pclass))) +\\n    scale_color_manual(values=c(\u0027#0000FF\u0027,\u0027#666666\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    scale_fill_manual(values=c(\u0027#FF9999\u0027,\u0027#99FF99\u0027),\\n        limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n    labs(x=\u0027Fare / (10 x TicketFrequency)\u0027,y=\u0027Age / 15\u0027,shape=\u0027Pclass\u0027,fill=\u0027Classifier\u0027,\\n        title=\u0027XGBoost classifies the test set.\\n        It predicts 10 non-WCG females have P(die)\u003e=0.92\u0027,color=\u0027Predict\u0027) +\\n    geom_vline(xintercept=c(0.8,0.9), linetype=\u0027dotted\u0027) +\\n    geom_hline(yintercept=c(1.33,1.67), linetype=\u0027dotted\u0027) +\\n    annotate(\u0027text\u0027,x=0.8,y=2.95,label=\u0027Fare = $8\u0027) +\\n    annotate(\u0027text\u0027,x=0.9,y=2.95,label=\u0027Fare = $9\u0027) +\\n    annotate(\u0027text\u0027,x=0.65,y=1.61,label=\u0027Age = 25\u0027) +\\n    annotate(\u0027text\u0027,x=0.65,y=1.28,label=\u0027Age = 20\u0027)\\n# plot passenger numbers\\nv = c(0.07,0.02,0.02,0.02,-0.04,0.02,0.02,0.02,0.02,0.02); c = 0\\nfor (i in which(dataTest$p==0)){\\n    c = c + 1;\\n    g1 \u003c- g1 + annotate(\u0027text\u0027,x=dataTest$x1[i]+0.015,y=dataTest$x2[i]+v[c],label=dataTest$PassengerId[i]\\n        ,color=\u0027darkblue\u0027,size=3)\\n}\\ng1\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022trusted\u0022:true,\u0022_uuid\u0022:\u00229f3beb2366557e7e3f15a40529a98e016677da30\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022submit$Survived[femalePerish-891] \u003c- 0\\nwrite.csv(submit,\u0027WCG_XGBoost2.csv\u0027,row.names=F)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00225b1e323c6ceadce25dbacfb4924eb4e6ab69ead3\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022![result-female](http://playagricola.com/Kaggle/surnameModel5.png)\\n\\n- 굉장해! 대부분의 여성들의 예측이 옳았다. 우리 점수는 83.3 %에서 84.7 %로 증가했습니다 !! 이것은 우리의 10 가지 여성 예측 중 80 %가 정확하고 좋았음을 의미합니다. 와우, 우리는 이제까지 가장 정확한 타이탄 모델을 가지고 있습니다!\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022813546fa6fef9686024c8faa82e4b594bffa30ca\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022## Comparison with CART, kNN, SVM, Random Forest\\n\\n- 아래는 Pclass = 3 (60 명의 여성)으로 제한된 솔로 여성을 다양한 방법으로 분류하는 방법을 보여줍니다. CART, kNN 및 SVM 교차 검증은 78.9 % 및 랜덤포레스트 78.7 %입니다. \\n- 네 가지 모델은 WCG에서 16, 16, 6,  9 솔로 여성에 대해서 예측을 변경하고 83.8 %, 83.3 %, 83.3 % 및 84.2 %의 점수를 각각 획득합니다. (WCG는 그 자체로 83.3 %를 얻습니다.) \\n- Random Forest에 의해 생성 된 영역은 위의 XGBoost와 가장 유사합니다. 그리고 가장 비슷한 점수를 얻습니다. CART는 매우 읽기 쉽기 때문에 좋습니다. CART는 P class = 3의 솔로 여학생이 FareAdj \u003e $8 or Age \u003e 25 로 사망한다고 말합니다. 이 패턴은 학습 데이터 세트에 있습니다. 이 조건들을 충만한 22 명의 여성 중 64 % = 14/22 명이 사망합니다.\\n\u0022},{\u0022metadata\u0022:{\u0022_kg_hide-input\u0022:true,\u0022trusted\u0022:true,\u0022_uuid\u0022:\u002298c26b4f688106d323285ff411723ed1ee1e8ff2\u0022},\u0022cell_type\u0022:\u0022code\u0022,\u0022source\u0022:\u0022g = list(); gp = list()\\ngt = c(\u0027CART learns the training set\u0027,\u0027kNN k=5 learns the training set\u0027\\n       ,\u0027SVM with radial kernel\u0027,\u0027Random Forest with P(die)\u003e0.75\u0027)\\ndata2 \u003c- data[data$PassengerId\u003c=891 \u0026 data$Title==\u0027woman\u0027 \u0026 data$FamilySize==1 \u0026 data$Pclass==3,]\\ndata3 \u003c- data.frame(y=data2$Survived,x1=data2$FareAdj/10,x2=data2$Age/15)\\n# set zoom\\nx1s \u003c- seq(0.6, 1, length.out = 50)\\nx2s \u003c- seq(1, 3, length.out = 50)\\nfor (i in 1:4){\\n    g[[i]] \u003c- data.frame(x1 = rep(x1s, each=100), x2 = rep(x2s, time = 100))\\n    if (i==1){\\n        fit \u003c- rpart(factor(y) ~ x1 + x2,data3)\\n        p \u003c- predict(fit,newdata=g[[i]])[,2]\\n        g[[i]]$y \u003c- ifelse(p\u003c=0.5,0,1)\\n    } else if (i==2){\\n        fit \u003c- knn3(factor(y) ~ x1 + x2,data3,k=3)\\n        p \u003c- predict(fit,newdata=g[[i]])[,2]\\n        g[[i]]$y \u003c- ifelse(p\u003c=0.5,0,1)\\n    } else if (i==3){\\n        fit \u003c- svm(factor(y)~ x1 + x2,data3,kernel=\u0027radial\u0027)\\n        p \u003c- predict(fit,newdata=g[[i]])\\n        g[[i]]$y \u003c- as.numeric(as.character(p))\\n    } else if (i==4){\\n        fit \u003c- randomForest(factor(y) ~ x1 + x2,data3)\\n        p \u003c- predict(fit,newdata=g[[i]],type=\u0027prob\u0027)[,2]\\n        g[[i]]$y \u003c- ifelse(p\u003c=0.25,0,1)\\n    }\\n    # plot results\\n    gp[[i]] \u003c- ggplot(data=data3[data3$x1\u003e0.6 \u0026 data3$x1\u003c1 \u0026 data3$x2\u003e1 \u0026 data3$x2\u003c3,]) +\\n        xlim(0.6,1) + ylim(1,3) +\\n        geom_tile(data=g[[i]],aes(x1,x2,fill=factor(y)),show.legend=F) +\\n        geom_point(size=1.5,aes(x1,x2,color=factor(y)),show.legend=F) +\\n        scale_color_manual(values=c(\u0027#AA0000\u0027,\u0027#00AA00\u0027),\\n            limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n        scale_fill_manual(values=c(\u0027#FF9999\u0027,\u0027#99FF99\u0027),\\n            limits=c(\u00270\u0027,\u00271\u0027),labels=c(\u00270\u0027,\u00271\u0027)) +\\n        #labs(x=\u0027Fare / (10 x TicketFrequency)\u0027,y=\u0027Age / 15\u0027,fill=\u0027Classify\u0027,\\n        labs(x=\u0027\u0027,y=\u0027\u0027,title=gt[i],color=\u0027Survived\u0027) +\\n        geom_vline(xintercept=c(0.8,0.9), linetype=\u0027dotted\u0027) +\\n        geom_hline(yintercept=c(1.33,1.67), linetype=\u0027dotted\u0027)\\n}\\ngrid.arrange(gp[[1]],gp[[2]],gp[[3]],gp[[4]],nrow=2)\u0022,\u0022execution_count\u0022:null,\u0022outputs\u0022:[]},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u0022bc9d7c9a5aba8ee3931ac68dcc13322359bde0ca\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022# Conclusion\\n\\n- 해당 튜토리얼 노트는 성인 남성의 생존을 예측하는 것이 매우 어렵다는 것을 보여주었습니다. \\n- 위의 분석에서, 훈련 데이터에서 성인 남성 생존 패턴이 있는 것으로 보인다. 그러나 이러한 패턴은 테스트 데이터 집합으로 이어지지는 않습니다. \\n    - 저는 성인 남성이 Pclass, Age, Family Size 및 Fare만으로도 생존 할 수 있다고 예측할 수는 없다고 생각합니다. 훈련 세트가 당신을 속일 수 있다고 생각하게 만듭니다. 남성의 생존을 예측하려면 기능을 설계해야 합니다.\\n\\n- 여성에 관해서는 예측이 더 성공적입니다. WCG 모델 자체만으로도 많은 여성들을 발견되지만,해당 커널은 non-WCG 여성들간에 여전히 패턴이 있음을 보여줍니다. \\n    - 예를 들어, 훈련 세트에는 Pclass = 3 인 6 명의 독신 여행 여성이 있고, $ 8 ~ $ 9 사이의 FareAdj, 20 ~ 25 세의 여성이 있습니다.이 여성 6 명 모두 사망했습니다. 그게 하나의 패턴입니다. \\n    - Pclass, Age, Family Size 및 Fare를 사용하여 우리는 여성 모델이 성공할 것이라고 예측할 수 있다는 것을 보여주었습니다. 우리는 또한 FareAdj가 8 세 근처에 있고 34 세 근처에있는 여성이 멸망 할 가능성이 있음을 발견했습니다.\\n\\n- 우리는 85 %보다 잘 할 수 있습니까? WCG 모델은 84.4 %의 CV와 83.3 %의 점수를 견고하게 달성 할 수 있습니다. 이 커널은 데이터에 더 많은 패턴이 있고 Mega Model의 앙상블이 데이터에 더 많은 패턴이 있음을 보여 줬습니다. 여기 XGBoost가 메가 모델의 앙상블보다 다른 여성을 찾았다는 것은 고무적입니다. \\n    - 이는 단일 모델이 아직 모든 non WCG 여성을 분류하지 못했다는 것을 의미합니다. 모든 사람들이 WCG가 아닌 승객을 위해 분류기를 직접 만들어이 커널을 포크하고 개선 할 것을 권장합니다. (참고 :이 커널을 포크하는 경우 설정에서 GPU를 켜십시오)\\n\\nXGBoost에 대해 더 자세히 알고 싶다면 Tae Hyon Whang의 XGBoost, 173/209 LB가있는 Titanic Starter라고 불리는 위대한 Python 커널을 확인하십시오.\\nTo learn more about XGBoost, check out [Tae Hyon Whang\u0027s][1] great Python kernel called [Titanic Starter with XGBoost, 173/209 LB][2].  \\n  \\n[1]:https://www.kaggle.com/numbersareuseful\\n[2]:https://www.kaggle.com/numbersareuseful/titanic-starter-with-xgboost-173-209-lb\\n\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u002214d091833121a4d676b3d5d0ba42ab0eb2148eec\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022# Summary of Titanic models\\n Here\u0027s a review of this notebook and my previous two. First the population was divided into 5 groups:  \\n* (A) Males adults - 61% of population  \\n* (B) Males boys (Master title) - 5% of population  \\n* (C) Females that have children, sisters, or mothers (brothers, husbands optional) - 12%\\n* (D) Females that have brothers, or husbands (no children, no sisters, no mothers) - 8%  \\n* (E) Females traveling alone - 14% of population  \\n  \\nNext we built 3 classifiers:    \\n* (1) [WCG classifies B+C][1]  \\n* (2) [Ensemble of top 5 Kaggle classifies A+D+E][1]  \\n* (3) [XGBoost classifies E][2]  \\n  \\nFinally we assembled 4 models. Here are cross validations and public scores:  \\n* WCG + GenderModel = 84.4% CV and 83.3% PS  \\n* WCG + Ensemble = unknown CV and 84.2% PS  \\n* WCG + XGBoost + GenderModel = 85.2% CV and 84.7% PS  \\n* WCG + XGBoost + Ensemble = unknown CV and 85.2% PS  \\n\\nThank you for reading my notebook #3! I hope you enjoyed it. Check out notebooks [#1][3] and [#2][1]. Feel free to use my classifiers, improve them, add your own, and assemble new models. I believe it is possible to increase CV and PS above 85%. Good luck! (_NOTE: if you fork this kernel, turn on GPU under settings_)  \\n  \\n[1]:https://www.kaggle.com/cdeotte/titantic-mega-model-0-84210\\n[2]:https://www.kaggle.com/cdeotte/titanic-wcg-xgboost-0-84688\\n[3]:https://www.kaggle.com/cdeotte/titanic-using-name-only-0-81818\u0022},{\u0022metadata\u0022:{\u0022_uuid\u0022:\u00226af53ed5b639b9e8c6ed594f34de1e78219d363b\u0022},\u0022cell_type\u0022:\u0022markdown\u0022,\u0022source\u0022:\u0022![hist](http://playagricola.com/Kaggle/histXGB.png)\u0022}],\u0022metadata\u0022:{\u0022kernelspec\u0022:{\u0022display_name\u0022:\u0022R\u0022,\u0022language\u0022:\u0022R\u0022,\u0022name\u0022:\u0022ir\u0022},\u0022language_info\u0022:{\u0022mimetype\u0022:\u0022text/x-r-source\u0022,\u0022name\u0022:\u0022R\u0022,\u0022pygments_lexer\u0022:\u0022r\u0022,\u0022version\u0022:\u00223.4.2\u0022,\u0022file_extension\u0022:\u0022.r\u0022,\u0022codemirror_mode\u0022:\u0022r\u0022}},\u0022nbformat\u0022:4,\u0022nbformat_minor\u0022:1}","dateCreated":"2018-11-22T03:40:53.3335614Z"},"resources":null,"isolatorResults":"\u003cresults\u003e\u003cdisk_kb_free\u003e4818736\u003c/disk_kb_free\u003e\u003cdocker_image_digest\u003eb5593d14878d872ba153e463c39e01750c916862d9bf5a572ddf5234ece009b0\u003c/docker_image_digest\u003e\u003cdocker_image_id\u003esha256:44f873c106e586a747e1f2a3f2fcb4f6827ba48b41ecd862601742984907ff5c\u003c/docker_image_id\u003e\u003cdocker_image_name\u003egcr.io/kaggle-private-byod/rstats\u003c/docker_image_name\u003e\u003cexit_code\u003e0\u003c/exit_code\u003e\u003cfailure_message /\u003e\u003cinvalid_path_errors\u003eFalse\u003c/invalid_path_errors\u003e\u003cout_of_memory\u003eFalse\u003c/out_of_memory\u003e\u003crun_time_seconds\u003e111.771542802002\u003c/run_time_seconds\u003e\u003csucceeded\u003eTrue\u003c/succeeded\u003e\u003ctimeout_exceeded\u003eFalse\u003c/timeout_exceeded\u003e\u003cused_all_space\u003eFalse\u003c/used_all_space\u003e\u003cwas_killed\u003eFalse\u003c/was_killed\u003e\u003c/results\u003e","runInfo":{"dockerfileUrl":"https://github.com/Kaggle/docker-rstats/blob/master/Dockerfile","dockerHubUrl":"https://registry.hub.docker.com/u/kaggle/rstats/","dockerImageDigest":"b5593d14878d872ba153e463c39e01750c916862d9bf5a572ddf5234ece009b0","dockerImageId":"sha256:44f873c106e586a747e1f2a3f2fcb4f6827ba48b41ecd862601742984907ff5c","dockerImageName":"/rstats","diskKbFree":4818736,"failureMessage":"","exitCode":0,"queuedSeconds":0,"outputSizeBytes":0,"runTimeSeconds":111.771542802002,"usedAllSpace":false,"timeoutExceeded":false,"isValidStatus":false,"wasGpuEnabled":false,"wasInternetEnabled":false,"outOfMemory":false,"invalidPathErrors":false,"succeeded":true,"wasKilled":false},"outputFilesTotalSizeBytes":2080711,"dockerImageVersionId":454,"usedCustomDockerImage":false},"author":{"id":136508,"displayName":"이상열","email":null,"editedEmail":null,"editedEmailCode":null,"userName":"syleeie","thumbnailUrl":"https://storage.googleapis.com/kaggle-avatars/thumbnails/136508-fb.jpg","profileUrl":"/syleeie","registerDate":"0001-01-01T00:00:00Z","lastVisitDate":"0001-01-01T00:00:00Z","statusId":0,"performanceTier":0,"userRoles":null,"userLogins":null,"groupIds":null,"duplicateUsers":null,"hasPhoneVerifications":false,"failedNerdchas":0,"hasPendingNerdcha":false,"deleteRequests":null,"userAttributes":null,"isAdmin":false,"isTvc":false,"isKaggleBot":false,"isAdminOrTvc":false,"isAnonymous":false,"canAct":false,"canBeSeen":false,"thumbnailName":null,"activationCode":"00000000-0000-0000-0000-000000000000","isPhoneVerified":false},"baseUrl":"/syleeie/jetbrain-day-kr-2018-titanic-prediction","collaborators":{"owner":{"userId":136508,"groupId":null,"groupMemberCount":null,"profileUrl":"/syleeie","thumbnailUrl":"https://storage.googleapis.com/kaggle-avatars/thumbnails/136508-fb.jpg","name":"이상열","slug":"syleeie","userTier":0,"joinDate":null,"type":"owner","isUser":true,"isGroup":false},"collaborators":[]},"initialTab":null,"log":"[{\n  \u0022data\u0022: \u0022[NbConvertApp] Converting notebook script.irnb to html\\n\u0022,\n  \u0022stream_name\u0022: \u0022stderr\u0022,\n  \u0022time\u0022: 4.4556220329977805\n},{\n  \u0022data\u0022: \u0022[NbConvertApp] Executing notebook with kernel: ir\\n\u0022,\n  \u0022stream_name\u0022: \u0022stderr\u0022,\n  \u0022time\u0022: 4.6698768440001\n},{\n  \u0022data\u0022: \u0022/usr/local/lib/python2.7/dist-packages/nbconvert/filters/datatypefilter.py:41: UserWarning: Your element with mimetype(s) [] is not able to be represented.\\n  mimetypes=output.keys())\\n\u0022,\n  \u0022stream_name\u0022: \u0022stderr\u0022,\n  \u0022time\u0022: 111.2413327840004\n},{\n  \u0022data\u0022: \u0022[NbConvertApp] Support files will be in __results___files/\\n[NbConvertApp] Making directory __results___files\\n\u0022,\n  \u0022stream_name\u0022: \u0022stderr\u0022,\n  \u0022time\u0022: 111.42239314199833\n},{\n  \u0022data\u0022: \u0022[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n\u0022,\n  \u0022stream_name\u0022: \u0022stderr\u0022,\n  \u0022time\u0022: 111.42659175899826\n},{\n  \u0022data\u0022: \u0022[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Making directory __results___files\\n[NbConvertApp] Writing 528648 bytes to __results__.html\\n\u0022,\n  \u0022stream_name\u0022: \u0022stderr\u0022,\n  \u0022time\u0022: 111.4328820419978\n}]","outputFiles":[{"ownerInfo":null,"kernelVersionOutputFileId":18687755,"kernelVersionId":7632756,"kernelId":2141451,"size":0,"fullPath":"genderSurnameModel2.csv","previewUrl":"/kernels/preview.json/7632756/653308c2-2a6e-34ec-6c8d-a2fa3ac9308e/genderSurnameModel2.csv","downloadUrl":"https://www.kaggleusercontent.com/kf/7632756/eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..p8tG0LkkIh199_mxnjt2Bg.xFmg68kEKhSecaDY-nkJmWtmPGzIcUqrLD83tjLdAwVrEB14SzrHpSEG3bW7nRqE0BYB17kioVMG2NEmleiIwHcCTmOvb5I6_Xxa1j2FeZtQxEjAVT8Z3k0kArw40gwfHb6gYQYfNfLd-K7of9UQj8RxqvvyIky7DaaSBs9y4hs.0lizVEDMv_aSiW2iSl9tuw/genderSurnameModel2.csv","fileType":".csv","contentLength":2843,"contentType":null,"contentMD5":null,"validationErrors":null,"type":"kernelOutputFile","collapsed":false,"info":{"metrics":null,"archiveInfo":null,"archiveInfoV2":null,"blobFileInfo":null,"convertCsvInfo":null,"kernelReference":null},"settings":{"csvSettings":null,"bigQuerySettings":null,"bigQueryMirrorSettings":null,"storageSettings":null,"remoteUrlSettings":null,"remoteGithubSettings":null},"render":null,"children":[],"name":"genderSurnameModel2.csv","description":null},{"ownerInfo":null,"kernelVersionOutputFileId":18687763,"kernelVersionId":7632756,"kernelId":2141451,"size":0,"fullPath":"WCG_XGBoost2.csv","previewUrl":"/kernels/preview.json/7632756/653308c2-2a6e-34ec-6c8d-a2fa3ac9308e/WCG_XGBoost2.csv","downloadUrl":"https://www.kaggleusercontent.com/kf/7632756/eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..bhqilPosoVtrXn_WeOevGg.McJOzqeZmVn2FiI2HeLtoIE9IKyEc4mKSg4XmpBiCyHIVo9dyAt7Zh6I7dn-3_JxD0P8qtmGXt9Wbzkt7a1hdg8qgJ-HQkif4L9v5WYYQFn97X_rwHg_En1hIU_FW3cZ4RLPuihPRFX6yR8xaYh0gT83AX4GS6cTf0HMKynfjzo.mKFfG90oWUJ0U6xjJDGQBA/WCG_XGBoost2.csv","fileType":".csv","contentLength":2843,"contentType":null,"contentMD5":null,"validationErrors":null,"type":"kernelOutputFile","collapsed":false,"info":{"metrics":null,"archiveInfo":null,"archiveInfoV2":null,"blobFileInfo":null,"convertCsvInfo":null,"kernelReference":null},"settings":{"csvSettings":null,"bigQuerySettings":null,"bigQueryMirrorSettings":null,"storageSettings":null,"remoteUrlSettings":null,"remoteGithubSettings":null},"render":null,"children":[],"name":"WCG_XGBoost2.csv","description":null},{"ownerInfo":null,"kernelVersionOutputFileId":18687764,"kernelVersionId":7632756,"kernelId":2141451,"size":0,"fullPath":"WCG_XGBoost1.csv","previewUrl":"/kernels/preview.json/7632756/653308c2-2a6e-34ec-6c8d-a2fa3ac9308e/WCG_XGBoost1.csv","downloadUrl":"https://www.kaggleusercontent.com/kf/7632756/eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..GjjO005DwqZVPAVsA1_m3g.O-reQjrcON3cK_LZWQxaQbQpFoLY6GF-vgBvkkigu3DNMj1zeRC91oWDE3Wim6yTjA1gZP-n5JlydEuRF0D_QRyad8dwhpNTpax5d6RrnARCFlNemTQ4ZmBLNgi1LIy3fM6sm7ilNgFnMZQDVOJneMBAdI5p_6z9GV6lEMVKc58.CwooEGyVn_Zc9GzcpOV9hA/WCG_XGBoost1.csv","fileType":".csv","contentLength":2843,"contentType":null,"contentMD5":null,"validationErrors":null,"type":"kernelOutputFile","collapsed":false,"info":{"metrics":null,"archiveInfo":null,"archiveInfoV2":null,"blobFileInfo":null,"convertCsvInfo":null,"kernelReference":null},"settings":{"csvSettings":null,"bigQuerySettings":null,"bigQueryMirrorSettings":null,"storageSettings":null,"remoteUrlSettings":null,"remoteGithubSettings":null},"render":null,"children":[],"name":"WCG_XGBoost1.csv","description":null},{"ownerInfo":null,"kernelVersionOutputFileId":18687765,"kernelVersionId":7632756,"kernelId":2141451,"size":0,"fullPath":"Rplot001.png","previewUrl":"/kernels/preview.json/7632756/653308c2-2a6e-34ec-6c8d-a2fa3ac9308e/Rplot001.png","downloadUrl":"https://www.kaggleusercontent.com/kf/7632756/eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..6_t6q-n-ATSKKPUyjgfq5w.YSptjHCyHcZExyIo1KvZh9arxENNx7aStYfAUHdY71B4ClkUunE-wrWVfcCTwA4voX2V7RivleFwOrIwN6opWAIO_8t6jSwh-02LTb2BCXN2hwZyjNrSAyu-cKr1tpwBeOPbgrZaYGD4E5Z454Zu_77kpvnzmV1lfyl3T9fNvj8.VsZBJP98Bcoay0xe40WYDw/Rplot001.png","fileType":".png","contentLength":47269,"contentType":null,"contentMD5":null,"validationErrors":null,"type":"kernelOutputFile","collapsed":false,"info":{"metrics":null,"archiveInfo":null,"archiveInfoV2":null,"blobFileInfo":null,"convertCsvInfo":null,"kernelReference":null},"settings":{"csvSettings":null,"bigQuerySettings":null,"bigQueryMirrorSettings":null,"storageSettings":null,"remoteUrlSettings":null,"remoteGithubSettings":null},"render":null,"children":[],"name":"Rplot001.png","description":null}],"outputFilesCropped":false,"ouputFilesOwnerInfo":{"databundleVersionId":0,"dataset":null,"competition":null,"kernel":{"kernelId":2141451,"kernelVersionId":7632756,"dataviewToken":"eyJhbGciOiJkaXIiLCJlbmMiOiJBMTI4Q0JDLUhTMjU2In0..8T3ixxFn3SnYRKBrvBl-YQ.XJNID0Vd18flibsv74VZpuR33Px93q72q7u4vtut7FbejfSeSxCfjMRMWKh4voyPV1V10cSrfYY2e_B4d9ZmZPZZ-qsu_eRQTkr2nZlKej2rSqAeik8gBzQhocpfFbPDYo6SCy_pct1x-0x7dvlApXiuDzxY_wfvu37rxYsRHwicYJ7MFqKycUj-P6aKCQ6stxnlF0RYMI84STbizEAREk8xQvAwAbaIG5GgIjsA14A8c5l5G9sRkEt6RBtSDJOuidpbagzAJaejJjlHGNsQ92c0GYETWiNk5BEJod542RvJTenQ6PPidWyMNGoj-8eg9WqI1rhb0oziOeU4b0kc3SvUkpUG9Q2G_Vt4Z9w2Rpbwot2T93rPq2JfDI8uv_emrG48VQTlmODqgZr-96QKKmsSIxPbxIqpwcDxL2WcHI_ySrB7aL7TE_vjymmL1XYW5m8Tb8tEtHIs5lyUQl5saTPeYRKHGnGvzgVHlxobJhqRDOi4jDKe_ZvtAHANqYkAZRO6LNrFMsVkODkNTODe2GGX6oPAJKTq7hAT9gGfL-vWGJOmXFPzA7183rZP0MgKkD2EmnnmQnxcn9PwHs4SnzC9uBM0CMt7dzNC2Qf671Oqs0dK7dF8V0YdXz-hAzJibFl7c9ZjEL-ra_48Px13Yy2ca88lVt1zbYSiqLuhLiuRs3lCubxBUvdoNh_EGi9dgiFxyHhhSvdPp8WEmeyFDg.c7CqX7nv9RvBGbwVF2l-lw","scope":"syleeie/jetbrain-day-kr-2018-titanic-prediction"},"previewsDisabled":false},"pageMessages":[],"dataSources":[{"imageUrl":"/static/images/dataset-deletion-icon@2x.png","sourceUrl":null,"slug":"top-6-titanic-model","lastUpdated":null,"overview":null,"sourceType":"dataset","sourceVersionType":"fileset","sourceId":38352,"sourceVersionNumber":0,"maxVersionNumber":1,"descriptionMimeType":null,"deleted":false,"private":true,"privateButVisible":false,"ownerInfo":null,"type":"dataSource","collapsed":false,"info":{"metrics":null,"archiveInfo":null,"archiveInfoV2":null,"blobFileInfo":null,"convertCsvInfo":null,"kernelReference":null},"settings":{"csvSettings":null,"bigQuerySettings":null,"bigQueryMirrorSettings":null,"storageSettings":null,"remoteUrlSettings":null,"remoteGithubSettings":null},"render":null,"children":[],"name":"[Private Dataset]","description":""},{"imageUrl":"/static/images/dataset-deletion-icon@2x.png","sourceUrl":null,"slug":"top-6-titanic","lastUpdated":null,"overview":null,"sourceType":"dataset","sourceVersionType":"fileset","sourceId":184856,"sourceVersionNumber":0,"maxVersionNumber":1,"descriptionMimeType":null,"deleted":false,"private":true,"privateButVisible":false,"ownerInfo":null,"type":"dataSource","collapsed":false,"info":{"metrics":null,"archiveInfo":null,"archiveInfoV2":null,"blobFileInfo":null,"convertCsvInfo":null,"kernelReference":null},"settings":{"csvSettings":null,"bigQuerySettings":null,"bigQueryMirrorSettings":null,"storageSettings":null,"remoteUrlSettings":null,"remoteGithubSettings":null},"render":null,"children":[],"name":"[Private Dataset]","description":""},{"imageUrl":"https://storage.googleapis.com/kaggle-competitions/kaggle/3136/logos/thumb76_76.png","sourceUrl":"/c/titanic","slug":"titanic","lastUpdated":"2012-09-28T21:13:33.55Z","overview":"Start here! Predict survival on the Titanic and get familiar with ML basics","sourceType":"competition","sourceVersionType":null,"sourceId":3136,"sourceVersionNumber":null,"maxVersionNumber":null,"descriptionMimeType":"text/html","deleted":false,"private":false,"privateButVisible":false,"ownerInfo":{"databundleVersionId":26502,"dataset":null,"competition":{"competitionId":3136,"dataviewToken":null,"scope":"c/titanic"},"kernel":null,"previewsDisabled":true},"type":"dataSource","collapsed":false,"info":{"metrics":null,"archiveInfo":null,"archiveInfoV2":null,"blobFileInfo":null,"convertCsvInfo":null,"kernelReference":null},"settings":{"csvSettings":null,"bigQuerySettings":null,"bigQueryMirrorSettings":null,"storageSettings":null,"remoteUrlSettings":null,"remoteGithubSettings":null},"render":null,"children":[{"id":63842,"blobFileId":37991,"databundleVersionId":26502,"databundleVersionObjectType":"file","url":null,"relativePath":"../input/gender_submission.csv","creationDate":"2017-02-01T01:49:18Z","isDummy":false,"size":3258,"fullPath":"../input/titanic/gender_submission.csv","previewUrl":"kernels/competition-preview/3136?relativePath=gender_submission.csv","downloadUrl":"/c/titanic/download/gender_submission.csv","fileType":".csv","contentLength":3258,"contentType":"text/csv","contentMD5":"MNEHO5ZKXYFUMexgOg3jUw==","validationErrors":null,"type":"databundleVersionObject","collapsed":false,"info":{"metrics":{"tableMetrics":{"exception":null,"rowCount":418},"columnMetrics":[]},"archiveInfo":null,"archiveInfoV2":null,"blobFileInfo":null,"convertCsvInfo":null,"kernelReference":null},"settings":{"csvSettings":{"delimiter":",","includesHeader":true},"bigQuerySettings":null,"bigQueryMirrorSettings":null,"storageSettings":null,"remoteUrlSettings":null,"remoteGithubSettings":null},"render":null,"children":[{"columns":[{"order":0,"originalType":"","type":"string","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"PassengerId","description":"892\n893\n894\n895\n896\n897\n898\n899\n900\n901\n902\n903\n904\n905\n906\n907\n908\n909\n910\n911\n912\n913\n914\n915\n916\n917\n918\n919\n920\n921\n922\n923\n924\n925\n926\n927\n928\n929\n930\n931\n932\n933\n934\n935\n936\n937\n938\n939\n940\n941\n942\n943\n944\n945\n946\n947\n948\n949\n950\n951\n952\n953\n954\n955\n956\n957\n958\n959\n960\n961\n962\n963\n964\n965\n966\n967\n968\n969\n970\n971\n972\n973\n974\n975\n976\n977\n978\n979\n980\n981\n982\n983\n984\n985\n986\n987\n988\n989\n990\n991\n992\n993\n994\n995\n996\n997\n998\n999\n1000\n1001\n1002\n1003\n1004\n1005\n1006\n1007\n1008\n1009\n1010\n1011\n1012\n1013\n1014\n1015\n1016\n1017\n1018\n1019\n1020\n1021\n1022\n1023\n1024\n1025\n1026\n1027\n1028\n1029\n1030\n1031\n1032\n1033\n1034\n1035\n1036\n1037\n1038\n1039\n1040\n1041\n1042\n1043\n1044\n1045\n1046\n1047\n1048\n1049\n1050\n1051\n1052\n1053\n1054\n1055\n1056\n1057\n1058\n1059\n1060\n1061\n1062\n1063\n1064\n1065\n1066\n1067\n1068\n1069\n1070\n1071\n1072\n1073\n1074\n1075\n1076\n1077\n1078\n1079\n1080\n1081\n1082\n1083\n1084\n1085\n1086\n1087\n1088\n1089\n1090\n1091\n1092\n1093\n1094\n1095\n1096\n1097\n1098\n1099\n1100\n1101\n1102\n1103\n1104\n1105\n1106\n1107\n1108\n1109\n1110\n1111\n1112\n1113\n1114\n1115\n1116\n1117\n1118\n1119\n1120\n1121\n1122\n1123\n1124\n1125\n1126\n1127\n1128\n1129\n1130\n1131\n1132\n1133\n1134\n1135\n1136\n1137\n1138\n1139\n1140\n1141\n1142\n1143\n1144\n1145\n1146\n1147\n1148\n1149\n1150\n1151\n1152\n1153\n1154\n1155\n1156\n1157\n1158\n1159\n1160\n1161\n1162\n1163\n1164\n1165\n1166\n1167\n1168\n1169\n1170\n1171\n1172\n1173\n1174\n1175\n1176\n1177\n1178\n1179\n1180\n1181\n1182\n1183\n1184\n1185\n1186\n1187\n1188\n1189\n1190\n1191\n1192\n1193\n1194\n1195\n1196\n1197\n1198\n1199\n1200\n1201\n1202\n1203\n1204\n1205\n1206\n1207\n1208\n1209\n1210\n1211\n1212\n1213\n1214\n1215\n1216\n1217\n1218\n1219\n1220\n1221\n1222\n1223\n1224\n1225\n1226\n1227\n1228\n1229\n1230\n1231\n1232\n1233\n1234\n1235\n1236\n1237\n1238\n1239\n1240\n1241\n1242\n1243\n1244\n1245\n1246\n1247\n1248\n1249\n1250\n1251\n1252\n1253\n1254\n1255\n1256\n1257\n1258\n1259\n1260\n1261\n1262\n1263\n1264\n1265\n1266\n1267\n1268\n1269\n1270\n1271\n1272\n1273\n1274\n1275\n1276\n1277\n1278\n1279\n1280\n1281\n1282\n1283\n1284\n1285\n1286\n1287\n1288\n1289\n1290\n1291\n1292\n1293\n1294\n1295\n1296\n1297\n1298\n1299\n1300\n1301\n1302\n1303\n1304\n1305\n1306\n1307\n1308\n1309\n"},{"order":1,"originalType":"","type":"boolean","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Survived","description":"0\n0\n0\n1\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n1\n0\n0\n0\n1\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n1\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n1\n0\n1\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n1\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n0\n0\n0\n0\n0\n"}],"totalRows":null,"type":"genericTable","collapsed":true,"info":{"metrics":null,"archiveInfo":null,"archiveInfoV2":null,"blobFileInfo":null,"convertCsvInfo":null,"kernelReference":null},"settings":{"csvSettings":null,"bigQuerySettings":null,"bigQueryMirrorSettings":null,"storageSettings":null,"remoteUrlSettings":null,"remoteGithubSettings":null},"render":null,"children":[],"name":"","description":null}],"name":"gender_submission.csv","description":"892,0\n893,0\n894,0\n895,0\n896,0\n897,0\n898,0\n899,0\n900,0\n901,0\n902,0\n903,0\n904,1\n905,0a\n906,1\n907,0\n908,0\n909,0\n910,0\n911,0\n912,1\n913,0\n914,0\n915,0\n916,1\n917,0\n918,0\n919,0\n920,0\n921,0\n922,0\n923,0\n924,0\n925,0\n926,1\n927,0\n928,0\n929,0\n930,0\n931,1\n932,0\n933,0\n934,0\n935,0\n936,1\n937,0\n938,0\n939,0\n940,1\n941,0\n942,1\n943,0\n944,0\n945,1\n946,0\n947,0\n948,0\n949,0\n950,0\n951,1\n952,0\n953,0\n954,0\n955,0\n956,1\n957,0\n958,0\n959,0\n960,0\n961,1\n962,\n963,0\n964,0\n965,0\n966,1\n967,1\n968,0\n969,0\n970,0\n971,0\n972,0\n973,1\n974,0\n975,0\n976,0\n977,0\n978,0\n979,0\n980,0\n981,0\n982,0\n983,0\n984,0\n985,0\n986,0\n987,0\n988,1\n989,0\n990,0\n991,0\n992,1\n993,0\n994,0\n995,0\n996,0\n997,0\n998,0\n999,0\n1000,0\n1001,0\n1002,0\n1003,0\n1004,0\n1005,0\n1006,1\n1007,0\n1008,0\n1009,0\n1010,1\n1011,0\n1012,0\n1013,0\n1014,1\n1015,0\n1016,0\n1017,0\n1018,0\n1019,0\n1020,0\n1021,0\n1022,0\n1023,0\n1024,0\n1025,0\n1026,0\n1027,0\n1028,0\n1029,0\n1030,0\n1031,0\n1032,0\n1033,1\n1034,1\n1035,0\n1036,0\n1037,0\n1038,1\n1039,0\n1040,0\n1041,0\n1042,1\n1043,0\n1044,0\n1045,0\n1046,0\n1047,0\n1048,1\n1049,0\n1050,0\n1051,0\n1052,0\n1053,0\n1054,0\n1055,0\n1056,0\n1057,0\n1058,1\n1059,0\n1060,0\n1061,0\n1062,0\n1063,0\n1064,0\n1065,0\n1066,0\n1067,0\n1068,0\n1069,1\n1070,0\n1071,1\n1072,0\n1073,1\n1074,1\n1075,0\n1076,1\n1077,0\n1078,0\n1079,0\n1080,1\n1081,0\n1082,0\n1083,0\n1084,0\n1085,0\n1086,0\n1087,0\n1088,1\n1089,0\n1090,0\n1091,0\n1092,0\n1093,0\n1094,1\n1095,0\n1096,0\n1097,0\n1098,0\n1099,0\n1100,0\n1101,0\n1102,0\n1103,0\n1104,1\n1105,0\n1106,0\n1107,0\n1108,0\n1109,1\n1110,1\n1111,0\n1112,0\n1113,0\n1114,0\n1115,0\n1116,0\n1117,0\n1118,0\n1119,0\n1120,0\n1121,0\n1122,1\n1123,0\n1124,0\n1125,0\n1126,1\n1127,0\n1128,1\n1129,0\n1130,0\n1131,1\n1132,0\n1133,0\n1134,1\n1135,0\n1136,0\n1137,1\n1138,0\n1139,0\n1140,0\n1141,0\n1142,0\n1143,0\n1144,1\n1145,0\n1146,0\n1147,0\n1148,0\n1149,0\n1150,0\n1151,0\n1152,0\n1153,0\n1154,0\n1155,0\n1156,0\n1157,0\n1158,0\n1159,0\n1160,0\n1161,0\n1162,1\n1163,0\n1164,1\n1165,0\n1166,0\n1167,0\n1168,0\n1169,0\n1170,0\n1171,0\n1172,0\n1173,0\n1174,0\n1175,0\n1176,0\n1177,0\n1178,0\n1179,1\n1180,0\n1181,0\n1182,0\n1183,0\n1184,0\n1185,1\n1186,0\n1187,0\n1188,0\n1189,0\n1190,1\n1191,0\n1192,0\n1193,0\n1194,0\n1195,0\n1196,0\n1197,0\n1198,1\n1199,0\n1200,1\n1201,0\n1202,0\n1203,0\n1204,0\n1205,0\n1206,1\n1207,0\n1208,1\n1209,0\n1210,0\n1211,0\n1212,0\n1213,0\n1214,0\n1215,0\n1216,1\n1217,0\n1218,0\n1219,1\n1220,0\n1221,0\n1222,0\n1223,0\n1224,0\n1225,0\n1226,0\n1227,0\n1228,0\n1229,0\n1230,0\n1231,0\n1232,0\n1233,0\n1234,1\n1235,1\n1236,0\n1237,0\n1238,0\n1239,0\n1240,0\n1241,0\n1242,1\n1243,0\n1244,1\n1245,1\n1246,0\n1247,0\n1248,1\n1249,0\n1250,0\n1251,0\n1252,1\n1253,0\n1254,0\n1255,0\n1256,1\n1257,1\n1258,0\n1259,0\n1260,0\n1261,0\n1262,0\n1263,1\n1264,0\n1265,0\n1266,1\n1267,1\n1268,0\n1269,0\n1270,1\n1271,0\n1272,0\n1273,0\n1274,0\n1275,0\n1276,0\n1277,1\n1278,0\n1279,0\n1280,0\n1281,0\n1282,1\n1283,0\n1284,0\n1285,0\n1286,0\n1287,1\n1288,0\n1289,1\n1290,0\n1291,0\n1292,1\n1293,0\n1294,0\n1295,1\n1296,0\n1297,0\n1298,0\n1299,1\n1300,0\n1301,0\n1302,0\n1303,1\n1304,0\n1305,0\n1306,1\n1307,0\n1308,0\n1309,0"},{"id":63841,"blobFileId":2613,"databundleVersionId":26502,"databundleVersionObjectType":"file","url":null,"relativePath":"../input/test.csv","creationDate":"2013-06-28T13:40:24.227Z","isDummy":false,"size":28629,"fullPath":"../input/titanic/test.csv","previewUrl":"kernels/competition-preview/3136?relativePath=test.csv","downloadUrl":"/c/titanic/download/test.csv","fileType":".csv","contentLength":28629,"contentType":"text/csv","contentMD5":"dTO4Lq5LWCYQy9aKpjawFw==","validationErrors":null,"type":"databundleVersionObject","collapsed":false,"info":{"metrics":{"tableMetrics":{"exception":null,"rowCount":418},"columnMetrics":[]},"archiveInfo":null,"archiveInfoV2":null,"blobFileInfo":null,"convertCsvInfo":null,"kernelReference":null},"settings":{"csvSettings":{"delimiter":",","includesHeader":true},"bigQuerySettings":null,"bigQueryMirrorSettings":null,"storageSettings":null,"remoteUrlSettings":null,"remoteGithubSettings":null},"render":null,"children":[{"columns":[{"order":0,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"PassengerId","description":"1"},{"order":1,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Pclass","description":"1"},{"order":2,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Name","description":"the name of the passenger"},{"order":3,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Sex","description":null},{"order":4,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Age","description":null},{"order":5,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"SibSp","description":"of siblings / spouses aboard the Titanic"},{"order":6,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Parch","description":"of parents / children aboard the Titanic"},{"order":7,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Ticket","description":"Ticket number"},{"order":8,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Fare","description":"Passenger fare"},{"order":9,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Cabin","description":"Cabin number"},{"order":10,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Embarked","description":"Port of Embarkation"}],"totalRows":null,"type":"genericTable","collapsed":true,"info":{"metrics":null,"archiveInfo":null,"archiveInfoV2":null,"blobFileInfo":null,"convertCsvInfo":null,"kernelReference":null},"settings":{"csvSettings":null,"bigQuerySettings":null,"bigQueryMirrorSettings":null,"storageSettings":null,"remoteUrlSettings":null,"remoteGithubSettings":null},"render":null,"children":[],"name":"","description":null}],"name":"test.csv","description":"test data to check the accuracy of the model created\n"},{"id":63840,"blobFileId":2307,"databundleVersionId":26502,"databundleVersionObjectType":"file","url":null,"relativePath":"../input/train.csv","creationDate":"2013-06-28T13:40:25.23Z","isDummy":false,"size":61194,"fullPath":"../input/titanic/train.csv","previewUrl":"kernels/competition-preview/3136?relativePath=train.csv","downloadUrl":"/c/titanic/download/train.csv","fileType":".csv","contentLength":61194,"contentType":"text/csv","contentMD5":"IwnMXwR4Ltm7YBbZ9OOBzw==","validationErrors":null,"type":"databundleVersionObject","collapsed":false,"info":{"metrics":{"tableMetrics":{"exception":null,"rowCount":891},"columnMetrics":[]},"archiveInfo":null,"archiveInfoV2":null,"blobFileInfo":null,"convertCsvInfo":null,"kernelReference":null},"settings":{"csvSettings":{"delimiter":",","includesHeader":true},"bigQuerySettings":null,"bigQueryMirrorSettings":null,"storageSettings":null,"remoteUrlSettings":null,"remoteGithubSettings":null},"render":null,"children":[{"columns":[{"order":0,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"PassengerId","description":"type should be integers"},{"order":1,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Survived","description":"Survived or Not "},{"order":2,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Pclass","description":"Class of Travel"},{"order":3,"originalType":"","type":"string","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Name","description":"Name of Passenger"},{"order":4,"originalType":"","type":"string","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Sex","description":"Gender"},{"order":5,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Age","description":"Age of Passengers"},{"order":6,"originalType":"","type":"string","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"SibSp","description":"Number of Sibling/Spouse aboard"},{"order":7,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Parch","description":"Number of Parent/Child aboard"},{"order":8,"originalType":"","type":"string","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Ticket","description":null},{"order":9,"originalType":"","type":"numeric","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Fare","description":null},{"order":10,"originalType":"","type":"string","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Cabin","description":null},{"order":11,"originalType":"","type":"string","extendedType":null,"isNullable":false,"isPrimaryKey":false,"isLabel":false,"info":null,"name":"Embarked","description":"The port in which a passenger has embarked. C - Cherbourg, S - Southampton, Q = Queenstown"}],"totalRows":null,"type":"genericTable","collapsed":true,"info":{"metrics":null,"archiveInfo":null,"archiveInfoV2":null,"blobFileInfo":null,"convertCsvInfo":null,"kernelReference":null},"settings":{"csvSettings":null,"bigQuerySettings":null,"bigQueryMirrorSettings":null,"storageSettings":null,"remoteUrlSettings":null,"remoteGithubSettings":null},"render":null,"children":[],"name":"","description":null}],"name":"train.csv","description":"contains data \n"}],"name":"Titanic: Machine Learning from Disaster","description":"\u003ch3\u003eOverview\u003c/h3\u003e\n\u003cp\u003eThe data has been split into two groups:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003etraining set (train.csv)\u003c/li\u003e\n\u003cli\u003etest set (test.csv)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cb\u003e The training set \u003c/b\u003eshould be used to build your machine learning models. For the training set, we provide the outcome (also known as the “ground truth”) for each passenger. Your model will be based on “features” like passengers’ gender and class. You can also use \u003ca href=\u0022https://triangleinequality.wordpress.com/2013/09/08/basic-feature-engineering-with-the-titanic-data/\u0022 target=\u0022_blank\u0022\u003e feature engineering \u003c/a\u003eto create new features.\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eThe test set \u003c/b\u003eshould be used to see how well your model performs on unseen data. For the test set, we do not provide the ground truth for each passenger. It is your job to predict these outcomes. For each passenger in the test set, use the model you trained to predict whether or not they survived the sinking of the Titanic.\u003c/p\u003e\n\u003cp\u003eWe also include \u003cb\u003egender_submission.csv\u003c/b\u003e, a set of predictions that assume all and only female passengers survive, as an example of what a submission file should look like.\u003c/p\u003e\n\u003ch3\u003eData Dictionary\u003c/h3\u003e\n\u003ctable style=\u0022width: 100%;\u0022\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\u003cth\u003e\u003cb\u003eVariable\u003c/b\u003e\u003c/th\u003e\u003cth\u003e\u003cb\u003eDefinition\u003c/b\u003e\u003c/th\u003e\u003cth\u003e\u003cb\u003eKey\u003c/b\u003e\u003c/th\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003esurvival\u003c/td\u003e\n\u003ctd\u003eSurvival\u003c/td\u003e\n\u003ctd\u003e0 = No, 1 = Yes\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003epclass\u003c/td\u003e\n\u003ctd\u003eTicket class\u003c/td\u003e\n\u003ctd\u003e1 = 1st, 2 = 2nd, 3 = 3rd\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003esex\u003c/td\u003e\n\u003ctd\u003eSex\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eAge\u003c/td\u003e\n\u003ctd\u003eAge in years\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003esibsp\u003c/td\u003e\n\u003ctd\u003e# of siblings / spouses aboard the Titanic\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eparch\u003c/td\u003e\n\u003ctd\u003e# of parents / children aboard the Titanic\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eticket\u003c/td\u003e\n\u003ctd\u003eTicket number\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003efare\u003c/td\u003e\n\u003ctd\u003ePassenger fare\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ecabin\u003c/td\u003e\n\u003ctd\u003eCabin number\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eembarked\u003c/td\u003e\n\u003ctd\u003ePort of Embarkation\u003c/td\u003e\n\u003ctd\u003eC = Cherbourg, Q = Queenstown, S = Southampton\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003eVariable Notes\u003c/h3\u003e\n\u003cp\u003e\u003cb\u003epclass\u003c/b\u003e: A proxy for socio-economic status (SES)\u003cbr /\u003e 1st = Upper\u003cbr /\u003e 2nd = Middle\u003cbr /\u003e 3rd = Lower\u003cbr /\u003e\u003cbr /\u003e \u003cb\u003eage\u003c/b\u003e: Age is fractional if less than 1. If the age is estimated, is it in the form of xx.5\u003cbr /\u003e\u003cbr /\u003e \u003cb\u003esibsp\u003c/b\u003e: The dataset defines family relations in this way...\u003cbr /\u003e Sibling = brother, sister, stepbrother, stepsister\u003cbr /\u003e Spouse = husband, wife (mistresses and fiancés were ignored)\u003cbr /\u003e\u003cbr /\u003e \u003cb\u003eparch\u003c/b\u003e: The dataset defines family relations in this way...\u003cbr /\u003e Parent = mother, father\u003cbr /\u003e Child = daughter, son, stepdaughter, stepson\u003cbr /\u003e Some children travelled only with a nanny, therefore parch=0 for them.\u003c/p\u003e"}],"versions":[{"id":7632756,"kernelVersionId":null,"isForkParent":false,"isNotebook":true,"languageName":"R","lastRunTime":"2018-11-22T03:40:53.52Z","linesChangedFromPrevious":0,"linesDeletedFromPrevious":48,"linesInsertedFromPrevious":62,"outputFilesTotalSizeBytes":0,"runInfo":{"dockerfileUrl":"https://github.com/Kaggle/docker-rstats/blob/master/Dockerfile","dockerHubUrl":"https://registry.hub.docker.com/u/kaggle/rstats/","dockerImageId":"sha256:44f873c106e586a747e1f2a3f2fcb4f6827ba48b41ecd862601742984907ff5c","dockerImageName":"gcr.io/kaggle-private-byod/rstats","exitCode":0,"failureMessage":"","isValidStatus":true,"runTimeSeconds":111.771542802002,"succeeded":true,"timeoutExceeded":false,"usedAllSpace":false},"status":"complete","title":"Jetbrain Day Kr 2018 - Titanic Prediction","url":"/syleeie/jetbrain-day-kr-2018-titanic-prediction?scriptVersionId=7632756","versionNumber":5,"hasVersionNumber":true,"isRedacted":false,"versionAuthor":null},{"id":7608803,"kernelVersionId":null,"isForkParent":false,"isNotebook":true,"languageName":"R","lastRunTime":"2018-11-21T11:37:47.227Z","linesChangedFromPrevious":0,"linesDeletedFromPrevious":41,"linesInsertedFromPrevious":572,"outputFilesTotalSizeBytes":0,"runInfo":{"dockerfileUrl":"https://github.com/Kaggle/docker-rstats/blob/master/Dockerfile","dockerHubUrl":"https://registry.hub.docker.com/u/kaggle/rstats/","dockerImageId":"sha256:44f873c106e586a747e1f2a3f2fcb4f6827ba48b41ecd862601742984907ff5c","dockerImageName":"gcr.io/kaggle-private-byod/rstats","exitCode":0,"failureMessage":"","isValidStatus":true,"runTimeSeconds":115.942934033003,"succeeded":true,"timeoutExceeded":false,"usedAllSpace":false},"status":"complete","title":"Jetbrain Day Kr 2018 - Titanic Prediction","url":"/syleeie/jetbrain-day-kr-2018-titanic-prediction?scriptVersionId=7608803","versionNumber":4,"hasVersionNumber":true,"isRedacted":false,"versionAuthor":null},{"id":7569800,"kernelVersionId":null,"isForkParent":false,"isNotebook":true,"languageName":"R","lastRunTime":"2018-11-20T10:59:57.41Z","linesChangedFromPrevious":0,"linesDeletedFromPrevious":0,"linesInsertedFromPrevious":0,"outputFilesTotalSizeBytes":0,"runInfo":{"dockerfileUrl":"https://github.com/Kaggle/docker-rstats/blob/master/Dockerfile","dockerHubUrl":"https://registry.hub.docker.com/u/kaggle/rstats/","dockerImageId":"sha256:44f873c106e586a747e1f2a3f2fcb4f6827ba48b41ecd862601742984907ff5c","dockerImageName":"gcr.io/kaggle-private-byod/rstats","exitCode":0,"failureMessage":"","isValidStatus":true,"runTimeSeconds":85.2891704240001,"succeeded":true,"timeoutExceeded":false,"usedAllSpace":false},"status":"complete","title":"Jetbrain Day Kr 2018 - Titanic Prediction","url":"/syleeie/jetbrain-day-kr-2018-titanic-prediction?scriptVersionId=7569800","versionNumber":3,"hasVersionNumber":true,"isRedacted":false,"versionAuthor":null},{"id":7536248,"kernelVersionId":null,"isForkParent":false,"isNotebook":true,"languageName":"R","lastRunTime":"2018-11-19T12:06:13.23Z","linesChangedFromPrevious":0,"linesDeletedFromPrevious":0,"linesInsertedFromPrevious":0,"outputFilesTotalSizeBytes":0,"runInfo":{"dockerfileUrl":"https://github.com/Kaggle/docker-rstats/blob/master/Dockerfile","dockerHubUrl":"https://registry.hub.docker.com/u/kaggle/rstats/","dockerImageId":"sha256:44f873c106e586a747e1f2a3f2fcb4f6827ba48b41ecd862601742984907ff5c","dockerImageName":"gcr.io/kaggle-private-byod/rstats","exitCode":0,"failureMessage":"","isValidStatus":true,"runTimeSeconds":87.096825421002,"succeeded":true,"timeoutExceeded":false,"usedAllSpace":false},"status":"complete","title":"Jetbrain Day Kr 2018 - Titanic Prediction","url":"/syleeie/jetbrain-day-kr-2018-titanic-prediction?scriptVersionId=7536248","versionNumber":2,"hasVersionNumber":true,"isRedacted":false,"versionAuthor":null},{"id":7536118,"kernelVersionId":null,"isForkParent":false,"isNotebook":true,"languageName":"R","lastRunTime":"2018-11-19T12:02:37.113Z","linesChangedFromPrevious":0,"linesDeletedFromPrevious":100,"linesInsertedFromPrevious":136,"outputFilesTotalSizeBytes":0,"runInfo":{"dockerfileUrl":"https://github.com/Kaggle/docker-rstats/blob/master/Dockerfile","dockerHubUrl":"https://registry.hub.docker.com/u/kaggle/rstats/","dockerImageId":"sha256:44f873c106e586a747e1f2a3f2fcb4f6827ba48b41ecd862601742984907ff5c","dockerImageName":"gcr.io/kaggle-private-byod/rstats","exitCode":0,"failureMessage":"","isValidStatus":true,"runTimeSeconds":83.177847130999,"succeeded":true,"timeoutExceeded":false,"usedAllSpace":false},"status":"complete","title":"Jetbrain Day Kr 2018 - Titanic Prediction","url":"/syleeie/jetbrain-day-kr-2018-titanic-prediction?scriptVersionId=7536118","versionNumber":1,"hasVersionNumber":true,"isRedacted":false,"versionAuthor":null},{"id":6344966,"kernelVersionId":null,"isForkParent":true,"isNotebook":true,"languageName":"R","lastRunTime":"2018-10-10T00:22:20.983Z","linesChangedFromPrevious":0,"linesDeletedFromPrevious":0,"linesInsertedFromPrevious":0,"outputFilesTotalSizeBytes":1069243,"runInfo":{"dockerfileUrl":"https://github.com/Kaggle/docker-rstats/blob/master/Dockerfile","dockerHubUrl":"https://registry.hub.docker.com/u/kaggle/rstats/","dockerImageId":"sha256:44f873c106e586a747e1f2a3f2fcb4f6827ba48b41ecd862601742984907ff5c","dockerImageName":"gcr.io/kaggle-private-byod/rstats","exitCode":0,"failureMessage":"","isValidStatus":true,"runTimeSeconds":81.8269550080004,"succeeded":true,"timeoutExceeded":false,"usedAllSpace":false},"status":"complete","title":"Titanic WCG+XGBoost [0.84688]","url":"/cdeotte/titanic-wcg-xgboost-0-84688","versionNumber":0,"hasVersionNumber":false,"isRedacted":false,"versionAuthor":null}],"categories":{"categories":[{"id":null,"name":"multiple data sources","displayName":null,"fullPath":null,"listingUrl":null,"tagUrl":null,"fontAwesomeIcon":null,"description":"This script uses multiple data sources","isInherited":true,"datasetCount":0,"competitionCount":0,"scriptCount":0,"totalCount":0}],"type":"script"},"submitToCompetitionInfo":null,"downloadAllFilesUrl":"/kernels/svzip/7632756","submission":null,"menuLinks":[{"href":"/syleeie/jetbrain-day-kr-2018-titanic-prediction/notebook","text":"Notebook","title":"Notebook","tab":"notebook","count":null,"showZeroCountExplicitly":false,"reportEventCategory":null,"reportEventType":null},{"href":"/syleeie/jetbrain-day-kr-2018-titanic-prediction/code","text":"Code","title":"Code","tab":"code","count":null,"showZeroCountExplicitly":false,"reportEventCategory":null,"reportEventType":null},{"href":"/syleeie/jetbrain-day-kr-2018-titanic-prediction/data","text":"Data","title":"Data","tab":"data","count":3,"showZeroCountExplicitly":false,"reportEventCategory":null,"reportEventType":null},{"href":"/syleeie/jetbrain-day-kr-2018-titanic-prediction/output","text":"Output","title":"Output","tab":"output","count":null,"showZeroCountExplicitly":false,"reportEventCategory":null,"reportEventType":null},{"href":"/syleeie/jetbrain-day-kr-2018-titanic-prediction/comments","text":"Comments","title":"Comments","tab":"comments","count":0,"showZeroCountExplicitly":true,"reportEventCategory":null,"reportEventType":null},{"href":"/syleeie/jetbrain-day-kr-2018-titanic-prediction/log","text":"Log","title":"Log","tab":"log","count":null,"showZeroCountExplicitly":false,"reportEventCategory":null,"reportEventType":null},{"href":"/syleeie/jetbrain-day-kr-2018-titanic-prediction/versions","text":"Versions","title":"Versions","tab":"versions","count":5,"showZeroCountExplicitly":false,"reportEventCategory":null,"reportEventType":null},{"href":"/syleeie/jetbrain-day-kr-2018-titanic-prediction/forks","text":"Forks","title":"Forks","tab":"forks","count":6,"showZeroCountExplicitly":false,"reportEventCategory":null,"reportEventType":null}],"rightMenuLinks":[],"callToAction":{"href":"/kernels/fork-version/7632756","text":"Fork Notebook","title":"Fork Notebook","tab":null,"count":null,"showZeroCountExplicitly":false,"reportEventCategory":"kernels","reportEventType":"anonymousKernelForkCreation"},"voteButton":{"totalVotes":6,"hasAlreadyVotedUp":false,"hasAlreadyVotedDown":false,"canUpvote":true,"canDownvote":false,"voteUpUrl":"/kernels/vote?id=2141451","voteDownUrl":null,"voters":[{"avatarThumbnailUrl":"https://storage.googleapis.com/kaggle-avatars/thumbnails/default-thumb.png","displayName":"Pankaj","profileUrl":"/jindal25","tier":"Novice","tierInt":0,"userId":361421,"userName":"jindal25"},{"avatarThumbnailUrl":"https://storage.googleapis.com/kaggle-avatars/thumbnails/1370076-kg.jpg","displayName":"vmuller","profileUrl":"/mullervilmos","tier":"Contributor","tierInt":1,"userId":1370076,"userName":"mullervilmos"},{"avatarThumbnailUrl":"https://storage.googleapis.com/kaggle-avatars/thumbnails/1723677-kg.jpg","displayName":"Chris Deotte","profileUrl":"/cdeotte","tier":"Grandmaster","tierInt":4,"userId":1723677,"userName":"cdeotte"},{"avatarThumbnailUrl":"https://storage.googleapis.com/kaggle-avatars/thumbnails/1772671-kg.JPG","displayName":"Conrad.K","profileUrl":"/conradkang","tier":"Novice","tierInt":0,"userId":1772671,"userName":"conradkang"},{"avatarThumbnailUrl":"https://storage.googleapis.com/kaggle-avatars/thumbnails/2650868-kg.jpg","displayName":"Enjoy_PG","profileUrl":"/lasthere","tier":"Novice","tierInt":0,"userId":2650868,"userName":"lasthere"},{"avatarThumbnailUrl":"https://storage.googleapis.com/kaggle-avatars/thumbnails/2675171-kg.jpg","displayName":"Shushrut","profileUrl":"/mysticvalley","tier":"Contributor","tierInt":1,"userId":2675171,"userName":"mysticvalley"}],"currentUserInfo":null,"showVoters":true,"alwaysShowVoters":true},"parentDataSource":null,"parentName":"multiple data sources","parentUrl":"#data","thumbnailImageUrl":"/static/images/multiple-datasource.png","canWrite":false,"canAdminister":false,"datasetHidden":false,"forkParentIsRedacted":false,"forkDiffLinesChanged":0,"forkDiffLinesDeleted":0,"forkDiffLinesInserted":0,"forkDiffUrl":null,"forkParentAuthorDisplayName":null,"forkParentAuthorUrl":null,"forkParentTitle":null,"forkParentUrl":null,"canSeeDataExplorerV2":true,"canSeeRevampedViewer":true,"canSeeInnerTableOfContents":true,"simplifiedViewer":false,"kernelOutputDataset":null});performance && performance.mark && performance.mark("KernelViewer.componentCouldBootstrap");</script>

<form action="/syleeie/jetbrain-day-kr-2018-titanic-prediction" id="__AjaxAntiForgeryForm" method="post"><input name="X-XSRF-TOKEN" type="hidden" value="CfDJ8LdUzqlsSWBPr4Ce3rb9VL_TuZef5tBDDGv6qS7XNOW7BkzIw4iOCNZFiNEAwq8JvfyjRdRqR5qjDTD4qCNaC8stG0NdiA-jnxOrKuyMJOBwBhZE-Sf0nkshDA30SQTEzicitLErqpa0D0gPzpoBlBo" /></form>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        "HTML-CSS": {
            preferredFont: "TeX",
            availableFonts: ["STIX", "TeX"],
            linebreaks: {
                automatic: true
            },
            EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
        },
        tex2jax: {
            inlineMath: [["\\(", "\\)"], ["\\\\(", "\\\\)"]],
            displayMath: [["$$", "$$"], ["\\[", "\\]"]],
            processEscapes: true,
            ignoreClass: "tex2jax_ignore|dno"
        },
        TeX: {
            noUndefined: {
                attributes: {
                    mathcolor: "red",
                    mathbackground: "#FFEEEE",
                    mathsize: "90%"
                }
            }
        },
        Macros: {
            href: "{}"
        },
        skipStartupTypeset: true,
        messageStyle: "none"
    });
</script>
<script type="text/javascript" async crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>



    </div>

        <div class="site-layout__footer">
            <footer class="site-footer">
    <div class="site-footer__content">
        <div class="site-footer__copyright">
            <span>&copy; 2019 Kaggle Inc</span>
        </div>
        <nav class="site-footer__nav">
            <a href="/team">Our Team</a>
            <a href="/terms">Terms</a>
            <a href="/privacy">Privacy</a>
            <a href="/contact">Contact/Support</a>
        </nav>
        <nav class="site-footer__social">
            <div data-component-name="SocialIcons" style="display: flex; flex-direction: column; flex: 1 0 auto;"></div><script>var Kaggle=window.Kaggle||{};Kaggle.State=Kaggle.State||[];Kaggle.State.push();performance && performance.mark && performance.mark("SocialIcons.componentCouldBootstrap");</script>
        </nav>
    </div>
</footer>

        </div>
</div>




</body>
</html>
